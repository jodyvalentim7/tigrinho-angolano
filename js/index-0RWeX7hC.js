var ch = e => { throw TypeError(e) }; var Il = (e, t, n) => t.has(e) || ch("Cannot " + n); var A = (e, t, n) => (Il(e, t, "read from private field"), n ? n.call(e) : t.get(e)), te = (e, t, n) => t.has(e) ? ch("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), X = (e, t, n, r) => (Il(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), Le = (e, t, n) => (Il(e, t, "access private method"), n); var vo = (e, t, n, r) => ({ set _(s) { X(e, t, s, n) }, get _() { return A(e, t, r) } }); function vw(e, t) { for (var n = 0; n < t.length; n++) { const r = t[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const s in r) if (s !== "default" && !(s in e)) { const i = Object.getOwnPropertyDescriptor(r, s); i && Object.defineProperty(e, s, i.get ? i : { enumerable: !0, get: () => r[s] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s); new MutationObserver(s => { for (const i of s) if (i.type === "childList") for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function n(s) { const i = {}; return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function r(s) { if (s.ep) return; s.ep = !0; const i = n(s); fetch(s.href, i) } })(); function Mg(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var Dg = { exports: {} }, Za = {}, Og = { exports: {} }, Z = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var to = Symbol.for("react.element"), xw = Symbol.for("react.portal"), ww = Symbol.for("react.fragment"), bw = Symbol.for("react.strict_mode"), Sw = Symbol.for("react.profiler"), Tw = Symbol.for("react.provider"), Cw = Symbol.for("react.context"), Ew = Symbol.for("react.forward_ref"), Pw = Symbol.for("react.suspense"), kw = Symbol.for("react.memo"), Aw = Symbol.for("react.lazy"), dh = Symbol.iterator; function Rw(e) { return e === null || typeof e != "object" ? null : (e = dh && e[dh] || e["@@iterator"], typeof e == "function" ? e : null) } var Fg = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Lg = Object.assign, Ig = {}; function zs(e, t, n) { this.props = e, this.context = t, this.refs = Ig, this.updater = n || Fg } zs.prototype.isReactComponent = {}; zs.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; zs.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function Vg() { } Vg.prototype = zs.prototype; function hd(e, t, n) { this.props = e, this.context = t, this.refs = Ig, this.updater = n || Fg } var pd = hd.prototype = new Vg; pd.constructor = hd; Lg(pd, zs.prototype); pd.isPureReactComponent = !0; var fh = Array.isArray, _g = Object.prototype.hasOwnProperty, md = { current: null }, zg = { key: !0, ref: !0, __self: !0, __source: !0 }; function Bg(e, t, n) { var r, s = {}, i = null, o = null; if (t != null) for (r in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (i = "" + t.key), t) _g.call(t, r) && !zg.hasOwnProperty(r) && (s[r] = t[r]); var a = arguments.length - 2; if (a === 1) s.children = n; else if (1 < a) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; s.children = l } if (e && e.defaultProps) for (r in a = e.defaultProps, a) s[r] === void 0 && (s[r] = a[r]); return { $$typeof: to, type: e, key: i, ref: o, props: s, _owner: md.current } } function Nw(e, t) { return { $$typeof: to, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function gd(e) { return typeof e == "object" && e !== null && e.$$typeof === to } function jw(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var hh = /\/+/g; function Vl(e, t) { return typeof e == "object" && e !== null && e.key != null ? jw("" + e.key) : t.toString(36) } function Ho(e, t, n, r, s) { var i = typeof e; (i === "undefined" || i === "boolean") && (e = null); var o = !1; if (e === null) o = !0; else switch (i) { case "string": case "number": o = !0; break; case "object": switch (e.$$typeof) { case to: case xw: o = !0 } }if (o) return o = e, s = s(o), e = r === "" ? "." + Vl(o, 0) : r, fh(s) ? (n = "", e != null && (n = e.replace(hh, "$&/") + "/"), Ho(s, t, n, "", function (u) { return u })) : s != null && (gd(s) && (s = Nw(s, n + (!s.key || o && o.key === s.key ? "" : ("" + s.key).replace(hh, "$&/") + "/") + e)), t.push(s)), 1; if (o = 0, r = r === "" ? "." : r + ":", fh(e)) for (var a = 0; a < e.length; a++) { i = e[a]; var l = r + Vl(i, a); o += Ho(i, t, n, l, s) } else if (l = Rw(e), typeof l == "function") for (e = l.call(e), a = 0; !(i = e.next()).done;)i = i.value, l = r + Vl(i, a++), o += Ho(i, t, n, l, s); else if (i === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return o } function xo(e, t, n) { if (e == null) return e; var r = [], s = 0; return Ho(e, r, "", "", function (i) { return t.call(n, i, s++) }), r } function Mw(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var Qe = { current: null }, Ko = { transition: null }, Dw = { ReactCurrentDispatcher: Qe, ReactCurrentBatchConfig: Ko, ReactCurrentOwner: md }; function $g() { throw Error("act(...) is not supported in production builds of React.") } Z.Children = { map: xo, forEach: function (e, t, n) { xo(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return xo(e, function () { t++ }), t }, toArray: function (e) { return xo(e, function (t) { return t }) || [] }, only: function (e) { if (!gd(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; Z.Component = zs; Z.Fragment = ww; Z.Profiler = Sw; Z.PureComponent = hd; Z.StrictMode = bw; Z.Suspense = Pw; Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Dw; Z.act = $g; Z.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = Lg({}, e.props), s = e.key, i = e.ref, o = e._owner; if (t != null) { if (t.ref !== void 0 && (i = t.ref, o = md.current), t.key !== void 0 && (s = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) _g.call(t, l) && !zg.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } return { $$typeof: to, type: e.type, key: s, ref: i, props: r, _owner: o } }; Z.createContext = function (e) { return e = { $$typeof: Cw, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: Tw, _context: e }, e.Consumer = e }; Z.createElement = Bg; Z.createFactory = function (e) { var t = Bg.bind(null, e); return t.type = e, t }; Z.createRef = function () { return { current: null } }; Z.forwardRef = function (e) { return { $$typeof: Ew, render: e } }; Z.isValidElement = gd; Z.lazy = function (e) { return { $$typeof: Aw, _payload: { _status: -1, _result: e }, _init: Mw } }; Z.memo = function (e, t) { return { $$typeof: kw, type: e, compare: t === void 0 ? null : t } }; Z.startTransition = function (e) { var t = Ko.transition; Ko.transition = {}; try { e() } finally { Ko.transition = t } }; Z.unstable_act = $g; Z.useCallback = function (e, t) { return Qe.current.useCallback(e, t) }; Z.useContext = function (e) { return Qe.current.useContext(e) }; Z.useDebugValue = function () { }; Z.useDeferredValue = function (e) { return Qe.current.useDeferredValue(e) }; Z.useEffect = function (e, t) { return Qe.current.useEffect(e, t) }; Z.useId = function () { return Qe.current.useId() }; Z.useImperativeHandle = function (e, t, n) { return Qe.current.useImperativeHandle(e, t, n) }; Z.useInsertionEffect = function (e, t) { return Qe.current.useInsertionEffect(e, t) }; Z.useLayoutEffect = function (e, t) { return Qe.current.useLayoutEffect(e, t) }; Z.useMemo = function (e, t) { return Qe.current.useMemo(e, t) }; Z.useReducer = function (e, t, n) { return Qe.current.useReducer(e, t, n) }; Z.useRef = function (e) { return Qe.current.useRef(e) }; Z.useState = function (e) { return Qe.current.useState(e) }; Z.useSyncExternalStore = function (e, t, n) { return Qe.current.useSyncExternalStore(e, t, n) }; Z.useTransition = function () { return Qe.current.useTransition() }; Z.version = "18.3.1"; Og.exports = Z; var w = Og.exports; const D = Mg(w), Ug = vw({ __proto__: null, default: D }, [w]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ow = w, Fw = Symbol.for("react.element"), Lw = Symbol.for("react.fragment"), Iw = Object.prototype.hasOwnProperty, Vw = Ow.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, _w = { key: !0, ref: !0, __self: !0, __source: !0 }; function Wg(e, t, n) { var r, s = {}, i = null, o = null; n !== void 0 && (i = "" + n), t.key !== void 0 && (i = "" + t.key), t.ref !== void 0 && (o = t.ref); for (r in t) Iw.call(t, r) && !_w.hasOwnProperty(r) && (s[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) s[r] === void 0 && (s[r] = t[r]); return { $$typeof: Fw, type: e, key: i, ref: o, props: s, _owner: Vw.current } } Za.Fragment = Lw; Za.jsx = Wg; Za.jsxs = Wg; Dg.exports = Za; var g = Dg.exports, Hg = { exports: {} }, pt = {}, Kg = { exports: {} }, Gg = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(k, R) { var F = k.length; k.push(R); e: for (; 0 < F;) { var W = F - 1 >>> 1, B = k[W]; if (0 < s(B, R)) k[W] = R, k[F] = B, F = W; else break e } } function n(k) { return k.length === 0 ? null : k[0] } function r(k) { if (k.length === 0) return null; var R = k[0], F = k.pop(); if (F !== R) { k[0] = F; e: for (var W = 0, B = k.length, Y = B >>> 1; W < Y;) { var q = 2 * (W + 1) - 1, he = k[q], Se = q + 1, J = k[Se]; if (0 > s(he, F)) Se < B && 0 > s(J, he) ? (k[W] = J, k[Se] = F, W = Se) : (k[W] = he, k[q] = F, W = q); else if (Se < B && 0 > s(J, F)) k[W] = J, k[Se] = F, W = Se; else break e } } return R } function s(k, R) { var F = k.sortIndex - R.sortIndex; return F !== 0 ? F : k.id - R.id } if (typeof performance == "object" && typeof performance.now == "function") { var i = performance; e.unstable_now = function () { return i.now() } } else { var o = Date, a = o.now(); e.unstable_now = function () { return o.now() - a } } var l = [], u = [], c = 1, d = null, f = 3, h = !1, x = !1, y = !1, b = typeof setTimeout == "function" ? setTimeout : null, p = typeof clearTimeout == "function" ? clearTimeout : null, m = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function v(k) { for (var R = n(u); R !== null;) { if (R.callback === null) r(u); else if (R.startTime <= k) r(u), R.sortIndex = R.expirationTime, t(l, R); else break; R = n(u) } } function S(k) { if (y = !1, v(k), !x) if (n(l) !== null) x = !0, U(T); else { var R = n(u); R !== null && V(S, R.startTime - k) } } function T(k, R) { x = !1, y && (y = !1, p(P), P = -1), h = !0; var F = f; try { for (v(R), d = n(l); d !== null && (!(d.expirationTime > R) || k && !z());) { var W = d.callback; if (typeof W == "function") { d.callback = null, f = d.priorityLevel; var B = W(d.expirationTime <= R); R = e.unstable_now(), typeof B == "function" ? d.callback = B : d === n(l) && r(l), v(R) } else r(l); d = n(l) } if (d !== null) var Y = !0; else { var q = n(u); q !== null && V(S, q.startTime - R), Y = !1 } return Y } finally { d = null, f = F, h = !1 } } var C = !1, E = null, P = -1, N = 5, j = -1; function z() { return !(e.unstable_now() - j < N) } function L() { if (E !== null) { var k = e.unstable_now(); j = k; var R = !0; try { R = E(!0, k) } finally { R ? H() : (C = !1, E = null) } } else C = !1 } var H; if (typeof m == "function") H = function () { m(L) }; else if (typeof MessageChannel < "u") { var O = new MessageChannel, K = O.port2; O.port1.onmessage = L, H = function () { K.postMessage(null) } } else H = function () { b(L, 0) }; function U(k) { E = k, C || (C = !0, H()) } function V(k, R) { P = b(function () { k(e.unstable_now()) }, R) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (k) { k.callback = null }, e.unstable_continueExecution = function () { x || h || (x = !0, U(T)) }, e.unstable_forceFrameRate = function (k) { 0 > k || 125 < k ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : N = 0 < k ? Math.floor(1e3 / k) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return f }, e.unstable_getFirstCallbackNode = function () { return n(l) }, e.unstable_next = function (k) { switch (f) { case 1: case 2: case 3: var R = 3; break; default: R = f }var F = f; f = R; try { return k() } finally { f = F } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (k, R) { switch (k) { case 1: case 2: case 3: case 4: case 5: break; default: k = 3 }var F = f; f = k; try { return R() } finally { f = F } }, e.unstable_scheduleCallback = function (k, R, F) { var W = e.unstable_now(); switch (typeof F == "object" && F !== null ? (F = F.delay, F = typeof F == "number" && 0 < F ? W + F : W) : F = W, k) { case 1: var B = -1; break; case 2: B = 250; break; case 5: B = 1073741823; break; case 4: B = 1e4; break; default: B = 5e3 }return B = F + B, k = { id: c++, callback: R, priorityLevel: k, startTime: F, expirationTime: B, sortIndex: -1 }, F > W ? (k.sortIndex = F, t(u, k), n(l) === null && k === n(u) && (y ? (p(P), P = -1) : y = !0, V(S, F - W))) : (k.sortIndex = B, t(l, k), x || h || (x = !0, U(T))), k }, e.unstable_shouldYield = z, e.unstable_wrapCallback = function (k) { var R = f; return function () { var F = f; f = R; try { return k.apply(this, arguments) } finally { f = F } } } })(Gg); Kg.exports = Gg; var zw = Kg.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Bw = w, ht = zw; function M(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Xg = new Set, ki = {}; function _r(e, t) { Rs(e, t), Rs(e + "Capture", t) } function Rs(e, t) { for (ki[e] = t, e = 0; e < t.length; e++)Xg.add(t[e]) } var yn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Ou = Object.prototype.hasOwnProperty, $w = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ph = {}, mh = {}; function Uw(e) { return Ou.call(mh, e) ? !0 : Ou.call(ph, e) ? !1 : $w.test(e) ? mh[e] = !0 : (ph[e] = !0, !1) } function Ww(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function Hw(e, t, n, r) { if (t === null || typeof t > "u" || Ww(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function Ye(e, t, n, r, s, i, o) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = s, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = o } var Fe = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { Fe[e] = new Ye(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; Fe[t] = new Ye(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { Fe[e] = new Ye(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { Fe[e] = new Ye(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { Fe[e] = new Ye(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { Fe[e] = new Ye(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { Fe[e] = new Ye(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { Fe[e] = new Ye(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { Fe[e] = new Ye(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var yd = /[\-:]([a-z])/g; function vd(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(yd, vd); Fe[t] = new Ye(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(yd, vd); Fe[t] = new Ye(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(yd, vd); Fe[t] = new Ye(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { Fe[e] = new Ye(e, 1, !1, e.toLowerCase(), null, !1, !1) }); Fe.xlinkHref = new Ye("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { Fe[e] = new Ye(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function xd(e, t, n, r) { var s = Fe.hasOwnProperty(t) ? Fe[t] : null; (s !== null ? s.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (Hw(t, n, s, r) && (n = null), r || s === null ? Uw(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : s.mustUseProperty ? e[s.propertyName] = n === null ? s.type === 3 ? !1 : "" : n : (t = s.attributeName, r = s.attributeNamespace, n === null ? e.removeAttribute(t) : (s = s.type, n = s === 3 || s === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var Cn = Bw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, wo = Symbol.for("react.element"), Xr = Symbol.for("react.portal"), Qr = Symbol.for("react.fragment"), wd = Symbol.for("react.strict_mode"), Fu = Symbol.for("react.profiler"), Qg = Symbol.for("react.provider"), Yg = Symbol.for("react.context"), bd = Symbol.for("react.forward_ref"), Lu = Symbol.for("react.suspense"), Iu = Symbol.for("react.suspense_list"), Sd = Symbol.for("react.memo"), On = Symbol.for("react.lazy"), qg = Symbol.for("react.offscreen"), gh = Symbol.iterator; function qs(e) { return e === null || typeof e != "object" ? null : (e = gh && e[gh] || e["@@iterator"], typeof e == "function" ? e : null) } var ve = Object.assign, _l; function li(e) {
  if (_l === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); _l = t && t[1] || "" } return `
`+ _l + e
} var zl = !1; function Bl(e, t) {
  if (!e || zl) return ""; zl = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (u) { var r = u } Reflect.construct(e, [], t) } else { try { t.call() } catch (u) { r = u } e.call(t.prototype) } else { try { throw Error() } catch (u) { r = u } e() } } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var s = u.stack.split(`
`), i = r.stack.split(`
`), o = s.length - 1, a = i.length - 1; 1 <= o && 0 <= a && s[o] !== i[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (s[o] !== i[a]) {
        if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || s[o] !== i[a]) {
          var l = `
`+ s[o].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
        } while (1 <= o && 0 <= a); break
      }
    }
  } finally { zl = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? li(e) : ""
} function Kw(e) { switch (e.tag) { case 5: return li(e.type); case 16: return li("Lazy"); case 13: return li("Suspense"); case 19: return li("SuspenseList"); case 0: case 2: case 15: return e = Bl(e.type, !1), e; case 11: return e = Bl(e.type.render, !1), e; case 1: return e = Bl(e.type, !0), e; default: return "" } } function Vu(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case Qr: return "Fragment"; case Xr: return "Portal"; case Fu: return "Profiler"; case wd: return "StrictMode"; case Lu: return "Suspense"; case Iu: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Yg: return (e.displayName || "Context") + ".Consumer"; case Qg: return (e._context.displayName || "Context") + ".Provider"; case bd: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Sd: return t = e.displayName || null, t !== null ? t : Vu(e.type) || "Memo"; case On: t = e._payload, e = e._init; try { return Vu(e(t)) } catch { } }return null } function Gw(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Vu(t); case 8: return t === wd ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function tr(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function Zg(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function Xw(e) { var t = Zg(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var s = n.get, i = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return s.call(this) }, set: function (o) { r = "" + o, i.call(this, o) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (o) { r = "" + o }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function bo(e) { e._valueTracker || (e._valueTracker = Xw(e)) } function Jg(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = Zg(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function fa(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function _u(e, t) { var n = t.checked; return ve({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function yh(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = tr(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function e0(e, t) { t = t.checked, t != null && xd(e, "checked", t, !1) } function zu(e, t) { e0(e, t); var n = tr(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Bu(e, t.type, n) : t.hasOwnProperty("defaultValue") && Bu(e, t.type, tr(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function vh(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function Bu(e, t, n) { (t !== "number" || fa(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var ui = Array.isArray; function ds(e, t, n, r) { if (e = e.options, t) { t = {}; for (var s = 0; s < n.length; s++)t["$" + n[s]] = !0; for (n = 0; n < e.length; n++)s = t.hasOwnProperty("$" + e[n].value), e[n].selected !== s && (e[n].selected = s), s && r && (e[n].defaultSelected = !0) } else { for (n = "" + tr(n), t = null, s = 0; s < e.length; s++) { if (e[s].value === n) { e[s].selected = !0, r && (e[s].defaultSelected = !0); return } t !== null || e[s].disabled || (t = e[s]) } t !== null && (t.selected = !0) } } function $u(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(M(91)); return ve({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function xh(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(M(92)); if (ui(n)) { if (1 < n.length) throw Error(M(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: tr(n) } } function t0(e, t) { var n = tr(t.value), r = tr(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function wh(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function n0(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Uu(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? n0(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var So, r0 = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, s) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, s) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (So = So || document.createElement("div"), So.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = So.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function Ai(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var hi = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Qw = ["Webkit", "ms", "Moz", "O"]; Object.keys(hi).forEach(function (e) { Qw.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), hi[t] = hi[e] }) }); function s0(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || hi.hasOwnProperty(e) && hi[e] ? ("" + t).trim() : t + "px" } function i0(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, s = s0(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, s) : e[n] = s } } var Yw = ve({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Wu(e, t) { if (t) { if (Yw[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(M(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(M(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(M(61)) } if (t.style != null && typeof t.style != "object") throw Error(M(62)) } } function Hu(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Ku = null; function Td(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Gu = null, fs = null, hs = null; function bh(e) { if (e = so(e)) { if (typeof Gu != "function") throw Error(M(280)); var t = e.stateNode; t && (t = rl(t), Gu(e.stateNode, e.type, t)) } } function o0(e) { fs ? hs ? hs.push(e) : hs = [e] : fs = e } function a0() { if (fs) { var e = fs, t = hs; if (hs = fs = null, bh(e), t) for (e = 0; e < t.length; e++)bh(t[e]) } } function l0(e, t) { return e(t) } function u0() { } var $l = !1; function c0(e, t, n) { if ($l) return e(t, n); $l = !0; try { return l0(e, t, n) } finally { $l = !1, (fs !== null || hs !== null) && (u0(), a0()) } } function Ri(e, t) { var n = e.stateNode; if (n === null) return null; var r = rl(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(M(231, t, typeof n)); return n } var Xu = !1; if (yn) try { var Zs = {}; Object.defineProperty(Zs, "passive", { get: function () { Xu = !0 } }), window.addEventListener("test", Zs, Zs), window.removeEventListener("test", Zs, Zs) } catch { Xu = !1 } function qw(e, t, n, r, s, i, o, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { t.apply(n, u) } catch (c) { this.onError(c) } } var pi = !1, ha = null, pa = !1, Qu = null, Zw = { onError: function (e) { pi = !0, ha = e } }; function Jw(e, t, n, r, s, i, o, a, l) { pi = !1, ha = null, qw.apply(Zw, arguments) } function eb(e, t, n, r, s, i, o, a, l) { if (Jw.apply(this, arguments), pi) { if (pi) { var u = ha; pi = !1, ha = null } else throw Error(M(198)); pa || (pa = !0, Qu = u) } } function zr(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function d0(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Sh(e) { if (zr(e) !== e) throw Error(M(188)) } function tb(e) { var t = e.alternate; if (!t) { if (t = zr(e), t === null) throw Error(M(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var s = n.return; if (s === null) break; var i = s.alternate; if (i === null) { if (r = s.return, r !== null) { n = r; continue } break } if (s.child === i.child) { for (i = s.child; i;) { if (i === n) return Sh(s), e; if (i === r) return Sh(s), t; i = i.sibling } throw Error(M(188)) } if (n.return !== r.return) n = s, r = i; else { for (var o = !1, a = s.child; a;) { if (a === n) { o = !0, n = s, r = i; break } if (a === r) { o = !0, r = s, n = i; break } a = a.sibling } if (!o) { for (a = i.child; a;) { if (a === n) { o = !0, n = i, r = s; break } if (a === r) { o = !0, r = i, n = s; break } a = a.sibling } if (!o) throw Error(M(189)) } } if (n.alternate !== r) throw Error(M(190)) } if (n.tag !== 3) throw Error(M(188)); return n.stateNode.current === n ? e : t } function f0(e) { return e = tb(e), e !== null ? h0(e) : null } function h0(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = h0(e); if (t !== null) return t; e = e.sibling } return null } var p0 = ht.unstable_scheduleCallback, Th = ht.unstable_cancelCallback, nb = ht.unstable_shouldYield, rb = ht.unstable_requestPaint, be = ht.unstable_now, sb = ht.unstable_getCurrentPriorityLevel, Cd = ht.unstable_ImmediatePriority, m0 = ht.unstable_UserBlockingPriority, ma = ht.unstable_NormalPriority, ib = ht.unstable_LowPriority, g0 = ht.unstable_IdlePriority, Ja = null, en = null; function ob(e) { if (en && typeof en.onCommitFiberRoot == "function") try { en.onCommitFiberRoot(Ja, e, void 0, (e.current.flags & 128) === 128) } catch { } } var zt = Math.clz32 ? Math.clz32 : ub, ab = Math.log, lb = Math.LN2; function ub(e) { return e >>>= 0, e === 0 ? 32 : 31 - (ab(e) / lb | 0) | 0 } var To = 64, Co = 4194304; function ci(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function ga(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, s = e.suspendedLanes, i = e.pingedLanes, o = n & 268435455; if (o !== 0) { var a = o & ~s; a !== 0 ? r = ci(a) : (i &= o, i !== 0 && (r = ci(i))) } else o = n & ~s, o !== 0 ? r = ci(o) : i !== 0 && (r = ci(i)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & s) && (s = r & -r, i = t & -t, s >= i || s === 16 && (i & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - zt(t), s = 1 << n, r |= e[n], t &= ~s; return r } function cb(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function db(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, s = e.expirationTimes, i = e.pendingLanes; 0 < i;) { var o = 31 - zt(i), a = 1 << o, l = s[o]; l === -1 ? (!(a & n) || a & r) && (s[o] = cb(a, t)) : l <= t && (e.expiredLanes |= a), i &= ~a } } function Yu(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function y0() { var e = To; return To <<= 1, !(To & 4194240) && (To = 64), e } function Ul(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function no(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - zt(t), e[t] = n } function fb(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var s = 31 - zt(n), i = 1 << s; t[s] = 0, r[s] = -1, e[s] = -1, n &= ~i } } function Ed(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - zt(n), s = 1 << r; s & t | e[r] & t && (e[r] |= t), n &= ~s } } var ne = 0; function v0(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var x0, Pd, w0, b0, S0, qu = !1, Eo = [], Gn = null, Xn = null, Qn = null, Ni = new Map, ji = new Map, Ln = [], hb = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Ch(e, t) { switch (e) { case "focusin": case "focusout": Gn = null; break; case "dragenter": case "dragleave": Xn = null; break; case "mouseover": case "mouseout": Qn = null; break; case "pointerover": case "pointerout": Ni.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": ji.delete(t.pointerId) } } function Js(e, t, n, r, s, i) { return e === null || e.nativeEvent !== i ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: i, targetContainers: [s] }, t !== null && (t = so(t), t !== null && Pd(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, s !== null && t.indexOf(s) === -1 && t.push(s), e) } function pb(e, t, n, r, s) { switch (t) { case "focusin": return Gn = Js(Gn, e, t, n, r, s), !0; case "dragenter": return Xn = Js(Xn, e, t, n, r, s), !0; case "mouseover": return Qn = Js(Qn, e, t, n, r, s), !0; case "pointerover": var i = s.pointerId; return Ni.set(i, Js(Ni.get(i) || null, e, t, n, r, s)), !0; case "gotpointercapture": return i = s.pointerId, ji.set(i, Js(ji.get(i) || null, e, t, n, r, s)), !0 }return !1 } function T0(e) { var t = xr(e.target); if (t !== null) { var n = zr(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = d0(n), t !== null) { e.blockedOn = t, S0(e.priority, function () { w0(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Go(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Zu(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); Ku = r, n.target.dispatchEvent(r), Ku = null } else return t = so(n), t !== null && Pd(t), e.blockedOn = n, !1; t.shift() } return !0 } function Eh(e, t, n) { Go(e) && n.delete(t) } function mb() { qu = !1, Gn !== null && Go(Gn) && (Gn = null), Xn !== null && Go(Xn) && (Xn = null), Qn !== null && Go(Qn) && (Qn = null), Ni.forEach(Eh), ji.forEach(Eh) } function ei(e, t) { e.blockedOn === t && (e.blockedOn = null, qu || (qu = !0, ht.unstable_scheduleCallback(ht.unstable_NormalPriority, mb))) } function Mi(e) { function t(s) { return ei(s, e) } if (0 < Eo.length) { ei(Eo[0], e); for (var n = 1; n < Eo.length; n++) { var r = Eo[n]; r.blockedOn === e && (r.blockedOn = null) } } for (Gn !== null && ei(Gn, e), Xn !== null && ei(Xn, e), Qn !== null && ei(Qn, e), Ni.forEach(t), ji.forEach(t), n = 0; n < Ln.length; n++)r = Ln[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < Ln.length && (n = Ln[0], n.blockedOn === null);)T0(n), n.blockedOn === null && Ln.shift() } var ps = Cn.ReactCurrentBatchConfig, ya = !0; function gb(e, t, n, r) { var s = ne, i = ps.transition; ps.transition = null; try { ne = 1, kd(e, t, n, r) } finally { ne = s, ps.transition = i } } function yb(e, t, n, r) { var s = ne, i = ps.transition; ps.transition = null; try { ne = 4, kd(e, t, n, r) } finally { ne = s, ps.transition = i } } function kd(e, t, n, r) { if (ya) { var s = Zu(e, t, n, r); if (s === null) Jl(e, t, r, va, n), Ch(e, r); else if (pb(s, e, t, n, r)) r.stopPropagation(); else if (Ch(e, r), t & 4 && -1 < hb.indexOf(e)) { for (; s !== null;) { var i = so(s); if (i !== null && x0(i), i = Zu(e, t, n, r), i === null && Jl(e, t, r, va, n), i === s) break; s = i } s !== null && r.stopPropagation() } else Jl(e, t, r, null, n) } } var va = null; function Zu(e, t, n, r) { if (va = null, e = Td(r), e = xr(e), e !== null) if (t = zr(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = d0(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return va = e, null } function C0(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (sb()) { case Cd: return 1; case m0: return 4; case ma: case ib: return 16; case g0: return 536870912; default: return 16 }default: return 16 } } var Un = null, Ad = null, Xo = null; function E0() { if (Xo) return Xo; var e, t = Ad, n = t.length, r, s = "value" in Un ? Un.value : Un.textContent, i = s.length; for (e = 0; e < n && t[e] === s[e]; e++); var o = n - e; for (r = 1; r <= o && t[n - r] === s[i - r]; r++); return Xo = s.slice(e, 1 < r ? 1 - r : void 0) } function Qo(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function Po() { return !0 } function Ph() { return !1 } function mt(e) { function t(n, r, s, i, o) { this._reactName = n, this._targetInst = s, this.type = r, this.nativeEvent = i, this.target = o, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(i) : i[a]); return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? Po : Ph, this.isPropagationStopped = Ph, this } return ve(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Po) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Po) }, persist: function () { }, isPersistent: Po }), t } var Bs = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Rd = mt(Bs), ro = ve({}, Bs, { view: 0, detail: 0 }), vb = mt(ro), Wl, Hl, ti, el = ve({}, ro, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Nd, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ti && (ti && e.type === "mousemove" ? (Wl = e.screenX - ti.screenX, Hl = e.screenY - ti.screenY) : Hl = Wl = 0, ti = e), Wl) }, movementY: function (e) { return "movementY" in e ? e.movementY : Hl } }), kh = mt(el), xb = ve({}, el, { dataTransfer: 0 }), wb = mt(xb), bb = ve({}, ro, { relatedTarget: 0 }), Kl = mt(bb), Sb = ve({}, Bs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Tb = mt(Sb), Cb = ve({}, Bs, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), Eb = mt(Cb), Pb = ve({}, Bs, { data: 0 }), Ah = mt(Pb), kb = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Ab = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Rb = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Nb(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = Rb[e]) ? !!t[e] : !1 } function Nd() { return Nb } var jb = ve({}, ro, { key: function (e) { if (e.key) { var t = kb[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = Qo(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Ab[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Nd, charCode: function (e) { return e.type === "keypress" ? Qo(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Qo(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Mb = mt(jb), Db = ve({}, el, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Rh = mt(Db), Ob = ve({}, ro, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Nd }), Fb = mt(Ob), Lb = ve({}, Bs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Ib = mt(Lb), Vb = ve({}, el, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), _b = mt(Vb), zb = [9, 13, 27, 32], jd = yn && "CompositionEvent" in window, mi = null; yn && "documentMode" in document && (mi = document.documentMode); var Bb = yn && "TextEvent" in window && !mi, P0 = yn && (!jd || mi && 8 < mi && 11 >= mi), Nh = " ", jh = !1; function k0(e, t) { switch (e) { case "keyup": return zb.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function A0(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Yr = !1; function $b(e, t) { switch (e) { case "compositionend": return A0(t); case "keypress": return t.which !== 32 ? null : (jh = !0, Nh); case "textInput": return e = t.data, e === Nh && jh ? null : e; default: return null } } function Ub(e, t) { if (Yr) return e === "compositionend" || !jd && k0(e, t) ? (e = E0(), Xo = Ad = Un = null, Yr = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return P0 && t.locale !== "ko" ? null : t.data; default: return null } } var Wb = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Mh(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!Wb[e.type] : t === "textarea" } function R0(e, t, n, r) { o0(r), t = xa(t, "onChange"), 0 < t.length && (n = new Rd("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var gi = null, Di = null; function Hb(e) { z0(e, 0) } function tl(e) { var t = Jr(e); if (Jg(t)) return e } function Kb(e, t) { if (e === "change") return t } var N0 = !1; if (yn) { var Gl; if (yn) { var Xl = "oninput" in document; if (!Xl) { var Dh = document.createElement("div"); Dh.setAttribute("oninput", "return;"), Xl = typeof Dh.oninput == "function" } Gl = Xl } else Gl = !1; N0 = Gl && (!document.documentMode || 9 < document.documentMode) } function Oh() { gi && (gi.detachEvent("onpropertychange", j0), Di = gi = null) } function j0(e) { if (e.propertyName === "value" && tl(Di)) { var t = []; R0(t, Di, e, Td(e)), c0(Hb, t) } } function Gb(e, t, n) { e === "focusin" ? (Oh(), gi = t, Di = n, gi.attachEvent("onpropertychange", j0)) : e === "focusout" && Oh() } function Xb(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return tl(Di) } function Qb(e, t) { if (e === "click") return tl(t) } function Yb(e, t) { if (e === "input" || e === "change") return tl(t) } function qb(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var $t = typeof Object.is == "function" ? Object.is : qb; function Oi(e, t) { if ($t(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var s = n[r]; if (!Ou.call(t, s) || !$t(e[s], t[s])) return !1 } return !0 } function Fh(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Lh(e, t) { var n = Fh(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = Fh(n) } } function M0(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? M0(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function D0() { for (var e = window, t = fa(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = fa(e.document) } return t } function Md(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function Zb(e) { var t = D0(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && M0(n.ownerDocument.documentElement, n)) { if (r !== null && Md(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var s = n.textContent.length, i = Math.min(r.start, s); r = r.end === void 0 ? i : Math.min(r.end, s), !e.extend && i > r && (s = r, r = i, i = s), s = Lh(n, i); var o = Lh(n, r); s && o && (e.rangeCount !== 1 || e.anchorNode !== s.node || e.anchorOffset !== s.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(s.node, s.offset), e.removeAllRanges(), i > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var Jb = yn && "documentMode" in document && 11 >= document.documentMode, qr = null, Ju = null, yi = null, ec = !1; function Ih(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; ec || qr == null || qr !== fa(r) || (r = qr, "selectionStart" in r && Md(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), yi && Oi(yi, r) || (yi = r, r = xa(Ju, "onSelect"), 0 < r.length && (t = new Rd("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = qr))) } function ko(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Zr = { animationend: ko("Animation", "AnimationEnd"), animationiteration: ko("Animation", "AnimationIteration"), animationstart: ko("Animation", "AnimationStart"), transitionend: ko("Transition", "TransitionEnd") }, Ql = {}, O0 = {}; yn && (O0 = document.createElement("div").style, "AnimationEvent" in window || (delete Zr.animationend.animation, delete Zr.animationiteration.animation, delete Zr.animationstart.animation), "TransitionEvent" in window || delete Zr.transitionend.transition); function nl(e) { if (Ql[e]) return Ql[e]; if (!Zr[e]) return e; var t = Zr[e], n; for (n in t) if (t.hasOwnProperty(n) && n in O0) return Ql[e] = t[n]; return e } var F0 = nl("animationend"), L0 = nl("animationiteration"), I0 = nl("animationstart"), V0 = nl("transitionend"), _0 = new Map, Vh = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function ur(e, t) { _0.set(e, t), _r(t, [e]) } for (var Yl = 0; Yl < Vh.length; Yl++) { var ql = Vh[Yl], eS = ql.toLowerCase(), tS = ql[0].toUpperCase() + ql.slice(1); ur(eS, "on" + tS) } ur(F0, "onAnimationEnd"); ur(L0, "onAnimationIteration"); ur(I0, "onAnimationStart"); ur("dblclick", "onDoubleClick"); ur("focusin", "onFocus"); ur("focusout", "onBlur"); ur(V0, "onTransitionEnd"); Rs("onMouseEnter", ["mouseout", "mouseover"]); Rs("onMouseLeave", ["mouseout", "mouseover"]); Rs("onPointerEnter", ["pointerout", "pointerover"]); Rs("onPointerLeave", ["pointerout", "pointerover"]); _r("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); _r("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); _r("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); _r("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); _r("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); _r("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var di = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), nS = new Set("cancel close invalid load scroll toggle".split(" ").concat(di)); function _h(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, eb(r, t, void 0, e), e.currentTarget = null } function z0(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], s = r.event; r = r.listeners; e: { var i = void 0; if (t) for (var o = r.length - 1; 0 <= o; o--) { var a = r[o], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== i && s.isPropagationStopped()) break e; _h(s, a, u), i = l } else for (o = 0; o < r.length; o++) { if (a = r[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== i && s.isPropagationStopped()) break e; _h(s, a, u), i = l } } } if (pa) throw e = Qu, pa = !1, Qu = null, e } function le(e, t) { var n = t[ic]; n === void 0 && (n = t[ic] = new Set); var r = e + "__bubble"; n.has(r) || (B0(t, e, 2, !1), n.add(r)) } function Zl(e, t, n) { var r = 0; t && (r |= 4), B0(n, e, r, t) } var Ao = "_reactListening" + Math.random().toString(36).slice(2); function Fi(e) { if (!e[Ao]) { e[Ao] = !0, Xg.forEach(function (n) { n !== "selectionchange" && (nS.has(n) || Zl(n, !1, e), Zl(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[Ao] || (t[Ao] = !0, Zl("selectionchange", !1, t)) } } function B0(e, t, n, r) { switch (C0(t)) { case 1: var s = gb; break; case 4: s = yb; break; default: s = kd }n = s.bind(null, t, n, e), s = void 0, !Xu || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (s = !0), r ? s !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: s }) : e.addEventListener(t, n, !0) : s !== void 0 ? e.addEventListener(t, n, { passive: s }) : e.addEventListener(t, n, !1) } function Jl(e, t, n, r, s) { var i = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var o = r.tag; if (o === 3 || o === 4) { var a = r.stateNode.containerInfo; if (a === s || a.nodeType === 8 && a.parentNode === s) break; if (o === 4) for (o = r.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === s || l.nodeType === 8 && l.parentNode === s)) return; o = o.return } for (; a !== null;) { if (o = xr(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { r = i = o; continue e } a = a.parentNode } } r = r.return } c0(function () { var u = i, c = Td(n), d = []; e: { var f = _0.get(e); if (f !== void 0) { var h = Rd, x = e; switch (e) { case "keypress": if (Qo(n) === 0) break e; case "keydown": case "keyup": h = Mb; break; case "focusin": x = "focus", h = Kl; break; case "focusout": x = "blur", h = Kl; break; case "beforeblur": case "afterblur": h = Kl; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": h = kh; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": h = wb; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": h = Fb; break; case F0: case L0: case I0: h = Tb; break; case V0: h = Ib; break; case "scroll": h = vb; break; case "wheel": h = _b; break; case "copy": case "cut": case "paste": h = Eb; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": h = Rh }var y = (t & 4) !== 0, b = !y && e === "scroll", p = y ? f !== null ? f + "Capture" : null : f; y = []; for (var m = u, v; m !== null;) { v = m; var S = v.stateNode; if (v.tag === 5 && S !== null && (v = S, p !== null && (S = Ri(m, p), S != null && y.push(Li(m, S, v)))), b) break; m = m.return } 0 < y.length && (f = new h(f, x, null, n, c), d.push({ event: f, listeners: y })) } } if (!(t & 7)) { e: { if (f = e === "mouseover" || e === "pointerover", h = e === "mouseout" || e === "pointerout", f && n !== Ku && (x = n.relatedTarget || n.fromElement) && (xr(x) || x[vn])) break e; if ((h || f) && (f = c.window === c ? c : (f = c.ownerDocument) ? f.defaultView || f.parentWindow : window, h ? (x = n.relatedTarget || n.toElement, h = u, x = x ? xr(x) : null, x !== null && (b = zr(x), x !== b || x.tag !== 5 && x.tag !== 6) && (x = null)) : (h = null, x = u), h !== x)) { if (y = kh, S = "onMouseLeave", p = "onMouseEnter", m = "mouse", (e === "pointerout" || e === "pointerover") && (y = Rh, S = "onPointerLeave", p = "onPointerEnter", m = "pointer"), b = h == null ? f : Jr(h), v = x == null ? f : Jr(x), f = new y(S, m + "leave", h, n, c), f.target = b, f.relatedTarget = v, S = null, xr(c) === u && (y = new y(p, m + "enter", x, n, c), y.target = v, y.relatedTarget = b, S = y), b = S, h && x) t: { for (y = h, p = x, m = 0, v = y; v; v = Kr(v))m++; for (v = 0, S = p; S; S = Kr(S))v++; for (; 0 < m - v;)y = Kr(y), m--; for (; 0 < v - m;)p = Kr(p), v--; for (; m--;) { if (y === p || p !== null && y === p.alternate) break t; y = Kr(y), p = Kr(p) } y = null } else y = null; h !== null && zh(d, f, h, y, !1), x !== null && b !== null && zh(d, b, x, y, !0) } } e: { if (f = u ? Jr(u) : window, h = f.nodeName && f.nodeName.toLowerCase(), h === "select" || h === "input" && f.type === "file") var T = Kb; else if (Mh(f)) if (N0) T = Yb; else { T = Xb; var C = Gb } else (h = f.nodeName) && h.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (T = Qb); if (T && (T = T(e, u))) { R0(d, T, n, c); break e } C && C(e, f, u), e === "focusout" && (C = f._wrapperState) && C.controlled && f.type === "number" && Bu(f, "number", f.value) } switch (C = u ? Jr(u) : window, e) { case "focusin": (Mh(C) || C.contentEditable === "true") && (qr = C, Ju = u, yi = null); break; case "focusout": yi = Ju = qr = null; break; case "mousedown": ec = !0; break; case "contextmenu": case "mouseup": case "dragend": ec = !1, Ih(d, n, c); break; case "selectionchange": if (Jb) break; case "keydown": case "keyup": Ih(d, n, c) }var E; if (jd) e: { switch (e) { case "compositionstart": var P = "onCompositionStart"; break e; case "compositionend": P = "onCompositionEnd"; break e; case "compositionupdate": P = "onCompositionUpdate"; break e }P = void 0 } else Yr ? k0(e, n) && (P = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (P = "onCompositionStart"); P && (P0 && n.locale !== "ko" && (Yr || P !== "onCompositionStart" ? P === "onCompositionEnd" && Yr && (E = E0()) : (Un = c, Ad = "value" in Un ? Un.value : Un.textContent, Yr = !0)), C = xa(u, P), 0 < C.length && (P = new Ah(P, e, null, n, c), d.push({ event: P, listeners: C }), E ? P.data = E : (E = A0(n), E !== null && (P.data = E)))), (E = Bb ? $b(e, n) : Ub(e, n)) && (u = xa(u, "onBeforeInput"), 0 < u.length && (c = new Ah("onBeforeInput", "beforeinput", null, n, c), d.push({ event: c, listeners: u }), c.data = E)) } z0(d, t) }) } function Li(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function xa(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var s = e, i = s.stateNode; s.tag === 5 && i !== null && (s = i, i = Ri(e, n), i != null && r.unshift(Li(e, i, s)), i = Ri(e, t), i != null && r.push(Li(e, i, s))), e = e.return } return r } function Kr(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function zh(e, t, n, r, s) { for (var i = t._reactName, o = []; n !== null && n !== r;) { var a = n, l = a.alternate, u = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && u !== null && (a = u, s ? (l = Ri(n, i), l != null && o.unshift(Li(n, l, a))) : s || (l = Ri(n, i), l != null && o.push(Li(n, l, a)))), n = n.return } o.length !== 0 && e.push({ event: t, listeners: o }) } var rS = /\r\n?/g, sS = /\u0000|\uFFFD/g; function Bh(e) {
  return (typeof e == "string" ? e : "" + e).replace(rS, `
`).replace(sS, "")
} function Ro(e, t, n) { if (t = Bh(t), Bh(e) !== t && n) throw Error(M(425)) } function wa() { } var tc = null, nc = null; function rc(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var sc = typeof setTimeout == "function" ? setTimeout : void 0, iS = typeof clearTimeout == "function" ? clearTimeout : void 0, $h = typeof Promise == "function" ? Promise : void 0, oS = typeof queueMicrotask == "function" ? queueMicrotask : typeof $h < "u" ? function (e) { return $h.resolve(null).then(e).catch(aS) } : sc; function aS(e) { setTimeout(function () { throw e }) } function eu(e, t) { var n = t, r = 0; do { var s = n.nextSibling; if (e.removeChild(n), s && s.nodeType === 8) if (n = s.data, n === "/$") { if (r === 0) { e.removeChild(s), Mi(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = s } while (n); Mi(t) } function Yn(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Uh(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var $s = Math.random().toString(36).slice(2), Zt = "__reactFiber$" + $s, Ii = "__reactProps$" + $s, vn = "__reactContainer$" + $s, ic = "__reactEvents$" + $s, lS = "__reactListeners$" + $s, uS = "__reactHandles$" + $s; function xr(e) { var t = e[Zt]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[vn] || n[Zt]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Uh(e); e !== null;) { if (n = e[Zt]) return n; e = Uh(e) } return t } e = n, n = e.parentNode } return null } function so(e) { return e = e[Zt] || e[vn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Jr(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(M(33)) } function rl(e) { return e[Ii] || null } var oc = [], es = -1; function cr(e) { return { current: e } } function ue(e) { 0 > es || (e.current = oc[es], oc[es] = null, es--) } function ie(e, t) { es++, oc[es] = e.current, e.current = t } var nr = {}, $e = cr(nr), tt = cr(!1), Dr = nr; function Ns(e, t) { var n = e.type.contextTypes; if (!n) return nr; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var s = {}, i; for (i in n) s[i] = t[i]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s } function nt(e) { return e = e.childContextTypes, e != null } function ba() { ue(tt), ue($e) } function Wh(e, t, n) { if ($e.current !== nr) throw Error(M(168)); ie($e, t), ie(tt, n) } function $0(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var s in r) if (!(s in t)) throw Error(M(108, Gw(e) || "Unknown", s)); return ve({}, n, r) } function Sa(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || nr, Dr = $e.current, ie($e, e), ie(tt, tt.current), !0 } function Hh(e, t, n) { var r = e.stateNode; if (!r) throw Error(M(169)); n ? (e = $0(e, t, Dr), r.__reactInternalMemoizedMergedChildContext = e, ue(tt), ue($e), ie($e, e)) : ue(tt), ie(tt, n) } var dn = null, sl = !1, tu = !1; function U0(e) { dn === null ? dn = [e] : dn.push(e) } function cS(e) { sl = !0, U0(e) } function dr() { if (!tu && dn !== null) { tu = !0; var e = 0, t = ne; try { var n = dn; for (ne = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } dn = null, sl = !1 } catch (s) { throw dn !== null && (dn = dn.slice(e + 1)), p0(Cd, dr), s } finally { ne = t, tu = !1 } } return null } var ts = [], ns = 0, Ta = null, Ca = 0, vt = [], xt = 0, Or = null, pn = 1, mn = ""; function gr(e, t) { ts[ns++] = Ca, ts[ns++] = Ta, Ta = e, Ca = t } function W0(e, t, n) { vt[xt++] = pn, vt[xt++] = mn, vt[xt++] = Or, Or = e; var r = pn; e = mn; var s = 32 - zt(r) - 1; r &= ~(1 << s), n += 1; var i = 32 - zt(t) + s; if (30 < i) { var o = s - s % 5; i = (r & (1 << o) - 1).toString(32), r >>= o, s -= o, pn = 1 << 32 - zt(t) + s | n << s | r, mn = i + e } else pn = 1 << i | n << s | r, mn = e } function Dd(e) { e.return !== null && (gr(e, 1), W0(e, 1, 0)) } function Od(e) { for (; e === Ta;)Ta = ts[--ns], ts[ns] = null, Ca = ts[--ns], ts[ns] = null; for (; e === Or;)Or = vt[--xt], vt[xt] = null, mn = vt[--xt], vt[xt] = null, pn = vt[--xt], vt[xt] = null } var dt = null, ct = null, fe = !1, _t = null; function H0(e, t) { var n = wt(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function Kh(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, dt = e, ct = Yn(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, dt = e, ct = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = Or !== null ? { id: pn, overflow: mn } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = wt(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, dt = e, ct = null, !0) : !1; default: return !1 } } function ac(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function lc(e) { if (fe) { var t = ct; if (t) { var n = t; if (!Kh(e, t)) { if (ac(e)) throw Error(M(418)); t = Yn(n.nextSibling); var r = dt; t && Kh(e, t) ? H0(r, n) : (e.flags = e.flags & -4097 | 2, fe = !1, dt = e) } } else { if (ac(e)) throw Error(M(418)); e.flags = e.flags & -4097 | 2, fe = !1, dt = e } } } function Gh(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; dt = e } function No(e) { if (e !== dt) return !1; if (!fe) return Gh(e), fe = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !rc(e.type, e.memoizedProps)), t && (t = ct)) { if (ac(e)) throw K0(), Error(M(418)); for (; t;)H0(e, t), t = Yn(t.nextSibling) } if (Gh(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(M(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { ct = Yn(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } ct = null } } else ct = dt ? Yn(e.stateNode.nextSibling) : null; return !0 } function K0() { for (var e = ct; e;)e = Yn(e.nextSibling) } function js() { ct = dt = null, fe = !1 } function Fd(e) { _t === null ? _t = [e] : _t.push(e) } var dS = Cn.ReactCurrentBatchConfig; function ni(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(M(309)); var r = n.stateNode } if (!r) throw Error(M(147, e)); var s = r, i = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === i ? t.ref : (t = function (o) { var a = s.refs; o === null ? delete a[i] : a[i] = o }, t._stringRef = i, t) } if (typeof e != "string") throw Error(M(284)); if (!n._owner) throw Error(M(290, e)) } return e } function jo(e, t) { throw e = Object.prototype.toString.call(t), Error(M(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Xh(e) { var t = e._init; return t(e._payload) } function G0(e) { function t(p, m) { if (e) { var v = p.deletions; v === null ? (p.deletions = [m], p.flags |= 16) : v.push(m) } } function n(p, m) { if (!e) return null; for (; m !== null;)t(p, m), m = m.sibling; return null } function r(p, m) { for (p = new Map; m !== null;)m.key !== null ? p.set(m.key, m) : p.set(m.index, m), m = m.sibling; return p } function s(p, m) { return p = er(p, m), p.index = 0, p.sibling = null, p } function i(p, m, v) { return p.index = v, e ? (v = p.alternate, v !== null ? (v = v.index, v < m ? (p.flags |= 2, m) : v) : (p.flags |= 2, m)) : (p.flags |= 1048576, m) } function o(p) { return e && p.alternate === null && (p.flags |= 2), p } function a(p, m, v, S) { return m === null || m.tag !== 6 ? (m = lu(v, p.mode, S), m.return = p, m) : (m = s(m, v), m.return = p, m) } function l(p, m, v, S) { var T = v.type; return T === Qr ? c(p, m, v.props.children, S, v.key) : m !== null && (m.elementType === T || typeof T == "object" && T !== null && T.$$typeof === On && Xh(T) === m.type) ? (S = s(m, v.props), S.ref = ni(p, m, v), S.return = p, S) : (S = na(v.type, v.key, v.props, null, p.mode, S), S.ref = ni(p, m, v), S.return = p, S) } function u(p, m, v, S) { return m === null || m.tag !== 4 || m.stateNode.containerInfo !== v.containerInfo || m.stateNode.implementation !== v.implementation ? (m = uu(v, p.mode, S), m.return = p, m) : (m = s(m, v.children || []), m.return = p, m) } function c(p, m, v, S, T) { return m === null || m.tag !== 7 ? (m = jr(v, p.mode, S, T), m.return = p, m) : (m = s(m, v), m.return = p, m) } function d(p, m, v) { if (typeof m == "string" && m !== "" || typeof m == "number") return m = lu("" + m, p.mode, v), m.return = p, m; if (typeof m == "object" && m !== null) { switch (m.$$typeof) { case wo: return v = na(m.type, m.key, m.props, null, p.mode, v), v.ref = ni(p, null, m), v.return = p, v; case Xr: return m = uu(m, p.mode, v), m.return = p, m; case On: var S = m._init; return d(p, S(m._payload), v) }if (ui(m) || qs(m)) return m = jr(m, p.mode, v, null), m.return = p, m; jo(p, m) } return null } function f(p, m, v, S) { var T = m !== null ? m.key : null; if (typeof v == "string" && v !== "" || typeof v == "number") return T !== null ? null : a(p, m, "" + v, S); if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case wo: return v.key === T ? l(p, m, v, S) : null; case Xr: return v.key === T ? u(p, m, v, S) : null; case On: return T = v._init, f(p, m, T(v._payload), S) }if (ui(v) || qs(v)) return T !== null ? null : c(p, m, v, S, null); jo(p, v) } return null } function h(p, m, v, S, T) { if (typeof S == "string" && S !== "" || typeof S == "number") return p = p.get(v) || null, a(m, p, "" + S, T); if (typeof S == "object" && S !== null) { switch (S.$$typeof) { case wo: return p = p.get(S.key === null ? v : S.key) || null, l(m, p, S, T); case Xr: return p = p.get(S.key === null ? v : S.key) || null, u(m, p, S, T); case On: var C = S._init; return h(p, m, v, C(S._payload), T) }if (ui(S) || qs(S)) return p = p.get(v) || null, c(m, p, S, T, null); jo(m, S) } return null } function x(p, m, v, S) { for (var T = null, C = null, E = m, P = m = 0, N = null; E !== null && P < v.length; P++) { E.index > P ? (N = E, E = null) : N = E.sibling; var j = f(p, E, v[P], S); if (j === null) { E === null && (E = N); break } e && E && j.alternate === null && t(p, E), m = i(j, m, P), C === null ? T = j : C.sibling = j, C = j, E = N } if (P === v.length) return n(p, E), fe && gr(p, P), T; if (E === null) { for (; P < v.length; P++)E = d(p, v[P], S), E !== null && (m = i(E, m, P), C === null ? T = E : C.sibling = E, C = E); return fe && gr(p, P), T } for (E = r(p, E); P < v.length; P++)N = h(E, p, P, v[P], S), N !== null && (e && N.alternate !== null && E.delete(N.key === null ? P : N.key), m = i(N, m, P), C === null ? T = N : C.sibling = N, C = N); return e && E.forEach(function (z) { return t(p, z) }), fe && gr(p, P), T } function y(p, m, v, S) { var T = qs(v); if (typeof T != "function") throw Error(M(150)); if (v = T.call(v), v == null) throw Error(M(151)); for (var C = T = null, E = m, P = m = 0, N = null, j = v.next(); E !== null && !j.done; P++, j = v.next()) { E.index > P ? (N = E, E = null) : N = E.sibling; var z = f(p, E, j.value, S); if (z === null) { E === null && (E = N); break } e && E && z.alternate === null && t(p, E), m = i(z, m, P), C === null ? T = z : C.sibling = z, C = z, E = N } if (j.done) return n(p, E), fe && gr(p, P), T; if (E === null) { for (; !j.done; P++, j = v.next())j = d(p, j.value, S), j !== null && (m = i(j, m, P), C === null ? T = j : C.sibling = j, C = j); return fe && gr(p, P), T } for (E = r(p, E); !j.done; P++, j = v.next())j = h(E, p, P, j.value, S), j !== null && (e && j.alternate !== null && E.delete(j.key === null ? P : j.key), m = i(j, m, P), C === null ? T = j : C.sibling = j, C = j); return e && E.forEach(function (L) { return t(p, L) }), fe && gr(p, P), T } function b(p, m, v, S) { if (typeof v == "object" && v !== null && v.type === Qr && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) { switch (v.$$typeof) { case wo: e: { for (var T = v.key, C = m; C !== null;) { if (C.key === T) { if (T = v.type, T === Qr) { if (C.tag === 7) { n(p, C.sibling), m = s(C, v.props.children), m.return = p, p = m; break e } } else if (C.elementType === T || typeof T == "object" && T !== null && T.$$typeof === On && Xh(T) === C.type) { n(p, C.sibling), m = s(C, v.props), m.ref = ni(p, C, v), m.return = p, p = m; break e } n(p, C); break } else t(p, C); C = C.sibling } v.type === Qr ? (m = jr(v.props.children, p.mode, S, v.key), m.return = p, p = m) : (S = na(v.type, v.key, v.props, null, p.mode, S), S.ref = ni(p, m, v), S.return = p, p = S) } return o(p); case Xr: e: { for (C = v.key; m !== null;) { if (m.key === C) if (m.tag === 4 && m.stateNode.containerInfo === v.containerInfo && m.stateNode.implementation === v.implementation) { n(p, m.sibling), m = s(m, v.children || []), m.return = p, p = m; break e } else { n(p, m); break } else t(p, m); m = m.sibling } m = uu(v, p.mode, S), m.return = p, p = m } return o(p); case On: return C = v._init, b(p, m, C(v._payload), S) }if (ui(v)) return x(p, m, v, S); if (qs(v)) return y(p, m, v, S); jo(p, v) } return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, m !== null && m.tag === 6 ? (n(p, m.sibling), m = s(m, v), m.return = p, p = m) : (n(p, m), m = lu(v, p.mode, S), m.return = p, p = m), o(p)) : n(p, m) } return b } var Ms = G0(!0), X0 = G0(!1), Ea = cr(null), Pa = null, rs = null, Ld = null; function Id() { Ld = rs = Pa = null } function Vd(e) { var t = Ea.current; ue(Ea), e._currentValue = t } function uc(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function ms(e, t) { Pa = e, Ld = rs = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (et = !0), e.firstContext = null) } function Et(e) { var t = e._currentValue; if (Ld !== e) if (e = { context: e, memoizedValue: t, next: null }, rs === null) { if (Pa === null) throw Error(M(308)); rs = e, Pa.dependencies = { lanes: 0, firstContext: e } } else rs = rs.next = e; return t } var wr = null; function _d(e) { wr === null ? wr = [e] : wr.push(e) } function Q0(e, t, n, r) { var s = t.interleaved; return s === null ? (n.next = n, _d(t)) : (n.next = s.next, s.next = n), t.interleaved = n, xn(e, r) } function xn(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var Fn = !1; function zd(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Y0(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function gn(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function qn(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, ee & 2) { var s = r.pending; return s === null ? t.next = t : (t.next = s.next, s.next = t), r.pending = t, xn(e, n) } return s = r.interleaved, s === null ? (t.next = t, _d(r)) : (t.next = s.next, s.next = t), r.interleaved = t, xn(e, n) } function Yo(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Ed(e, n) } } function Qh(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var s = null, i = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; i === null ? s = i = o : i = i.next = o, n = n.next } while (n !== null); i === null ? s = i = t : i = i.next = t } else s = i = t; n = { baseState: r.baseState, firstBaseUpdate: s, lastBaseUpdate: i, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function ka(e, t, n, r) { var s = e.updateQueue; Fn = !1; var i = s.firstBaseUpdate, o = s.lastBaseUpdate, a = s.shared.pending; if (a !== null) { s.shared.pending = null; var l = a, u = l.next; l.next = null, o === null ? i = u : o.next = u, o = l; var c = e.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== o && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (i !== null) { var d = s.baseState; o = 0, c = u = l = null, a = i; do { var f = a.lane, h = a.eventTime; if ((r & f) === f) { c !== null && (c = c.next = { eventTime: h, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var x = e, y = a; switch (f = t, h = n, y.tag) { case 1: if (x = y.payload, typeof x == "function") { d = x.call(h, d, f); break e } d = x; break e; case 3: x.flags = x.flags & -65537 | 128; case 0: if (x = y.payload, f = typeof x == "function" ? x.call(h, d, f) : x, f == null) break e; d = ve({}, d, f); break e; case 2: Fn = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, f = s.effects, f === null ? s.effects = [a] : f.push(a)) } else h = { eventTime: h, lane: f, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = h, l = d) : c = c.next = h, o |= f; if (a = a.next, a === null) { if (a = s.shared.pending, a === null) break; f = a, a = f.next, f.next = null, s.lastBaseUpdate = f, s.shared.pending = null } } while (!0); if (c === null && (l = d), s.baseState = l, s.firstBaseUpdate = u, s.lastBaseUpdate = c, t = s.shared.interleaved, t !== null) { s = t; do o |= s.lane, s = s.next; while (s !== t) } else i === null && (s.shared.lanes = 0); Lr |= o, e.lanes = o, e.memoizedState = d } } function Yh(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], s = r.callback; if (s !== null) { if (r.callback = null, r = n, typeof s != "function") throw Error(M(191, s)); s.call(r) } } } var io = {}, tn = cr(io), Vi = cr(io), _i = cr(io); function br(e) { if (e === io) throw Error(M(174)); return e } function Bd(e, t) { switch (ie(_i, t), ie(Vi, e), ie(tn, io), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Uu(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Uu(t, e) }ue(tn), ie(tn, t) } function Ds() { ue(tn), ue(Vi), ue(_i) } function q0(e) { br(_i.current); var t = br(tn.current), n = Uu(t, e.type); t !== n && (ie(Vi, e), ie(tn, n)) } function $d(e) { Vi.current === e && (ue(tn), ue(Vi)) } var me = cr(0); function Aa(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var nu = []; function Ud() { for (var e = 0; e < nu.length; e++)nu[e]._workInProgressVersionPrimary = null; nu.length = 0 } var qo = Cn.ReactCurrentDispatcher, ru = Cn.ReactCurrentBatchConfig, Fr = 0, ye = null, Pe = null, Ne = null, Ra = !1, vi = !1, zi = 0, fS = 0; function Ie() { throw Error(M(321)) } function Wd(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!$t(e[n], t[n])) return !1; return !0 } function Hd(e, t, n, r, s, i) { if (Fr = i, ye = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, qo.current = e === null || e.memoizedState === null ? gS : yS, e = n(r, s), vi) { i = 0; do { if (vi = !1, zi = 0, 25 <= i) throw Error(M(301)); i += 1, Ne = Pe = null, t.updateQueue = null, qo.current = vS, e = n(r, s) } while (vi) } if (qo.current = Na, t = Pe !== null && Pe.next !== null, Fr = 0, Ne = Pe = ye = null, Ra = !1, t) throw Error(M(300)); return e } function Kd() { var e = zi !== 0; return zi = 0, e } function Gt() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ne === null ? ye.memoizedState = Ne = e : Ne = Ne.next = e, Ne } function Pt() { if (Pe === null) { var e = ye.alternate; e = e !== null ? e.memoizedState : null } else e = Pe.next; var t = Ne === null ? ye.memoizedState : Ne.next; if (t !== null) Ne = t, Pe = e; else { if (e === null) throw Error(M(310)); Pe = e, e = { memoizedState: Pe.memoizedState, baseState: Pe.baseState, baseQueue: Pe.baseQueue, queue: Pe.queue, next: null }, Ne === null ? ye.memoizedState = Ne = e : Ne = Ne.next = e } return Ne } function Bi(e, t) { return typeof t == "function" ? t(e) : t } function su(e) { var t = Pt(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = Pe, s = r.baseQueue, i = n.pending; if (i !== null) { if (s !== null) { var o = s.next; s.next = i.next, i.next = o } r.baseQueue = s = i, n.pending = null } if (s !== null) { i = s.next, r = r.baseState; var a = o = null, l = null, u = i; do { var c = u.lane; if ((Fr & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var d = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = d, o = r) : l = l.next = d, ye.lanes |= c, Lr |= c } u = u.next } while (u !== null && u !== i); l === null ? o = r : l.next = a, $t(r, t.memoizedState) || (et = !0), t.memoizedState = r, t.baseState = o, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { s = e; do i = s.lane, ye.lanes |= i, Lr |= i, s = s.next; while (s !== e) } else s === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function iu(e) { var t = Pt(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = n.dispatch, s = n.pending, i = t.memoizedState; if (s !== null) { n.pending = null; var o = s = s.next; do i = e(i, o.action), o = o.next; while (o !== s); $t(i, t.memoizedState) || (et = !0), t.memoizedState = i, t.baseQueue === null && (t.baseState = i), n.lastRenderedState = i } return [i, r] } function Z0() { } function J0(e, t) { var n = ye, r = Pt(), s = t(), i = !$t(r.memoizedState, s); if (i && (r.memoizedState = s, et = !0), r = r.queue, Gd(ny.bind(null, n, r, e), [e]), r.getSnapshot !== t || i || Ne !== null && Ne.memoizedState.tag & 1) { if (n.flags |= 2048, $i(9, ty.bind(null, n, r, s, t), void 0, null), je === null) throw Error(M(349)); Fr & 30 || ey(n, t, s) } return s } function ey(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = ye.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ye.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function ty(e, t, n, r) { t.value = n, t.getSnapshot = r, ry(t) && sy(e) } function ny(e, t, n) { return n(function () { ry(t) && sy(e) }) } function ry(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !$t(e, n) } catch { return !0 } } function sy(e) { var t = xn(e, 1); t !== null && Bt(t, e, 1, -1) } function qh(e) { var t = Gt(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Bi, lastRenderedState: e }, t.queue = e, e = e.dispatch = mS.bind(null, ye, e), [t.memoizedState, e] } function $i(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = ye.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ye.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function iy() { return Pt().memoizedState } function Zo(e, t, n, r) { var s = Gt(); ye.flags |= e, s.memoizedState = $i(1 | t, n, void 0, r === void 0 ? null : r) } function il(e, t, n, r) { var s = Pt(); r = r === void 0 ? null : r; var i = void 0; if (Pe !== null) { var o = Pe.memoizedState; if (i = o.destroy, r !== null && Wd(r, o.deps)) { s.memoizedState = $i(t, n, i, r); return } } ye.flags |= e, s.memoizedState = $i(1 | t, n, i, r) } function Zh(e, t) { return Zo(8390656, 8, e, t) } function Gd(e, t) { return il(2048, 8, e, t) } function oy(e, t) { return il(4, 2, e, t) } function ay(e, t) { return il(4, 4, e, t) } function ly(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function uy(e, t, n) { return n = n != null ? n.concat([e]) : null, il(4, 4, ly.bind(null, t, e), n) } function Xd() { } function cy(e, t) { var n = Pt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Wd(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function dy(e, t) { var n = Pt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Wd(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function fy(e, t, n) { return Fr & 21 ? ($t(n, t) || (n = y0(), ye.lanes |= n, Lr |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, et = !0), e.memoizedState = n) } function hS(e, t) { var n = ne; ne = n !== 0 && 4 > n ? n : 4, e(!0); var r = ru.transition; ru.transition = {}; try { e(!1), t() } finally { ne = n, ru.transition = r } } function hy() { return Pt().memoizedState } function pS(e, t, n) { var r = Jn(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, py(e)) my(t, n); else if (n = Q0(e, t, n, r), n !== null) { var s = Xe(); Bt(n, e, r, s), gy(n, t, r) } } function mS(e, t, n) { var r = Jn(e), s = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (py(e)) my(t, s); else { var i = e.alternate; if (e.lanes === 0 && (i === null || i.lanes === 0) && (i = t.lastRenderedReducer, i !== null)) try { var o = t.lastRenderedState, a = i(o, n); if (s.hasEagerState = !0, s.eagerState = a, $t(a, o)) { var l = t.interleaved; l === null ? (s.next = s, _d(t)) : (s.next = l.next, l.next = s), t.interleaved = s; return } } catch { } finally { } n = Q0(e, t, s, r), n !== null && (s = Xe(), Bt(n, e, r, s), gy(n, t, r)) } } function py(e) { var t = e.alternate; return e === ye || t !== null && t === ye } function my(e, t) { vi = Ra = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function gy(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Ed(e, n) } } var Na = { readContext: Et, useCallback: Ie, useContext: Ie, useEffect: Ie, useImperativeHandle: Ie, useInsertionEffect: Ie, useLayoutEffect: Ie, useMemo: Ie, useReducer: Ie, useRef: Ie, useState: Ie, useDebugValue: Ie, useDeferredValue: Ie, useTransition: Ie, useMutableSource: Ie, useSyncExternalStore: Ie, useId: Ie, unstable_isNewReconciler: !1 }, gS = { readContext: Et, useCallback: function (e, t) { return Gt().memoizedState = [e, t === void 0 ? null : t], e }, useContext: Et, useEffect: Zh, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, Zo(4194308, 4, ly.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Zo(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Zo(4, 2, e, t) }, useMemo: function (e, t) { var n = Gt(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = Gt(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = pS.bind(null, ye, e), [r.memoizedState, e] }, useRef: function (e) { var t = Gt(); return e = { current: e }, t.memoizedState = e }, useState: qh, useDebugValue: Xd, useDeferredValue: function (e) { return Gt().memoizedState = e }, useTransition: function () { var e = qh(!1), t = e[0]; return e = hS.bind(null, e[1]), Gt().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ye, s = Gt(); if (fe) { if (n === void 0) throw Error(M(407)); n = n() } else { if (n = t(), je === null) throw Error(M(349)); Fr & 30 || ey(r, t, n) } s.memoizedState = n; var i = { value: n, getSnapshot: t }; return s.queue = i, Zh(ny.bind(null, r, i, e), [e]), r.flags |= 2048, $i(9, ty.bind(null, r, i, n, t), void 0, null), n }, useId: function () { var e = Gt(), t = je.identifierPrefix; if (fe) { var n = mn, r = pn; n = (r & ~(1 << 32 - zt(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = zi++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = fS++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, yS = { readContext: Et, useCallback: cy, useContext: Et, useEffect: Gd, useImperativeHandle: uy, useInsertionEffect: oy, useLayoutEffect: ay, useMemo: dy, useReducer: su, useRef: iy, useState: function () { return su(Bi) }, useDebugValue: Xd, useDeferredValue: function (e) { var t = Pt(); return fy(t, Pe.memoizedState, e) }, useTransition: function () { var e = su(Bi)[0], t = Pt().memoizedState; return [e, t] }, useMutableSource: Z0, useSyncExternalStore: J0, useId: hy, unstable_isNewReconciler: !1 }, vS = { readContext: Et, useCallback: cy, useContext: Et, useEffect: Gd, useImperativeHandle: uy, useInsertionEffect: oy, useLayoutEffect: ay, useMemo: dy, useReducer: iu, useRef: iy, useState: function () { return iu(Bi) }, useDebugValue: Xd, useDeferredValue: function (e) { var t = Pt(); return Pe === null ? t.memoizedState = e : fy(t, Pe.memoizedState, e) }, useTransition: function () { var e = iu(Bi)[0], t = Pt().memoizedState; return [e, t] }, useMutableSource: Z0, useSyncExternalStore: J0, useId: hy, unstable_isNewReconciler: !1 }; function Ot(e, t) { if (e && e.defaultProps) { t = ve({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } function cc(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : ve({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var ol = { isMounted: function (e) { return (e = e._reactInternals) ? zr(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = Xe(), s = Jn(e), i = gn(r, s); i.payload = t, n != null && (i.callback = n), t = qn(e, i, s), t !== null && (Bt(t, e, s, r), Yo(t, e, s)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = Xe(), s = Jn(e), i = gn(r, s); i.tag = 1, i.payload = t, n != null && (i.callback = n), t = qn(e, i, s), t !== null && (Bt(t, e, s, r), Yo(t, e, s)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = Xe(), r = Jn(e), s = gn(n, r); s.tag = 2, t != null && (s.callback = t), t = qn(e, s, r), t !== null && (Bt(t, e, r, n), Yo(t, e, r)) } }; function Jh(e, t, n, r, s, i, o) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, i, o) : t.prototype && t.prototype.isPureReactComponent ? !Oi(n, r) || !Oi(s, i) : !0 } function yy(e, t, n) { var r = !1, s = nr, i = t.contextType; return typeof i == "object" && i !== null ? i = Et(i) : (s = nt(t) ? Dr : $e.current, r = t.contextTypes, i = (r = r != null) ? Ns(e, s) : nr), t = new t(n, i), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = ol, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = s, e.__reactInternalMemoizedMaskedChildContext = i), t } function ep(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && ol.enqueueReplaceState(t, t.state, null) } function dc(e, t, n, r) { var s = e.stateNode; s.props = n, s.state = e.memoizedState, s.refs = {}, zd(e); var i = t.contextType; typeof i == "object" && i !== null ? s.context = Et(i) : (i = nt(t) ? Dr : $e.current, s.context = Ns(e, i)), s.state = e.memoizedState, i = t.getDerivedStateFromProps, typeof i == "function" && (cc(e, t, i, n), s.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (t = s.state, typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), t !== s.state && ol.enqueueReplaceState(s, s.state, null), ka(e, n, s, r), s.state = e.memoizedState), typeof s.componentDidMount == "function" && (e.flags |= 4194308) } function Os(e, t) {
  try { var n = "", r = t; do n += Kw(r), r = r.return; while (r); var s = n } catch (i) {
    s = `
Error generating stack: `+ i.message + `
`+ i.stack
  } return { value: e, source: t, stack: s, digest: null }
} function ou(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function fc(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var xS = typeof WeakMap == "function" ? WeakMap : Map; function vy(e, t, n) { n = gn(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Ma || (Ma = !0, Sc = r), fc(e, t) }, n } function xy(e, t, n) { n = gn(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var s = t.value; n.payload = function () { return r(s) }, n.callback = function () { fc(e, t) } } var i = e.stateNode; return i !== null && typeof i.componentDidCatch == "function" && (n.callback = function () { fc(e, t), typeof r != "function" && (Zn === null ? Zn = new Set([this]) : Zn.add(this)); var o = t.stack; this.componentDidCatch(t.value, { componentStack: o !== null ? o : "" }) }), n } function tp(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new xS; var s = new Set; r.set(t, s) } else s = r.get(t), s === void 0 && (s = new Set, r.set(t, s)); s.has(n) || (s.add(n), e = DS.bind(null, e, t, n), t.then(e, e)) } function np(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function rp(e, t, n, r, s) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = s, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = gn(-1, 1), t.tag = 2, qn(n, t, 1))), n.lanes |= 1), e) } var wS = Cn.ReactCurrentOwner, et = !1; function We(e, t, n, r) { t.child = e === null ? X0(t, null, n, r) : Ms(t, e.child, n, r) } function sp(e, t, n, r, s) { n = n.render; var i = t.ref; return ms(t, s), r = Hd(e, t, n, r, i, s), n = Kd(), e !== null && !et ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, wn(e, t, s)) : (fe && n && Dd(t), t.flags |= 1, We(e, t, r, s), t.child) } function ip(e, t, n, r, s) { if (e === null) { var i = n.type; return typeof i == "function" && !nf(i) && i.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = i, wy(e, t, i, r, s)) : (e = na(n.type, null, r, t, t.mode, s), e.ref = t.ref, e.return = t, t.child = e) } if (i = e.child, !(e.lanes & s)) { var o = i.memoizedProps; if (n = n.compare, n = n !== null ? n : Oi, n(o, r) && e.ref === t.ref) return wn(e, t, s) } return t.flags |= 1, e = er(i, r), e.ref = t.ref, e.return = t, t.child = e } function wy(e, t, n, r, s) { if (e !== null) { var i = e.memoizedProps; if (Oi(i, r) && e.ref === t.ref) if (et = !1, t.pendingProps = r = i, (e.lanes & s) !== 0) e.flags & 131072 && (et = !0); else return t.lanes = e.lanes, wn(e, t, s) } return hc(e, t, n, r, s) } function by(e, t, n) { var r = t.pendingProps, s = r.children, i = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ie(is, lt), lt |= n; else { if (!(n & 1073741824)) return e = i !== null ? i.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, ie(is, lt), lt |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = i !== null ? i.baseLanes : n, ie(is, lt), lt |= r } else i !== null ? (r = i.baseLanes | n, t.memoizedState = null) : r = n, ie(is, lt), lt |= r; return We(e, t, s, n), t.child } function Sy(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function hc(e, t, n, r, s) { var i = nt(n) ? Dr : $e.current; return i = Ns(t, i), ms(t, s), n = Hd(e, t, n, r, i, s), r = Kd(), e !== null && !et ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, wn(e, t, s)) : (fe && r && Dd(t), t.flags |= 1, We(e, t, n, s), t.child) } function op(e, t, n, r, s) { if (nt(n)) { var i = !0; Sa(t) } else i = !1; if (ms(t, s), t.stateNode === null) Jo(e, t), yy(t, n, r), dc(t, n, r, s), r = !0; else if (e === null) { var o = t.stateNode, a = t.memoizedProps; o.props = a; var l = o.context, u = n.contextType; typeof u == "object" && u !== null ? u = Et(u) : (u = nt(n) ? Dr : $e.current, u = Ns(t, u)); var c = n.getDerivedStateFromProps, d = typeof c == "function" || typeof o.getSnapshotBeforeUpdate == "function"; d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== u) && ep(t, o, r, u), Fn = !1; var f = t.memoizedState; o.state = f, ka(t, r, o, s), l = t.memoizedState, a !== r || f !== l || tt.current || Fn ? (typeof c == "function" && (cc(t, n, c, r), l = t.memoizedState), (a = Fn || Jh(t, n, a, r, f, l, u)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), o.props = r, o.state = l, o.context = u, r = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { o = t.stateNode, Y0(e, t), a = t.memoizedProps, u = t.type === t.elementType ? a : Ot(t.type, a), o.props = u, d = t.pendingProps, f = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = Et(l) : (l = nt(n) ? Dr : $e.current, l = Ns(t, l)); var h = n.getDerivedStateFromProps; (c = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || f !== l) && ep(t, o, r, l), Fn = !1, f = t.memoizedState, o.state = f, ka(t, r, o, s); var x = t.memoizedState; a !== d || f !== x || tt.current || Fn ? (typeof h == "function" && (cc(t, n, h, r), x = t.memoizedState), (u = Fn || Jh(t, n, u, r, f, x, l) || !1) ? (c || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, x, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, x, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = x), o.props = r, o.state = x, o.context = l, r = u) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), r = !1) } return pc(e, t, n, r, i, s) } function pc(e, t, n, r, s, i) { Sy(e, t); var o = (t.flags & 128) !== 0; if (!r && !o) return s && Hh(t, n, !1), wn(e, t, i); r = t.stateNode, wS.current = t; var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && o ? (t.child = Ms(t, e.child, null, i), t.child = Ms(t, null, a, i)) : We(e, t, a, i), t.memoizedState = r.state, s && Hh(t, n, !0), t.child } function Ty(e) { var t = e.stateNode; t.pendingContext ? Wh(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Wh(e, t.context, !1), Bd(e, t.containerInfo) } function ap(e, t, n, r, s) { return js(), Fd(s), t.flags |= 256, We(e, t, n, r), t.child } var mc = { dehydrated: null, treeContext: null, retryLane: 0 }; function gc(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Cy(e, t, n) { var r = t.pendingProps, s = me.current, i = !1, o = (t.flags & 128) !== 0, a; if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (s & 2) !== 0), a ? (i = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (s |= 1), ie(me, s & 1), e === null) return lc(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = r.children, e = r.fallback, i ? (r = t.mode, i = t.child, o = { mode: "hidden", children: o }, !(r & 1) && i !== null ? (i.childLanes = 0, i.pendingProps = o) : i = ul(o, r, 0, null), e = jr(e, r, n, null), i.return = t, e.return = t, i.sibling = e, t.child = i, t.child.memoizedState = gc(n), t.memoizedState = mc, e) : Qd(t, o)); if (s = e.memoizedState, s !== null && (a = s.dehydrated, a !== null)) return bS(e, t, o, r, a, s, n); if (i) { i = r.fallback, o = t.mode, s = e.child, a = s.sibling; var l = { mode: "hidden", children: r.children }; return !(o & 1) && t.child !== s ? (r = t.child, r.childLanes = 0, r.pendingProps = l, t.deletions = null) : (r = er(s, l), r.subtreeFlags = s.subtreeFlags & 14680064), a !== null ? i = er(a, i) : (i = jr(i, o, n, null), i.flags |= 2), i.return = t, r.return = t, r.sibling = i, t.child = r, r = i, i = t.child, o = e.child.memoizedState, o = o === null ? gc(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, i.memoizedState = o, i.childLanes = e.childLanes & ~n, t.memoizedState = mc, r } return i = e.child, e = i.sibling, r = er(i, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function Qd(e, t) { return t = ul({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function Mo(e, t, n, r) { return r !== null && Fd(r), Ms(t, e.child, null, n), e = Qd(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function bS(e, t, n, r, s, i, o) { if (n) return t.flags & 256 ? (t.flags &= -257, r = ou(Error(M(422))), Mo(e, t, o, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (i = r.fallback, s = t.mode, r = ul({ mode: "visible", children: r.children }, s, 0, null), i = jr(i, s, o, null), i.flags |= 2, r.return = t, i.return = t, r.sibling = i, t.child = r, t.mode & 1 && Ms(t, e.child, null, o), t.child.memoizedState = gc(o), t.memoizedState = mc, i); if (!(t.mode & 1)) return Mo(e, t, o, null); if (s.data === "$!") { if (r = s.nextSibling && s.nextSibling.dataset, r) var a = r.dgst; return r = a, i = Error(M(419)), r = ou(i, r, void 0), Mo(e, t, o, r) } if (a = (o & e.childLanes) !== 0, et || a) { if (r = je, r !== null) { switch (o & -o) { case 4: s = 2; break; case 16: s = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: s = 32; break; case 536870912: s = 268435456; break; default: s = 0 }s = s & (r.suspendedLanes | o) ? 0 : s, s !== 0 && s !== i.retryLane && (i.retryLane = s, xn(e, s), Bt(r, e, s, -1)) } return tf(), r = ou(Error(M(421))), Mo(e, t, o, r) } return s.data === "$?" ? (t.flags |= 128, t.child = e.child, t = OS.bind(null, e), s._reactRetry = t, null) : (e = i.treeContext, ct = Yn(s.nextSibling), dt = t, fe = !0, _t = null, e !== null && (vt[xt++] = pn, vt[xt++] = mn, vt[xt++] = Or, pn = e.id, mn = e.overflow, Or = t), t = Qd(t, r.children), t.flags |= 4096, t) } function lp(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), uc(e.return, t, n) } function au(e, t, n, r, s) { var i = e.memoizedState; i === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: s } : (i.isBackwards = t, i.rendering = null, i.renderingStartTime = 0, i.last = r, i.tail = n, i.tailMode = s) } function Ey(e, t, n) { var r = t.pendingProps, s = r.revealOrder, i = r.tail; if (We(e, t, r.children, n), r = me.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && lp(e, n, t); else if (e.tag === 19) lp(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (ie(me, r), !(t.mode & 1)) t.memoizedState = null; else switch (s) { case "forwards": for (n = t.child, s = null; n !== null;)e = n.alternate, e !== null && Aa(e) === null && (s = n), n = n.sibling; n = s, n === null ? (s = t.child, t.child = null) : (s = n.sibling, n.sibling = null), au(t, !1, s, n, i); break; case "backwards": for (n = null, s = t.child, t.child = null; s !== null;) { if (e = s.alternate, e !== null && Aa(e) === null) { t.child = s; break } e = s.sibling, s.sibling = n, n = s, s = e } au(t, !0, n, null, i); break; case "together": au(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Jo(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function wn(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), Lr |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(M(153)); if (t.child !== null) { for (e = t.child, n = er(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = er(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function SS(e, t, n) { switch (t.tag) { case 3: Ty(t), js(); break; case 5: q0(t); break; case 1: nt(t.type) && Sa(t); break; case 4: Bd(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, s = t.memoizedProps.value; ie(Ea, r._currentValue), r._currentValue = s; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (ie(me, me.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? Cy(e, t, n) : (ie(me, me.current & 1), e = wn(e, t, n), e !== null ? e.sibling : null); ie(me, me.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return Ey(e, t, n); t.flags |= 128 } if (s = t.memoizedState, s !== null && (s.rendering = null, s.tail = null, s.lastEffect = null), ie(me, me.current), r) break; return null; case 22: case 23: return t.lanes = 0, by(e, t, n) }return wn(e, t, n) } var Py, yc, ky, Ay; Py = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; yc = function () { }; ky = function (e, t, n, r) { var s = e.memoizedProps; if (s !== r) { e = t.stateNode, br(tn.current); var i = null; switch (n) { case "input": s = _u(e, s), r = _u(e, r), i = []; break; case "select": s = ve({}, s, { value: void 0 }), r = ve({}, r, { value: void 0 }), i = []; break; case "textarea": s = $u(e, s), r = $u(e, r), i = []; break; default: typeof s.onClick != "function" && typeof r.onClick == "function" && (e.onclick = wa) }Wu(n, r); var o; n = null; for (u in s) if (!r.hasOwnProperty(u) && s.hasOwnProperty(u) && s[u] != null) if (u === "style") { var a = s[u]; for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (ki.hasOwnProperty(u) ? i || (i = []) : (i = i || []).push(u, null)); for (u in r) { var l = r[u]; if (a = s != null ? s[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o]) } else n || (i || (i = []), i.push(u, n)), n = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (i = i || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (ki.hasOwnProperty(u) ? (l != null && u === "onScroll" && le("scroll", e), i || a === l || (i = [])) : (i = i || []).push(u, l)) } n && (i = i || []).push("style", n); var u = i; (t.updateQueue = u) && (t.flags |= 4) } }; Ay = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function ri(e, t) { if (!fe) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Ve(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var s = e.child; s !== null;)n |= s.lanes | s.childLanes, r |= s.subtreeFlags & 14680064, r |= s.flags & 14680064, s.return = e, s = s.sibling; else for (s = e.child; s !== null;)n |= s.lanes | s.childLanes, r |= s.subtreeFlags, r |= s.flags, s.return = e, s = s.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function TS(e, t, n) { var r = t.pendingProps; switch (Od(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ve(t), null; case 1: return nt(t.type) && ba(), Ve(t), null; case 3: return r = t.stateNode, Ds(), ue(tt), ue($e), Ud(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (No(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, _t !== null && (Ec(_t), _t = null))), yc(e, t), Ve(t), null; case 5: $d(t); var s = br(_i.current); if (n = t.type, e !== null && t.stateNode != null) ky(e, t, n, r, s), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(M(166)); return Ve(t), null } if (e = br(tn.current), No(t)) { r = t.stateNode, n = t.type; var i = t.memoizedProps; switch (r[Zt] = t, r[Ii] = i, e = (t.mode & 1) !== 0, n) { case "dialog": le("cancel", r), le("close", r); break; case "iframe": case "object": case "embed": le("load", r); break; case "video": case "audio": for (s = 0; s < di.length; s++)le(di[s], r); break; case "source": le("error", r); break; case "img": case "image": case "link": le("error", r), le("load", r); break; case "details": le("toggle", r); break; case "input": yh(r, i), le("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!i.multiple }, le("invalid", r); break; case "textarea": xh(r, i), le("invalid", r) }Wu(n, i), s = null; for (var o in i) if (i.hasOwnProperty(o)) { var a = i[o]; o === "children" ? typeof a == "string" ? r.textContent !== a && (i.suppressHydrationWarning !== !0 && Ro(r.textContent, a, e), s = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (i.suppressHydrationWarning !== !0 && Ro(r.textContent, a, e), s = ["children", "" + a]) : ki.hasOwnProperty(o) && a != null && o === "onScroll" && le("scroll", r) } switch (n) { case "input": bo(r), vh(r, i, !0); break; case "textarea": bo(r), wh(r); break; case "select": case "option": break; default: typeof i.onClick == "function" && (r.onclick = wa) }r = s, t.updateQueue = r, r !== null && (t.flags |= 4) } else { o = s.nodeType === 9 ? s : s.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = n0(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = o.createElement(n, { is: r.is }) : (e = o.createElement(n), n === "select" && (o = e, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : e = o.createElementNS(e, n), e[Zt] = t, e[Ii] = r, Py(e, t, !1, !1), t.stateNode = e; e: { switch (o = Hu(n, r), n) { case "dialog": le("cancel", e), le("close", e), s = r; break; case "iframe": case "object": case "embed": le("load", e), s = r; break; case "video": case "audio": for (s = 0; s < di.length; s++)le(di[s], e); s = r; break; case "source": le("error", e), s = r; break; case "img": case "image": case "link": le("error", e), le("load", e), s = r; break; case "details": le("toggle", e), s = r; break; case "input": yh(e, r), s = _u(e, r), le("invalid", e); break; case "option": s = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, s = ve({}, r, { value: void 0 }), le("invalid", e); break; case "textarea": xh(e, r), s = $u(e, r), le("invalid", e); break; default: s = r }Wu(n, s), a = s; for (i in a) if (a.hasOwnProperty(i)) { var l = a[i]; i === "style" ? i0(e, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && r0(e, l)) : i === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Ai(e, l) : typeof l == "number" && Ai(e, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (ki.hasOwnProperty(i) ? l != null && i === "onScroll" && le("scroll", e) : l != null && xd(e, i, l, o)) } switch (n) { case "input": bo(e), vh(e, r, !1); break; case "textarea": bo(e), wh(e); break; case "option": r.value != null && e.setAttribute("value", "" + tr(r.value)); break; case "select": e.multiple = !!r.multiple, i = r.value, i != null ? ds(e, !!r.multiple, i, !1) : r.defaultValue != null && ds(e, !!r.multiple, r.defaultValue, !0); break; default: typeof s.onClick == "function" && (e.onclick = wa) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Ve(t), null; case 6: if (e && t.stateNode != null) Ay(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(M(166)); if (n = br(_i.current), br(tn.current), No(t)) { if (r = t.stateNode, n = t.memoizedProps, r[Zt] = t, (i = r.nodeValue !== n) && (e = dt, e !== null)) switch (e.tag) { case 3: Ro(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && Ro(r.nodeValue, n, (e.mode & 1) !== 0) }i && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[Zt] = t, t.stateNode = r } return Ve(t), null; case 13: if (ue(me), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (fe && ct !== null && t.mode & 1 && !(t.flags & 128)) K0(), js(), t.flags |= 98560, i = !1; else if (i = No(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!i) throw Error(M(318)); if (i = t.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(M(317)); i[Zt] = t } else js(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; Ve(t), i = !1 } else _t !== null && (Ec(_t), _t = null), i = !0; if (!i) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || me.current & 1 ? Ae === 0 && (Ae = 3) : tf())), t.updateQueue !== null && (t.flags |= 4), Ve(t), null); case 4: return Ds(), yc(e, t), e === null && Fi(t.stateNode.containerInfo), Ve(t), null; case 10: return Vd(t.type._context), Ve(t), null; case 17: return nt(t.type) && ba(), Ve(t), null; case 19: if (ue(me), i = t.memoizedState, i === null) return Ve(t), null; if (r = (t.flags & 128) !== 0, o = i.rendering, o === null) if (r) ri(i, !1); else { if (Ae !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (o = Aa(e), o !== null) { for (t.flags |= 128, ri(i, !1), r = o.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)i = n, e = r, i.flags &= 14680066, o = i.alternate, o === null ? (i.childLanes = 0, i.lanes = e, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = o.childLanes, i.lanes = o.lanes, i.child = o.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = o.memoizedProps, i.memoizedState = o.memoizedState, i.updateQueue = o.updateQueue, i.type = o.type, e = o.dependencies, i.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return ie(me, me.current & 1 | 2), t.child } e = e.sibling } i.tail !== null && be() > Fs && (t.flags |= 128, r = !0, ri(i, !1), t.lanes = 4194304) } else { if (!r) if (e = Aa(o), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), ri(i, !0), i.tail === null && i.tailMode === "hidden" && !o.alternate && !fe) return Ve(t), null } else 2 * be() - i.renderingStartTime > Fs && n !== 1073741824 && (t.flags |= 128, r = !0, ri(i, !1), t.lanes = 4194304); i.isBackwards ? (o.sibling = t.child, t.child = o) : (n = i.last, n !== null ? n.sibling = o : t.child = o, i.last = o) } return i.tail !== null ? (t = i.tail, i.rendering = t, i.tail = t.sibling, i.renderingStartTime = be(), t.sibling = null, n = me.current, ie(me, r ? n & 1 | 2 : n & 1), t) : (Ve(t), null); case 22: case 23: return ef(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? lt & 1073741824 && (Ve(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Ve(t), null; case 24: return null; case 25: return null }throw Error(M(156, t.tag)) } function CS(e, t) { switch (Od(t), t.tag) { case 1: return nt(t.type) && ba(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return Ds(), ue(tt), ue($e), Ud(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return $d(t), null; case 13: if (ue(me), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(M(340)); js() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return ue(me), null; case 4: return Ds(), null; case 10: return Vd(t.type._context), null; case 22: case 23: return ef(), null; case 24: return null; default: return null } } var Do = !1, ze = !1, ES = typeof WeakSet == "function" ? WeakSet : Set, I = null; function ss(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { we(e, t, r) } else n.current = null } function vc(e, t, n) { try { n() } catch (r) { we(e, t, r) } } var up = !1; function PS(e, t) { if (tc = ya, e = D0(), Md(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var s = r.anchorOffset, i = r.focusNode; r = r.focusOffset; try { n.nodeType, i.nodeType } catch { n = null; break e } var o = 0, a = -1, l = -1, u = 0, c = 0, d = e, f = null; t: for (; ;) { for (var h; d !== n || s !== 0 && d.nodeType !== 3 || (a = o + s), d !== i || r !== 0 && d.nodeType !== 3 || (l = o + r), d.nodeType === 3 && (o += d.nodeValue.length), (h = d.firstChild) !== null;)f = d, d = h; for (; ;) { if (d === e) break t; if (f === n && ++u === s && (a = o), f === i && ++c === r && (l = o), (h = d.nextSibling) !== null) break; d = f, f = d.parentNode } d = h } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (nc = { focusedElem: e, selectionRange: n }, ya = !1, I = t; I !== null;)if (t = I, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, I = e; else for (; I !== null;) { t = I; try { var x = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (x !== null) { var y = x.memoizedProps, b = x.memoizedState, p = t.stateNode, m = p.getSnapshotBeforeUpdate(t.elementType === t.type ? y : Ot(t.type, y), b); p.__reactInternalSnapshotBeforeUpdate = m } break; case 3: var v = t.stateNode.containerInfo; v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(M(163)) } } catch (S) { we(t, t.return, S) } if (e = t.sibling, e !== null) { e.return = t.return, I = e; break } I = t.return } return x = up, up = !1, x } function xi(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var s = r = r.next; do { if ((s.tag & e) === e) { var i = s.destroy; s.destroy = void 0, i !== void 0 && vc(t, n, i) } s = s.next } while (s !== r) } } function al(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function xc(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function Ry(e) { var t = e.alternate; t !== null && (e.alternate = null, Ry(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Zt], delete t[Ii], delete t[ic], delete t[lS], delete t[uS])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function Ny(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function cp(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Ny(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function wc(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = wa)); else if (r !== 4 && (e = e.child, e !== null)) for (wc(e, t, n), e = e.sibling; e !== null;)wc(e, t, n), e = e.sibling } function bc(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (bc(e, t, n), e = e.sibling; e !== null;)bc(e, t, n), e = e.sibling } var Me = null, Vt = !1; function An(e, t, n) { for (n = n.child; n !== null;)jy(e, t, n), n = n.sibling } function jy(e, t, n) { if (en && typeof en.onCommitFiberUnmount == "function") try { en.onCommitFiberUnmount(Ja, n) } catch { } switch (n.tag) { case 5: ze || ss(n, t); case 6: var r = Me, s = Vt; Me = null, An(e, t, n), Me = r, Vt = s, Me !== null && (Vt ? (e = Me, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Me.removeChild(n.stateNode)); break; case 18: Me !== null && (Vt ? (e = Me, n = n.stateNode, e.nodeType === 8 ? eu(e.parentNode, n) : e.nodeType === 1 && eu(e, n), Mi(e)) : eu(Me, n.stateNode)); break; case 4: r = Me, s = Vt, Me = n.stateNode.containerInfo, Vt = !0, An(e, t, n), Me = r, Vt = s; break; case 0: case 11: case 14: case 15: if (!ze && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { s = r = r.next; do { var i = s, o = i.destroy; i = i.tag, o !== void 0 && (i & 2 || i & 4) && vc(n, t, o), s = s.next } while (s !== r) } An(e, t, n); break; case 1: if (!ze && (ss(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { we(n, t, a) } An(e, t, n); break; case 21: An(e, t, n); break; case 22: n.mode & 1 ? (ze = (r = ze) || n.memoizedState !== null, An(e, t, n), ze = r) : An(e, t, n); break; default: An(e, t, n) } } function dp(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new ES), t.forEach(function (r) { var s = FS.bind(null, e, r); n.has(r) || (n.add(r), r.then(s, s)) }) } } function Nt(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var s = n[r]; try { var i = e, o = t, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Me = a.stateNode, Vt = !1; break e; case 3: Me = a.stateNode.containerInfo, Vt = !0; break e; case 4: Me = a.stateNode.containerInfo, Vt = !0; break e }a = a.return } if (Me === null) throw Error(M(160)); jy(i, o, s), Me = null, Vt = !1; var l = s.alternate; l !== null && (l.return = null), s.return = null } catch (u) { we(s, t, u) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)My(t, e), t = t.sibling } function My(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Nt(t, e), Kt(e), r & 4) { try { xi(3, e, e.return), al(3, e) } catch (y) { we(e, e.return, y) } try { xi(5, e, e.return) } catch (y) { we(e, e.return, y) } } break; case 1: Nt(t, e), Kt(e), r & 512 && n !== null && ss(n, n.return); break; case 5: if (Nt(t, e), Kt(e), r & 512 && n !== null && ss(n, n.return), e.flags & 32) { var s = e.stateNode; try { Ai(s, "") } catch (y) { we(e, e.return, y) } } if (r & 4 && (s = e.stateNode, s != null)) { var i = e.memoizedProps, o = n !== null ? n.memoizedProps : i, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && i.type === "radio" && i.name != null && e0(s, i), Hu(a, o); var u = Hu(a, i); for (o = 0; o < l.length; o += 2) { var c = l[o], d = l[o + 1]; c === "style" ? i0(s, d) : c === "dangerouslySetInnerHTML" ? r0(s, d) : c === "children" ? Ai(s, d) : xd(s, c, d, u) } switch (a) { case "input": zu(s, i); break; case "textarea": t0(s, i); break; case "select": var f = s._wrapperState.wasMultiple; s._wrapperState.wasMultiple = !!i.multiple; var h = i.value; h != null ? ds(s, !!i.multiple, h, !1) : f !== !!i.multiple && (i.defaultValue != null ? ds(s, !!i.multiple, i.defaultValue, !0) : ds(s, !!i.multiple, i.multiple ? [] : "", !1)) }s[Ii] = i } catch (y) { we(e, e.return, y) } } break; case 6: if (Nt(t, e), Kt(e), r & 4) { if (e.stateNode === null) throw Error(M(162)); s = e.stateNode, i = e.memoizedProps; try { s.nodeValue = i } catch (y) { we(e, e.return, y) } } break; case 3: if (Nt(t, e), Kt(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { Mi(t.containerInfo) } catch (y) { we(e, e.return, y) } break; case 4: Nt(t, e), Kt(e); break; case 13: Nt(t, e), Kt(e), s = e.child, s.flags & 8192 && (i = s.memoizedState !== null, s.stateNode.isHidden = i, !i || s.alternate !== null && s.alternate.memoizedState !== null || (Zd = be())), r & 4 && dp(e); break; case 22: if (c = n !== null && n.memoizedState !== null, e.mode & 1 ? (ze = (u = ze) || c, Nt(t, e), ze = u) : Nt(t, e), Kt(e), r & 8192) { if (u = e.memoizedState !== null, (e.stateNode.isHidden = u) && !c && e.mode & 1) for (I = e, c = e.child; c !== null;) { for (d = I = c; I !== null;) { switch (f = I, h = f.child, f.tag) { case 0: case 11: case 14: case 15: xi(4, f, f.return); break; case 1: ss(f, f.return); var x = f.stateNode; if (typeof x.componentWillUnmount == "function") { r = f, n = f.return; try { t = r, x.props = t.memoizedProps, x.state = t.memoizedState, x.componentWillUnmount() } catch (y) { we(r, n, y) } } break; case 5: ss(f, f.return); break; case 22: if (f.memoizedState !== null) { hp(d); continue } }h !== null ? (h.return = f, I = h) : hp(d) } c = c.sibling } e: for (c = null, d = e; ;) { if (d.tag === 5) { if (c === null) { c = d; try { s = d.stateNode, u ? (i = s.style, typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = s0("display", o)) } catch (y) { we(e, e.return, y) } } } else if (d.tag === 6) { if (c === null) try { d.stateNode.nodeValue = u ? "" : d.memoizedProps } catch (y) { we(e, e.return, y) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === e) break e; for (; d.sibling === null;) { if (d.return === null || d.return === e) break e; c === d && (c = null), d = d.return } c === d && (c = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: Nt(t, e), Kt(e), r & 4 && dp(e); break; case 21: break; default: Nt(t, e), Kt(e) } } function Kt(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (Ny(n)) { var r = n; break e } n = n.return } throw Error(M(160)) } switch (r.tag) { case 5: var s = r.stateNode; r.flags & 32 && (Ai(s, ""), r.flags &= -33); var i = cp(e); bc(e, i, s); break; case 3: case 4: var o = r.stateNode.containerInfo, a = cp(e); wc(e, a, o); break; default: throw Error(M(161)) } } catch (l) { we(e, e.return, l) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function kS(e, t, n) { I = e, Dy(e) } function Dy(e, t, n) { for (var r = (e.mode & 1) !== 0; I !== null;) { var s = I, i = s.child; if (s.tag === 22 && r) { var o = s.memoizedState !== null || Do; if (!o) { var a = s.alternate, l = a !== null && a.memoizedState !== null || ze; a = Do; var u = ze; if (Do = o, (ze = l) && !u) for (I = s; I !== null;)o = I, l = o.child, o.tag === 22 && o.memoizedState !== null ? pp(s) : l !== null ? (l.return = o, I = l) : pp(s); for (; i !== null;)I = i, Dy(i), i = i.sibling; I = s, Do = a, ze = u } fp(e) } else s.subtreeFlags & 8772 && i !== null ? (i.return = s, I = i) : fp(e) } } function fp(e) { for (; I !== null;) { var t = I; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: ze || al(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !ze) if (n === null) r.componentDidMount(); else { var s = t.elementType === t.type ? n.memoizedProps : Ot(t.type, n.memoizedProps); r.componentDidUpdate(s, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var i = t.updateQueue; i !== null && Yh(t, i, r); break; case 3: var o = t.updateQueue; if (o !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }Yh(t, o, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var u = t.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var d = c.dehydrated; d !== null && Mi(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(M(163)) }ze || t.flags & 512 && xc(t) } catch (f) { we(t, t.return, f) } } if (t === e) { I = null; break } if (n = t.sibling, n !== null) { n.return = t.return, I = n; break } I = t.return } } function hp(e) { for (; I !== null;) { var t = I; if (t === e) { I = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, I = n; break } I = t.return } } function pp(e) { for (; I !== null;) { var t = I; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { al(4, t) } catch (l) { we(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var s = t.return; try { r.componentDidMount() } catch (l) { we(t, s, l) } } var i = t.return; try { xc(t) } catch (l) { we(t, i, l) } break; case 5: var o = t.return; try { xc(t) } catch (l) { we(t, o, l) } } } catch (l) { we(t, t.return, l) } if (t === e) { I = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, I = a; break } I = t.return } } var AS = Math.ceil, ja = Cn.ReactCurrentDispatcher, Yd = Cn.ReactCurrentOwner, St = Cn.ReactCurrentBatchConfig, ee = 0, je = null, Ce = null, Oe = 0, lt = 0, is = cr(0), Ae = 0, Ui = null, Lr = 0, ll = 0, qd = 0, wi = null, Je = null, Zd = 0, Fs = 1 / 0, cn = null, Ma = !1, Sc = null, Zn = null, Oo = !1, Wn = null, Da = 0, bi = 0, Tc = null, ea = -1, ta = 0; function Xe() { return ee & 6 ? be() : ea !== -1 ? ea : ea = be() } function Jn(e) { return e.mode & 1 ? ee & 2 && Oe !== 0 ? Oe & -Oe : dS.transition !== null ? (ta === 0 && (ta = y0()), ta) : (e = ne, e !== 0 || (e = window.event, e = e === void 0 ? 16 : C0(e.type)), e) : 1 } function Bt(e, t, n, r) { if (50 < bi) throw bi = 0, Tc = null, Error(M(185)); no(e, n, r), (!(ee & 2) || e !== je) && (e === je && (!(ee & 2) && (ll |= n), Ae === 4 && In(e, Oe)), rt(e, r), n === 1 && ee === 0 && !(t.mode & 1) && (Fs = be() + 500, sl && dr())) } function rt(e, t) { var n = e.callbackNode; db(e, t); var r = ga(e, e === je ? Oe : 0); if (r === 0) n !== null && Th(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && Th(n), t === 1) e.tag === 0 ? cS(mp.bind(null, e)) : U0(mp.bind(null, e)), oS(function () { !(ee & 6) && dr() }), n = null; else { switch (v0(r)) { case 1: n = Cd; break; case 4: n = m0; break; case 16: n = ma; break; case 536870912: n = g0; break; default: n = ma }n = By(n, Oy.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function Oy(e, t) { if (ea = -1, ta = 0, ee & 6) throw Error(M(327)); var n = e.callbackNode; if (gs() && e.callbackNode !== n) return null; var r = ga(e, e === je ? Oe : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = Oa(e, r); else { t = r; var s = ee; ee |= 2; var i = Ly(); (je !== e || Oe !== t) && (cn = null, Fs = be() + 500, Nr(e, t)); do try { jS(); break } catch (a) { Fy(e, a) } while (!0); Id(), ja.current = i, ee = s, Ce !== null ? t = 0 : (je = null, Oe = 0, t = Ae) } if (t !== 0) { if (t === 2 && (s = Yu(e), s !== 0 && (r = s, t = Cc(e, s))), t === 1) throw n = Ui, Nr(e, 0), In(e, r), rt(e, be()), n; if (t === 6) In(e, r); else { if (s = e.current.alternate, !(r & 30) && !RS(s) && (t = Oa(e, r), t === 2 && (i = Yu(e), i !== 0 && (r = i, t = Cc(e, i))), t === 1)) throw n = Ui, Nr(e, 0), In(e, r), rt(e, be()), n; switch (e.finishedWork = s, e.finishedLanes = r, t) { case 0: case 1: throw Error(M(345)); case 2: yr(e, Je, cn); break; case 3: if (In(e, r), (r & 130023424) === r && (t = Zd + 500 - be(), 10 < t)) { if (ga(e, 0) !== 0) break; if (s = e.suspendedLanes, (s & r) !== r) { Xe(), e.pingedLanes |= e.suspendedLanes & s; break } e.timeoutHandle = sc(yr.bind(null, e, Je, cn), t); break } yr(e, Je, cn); break; case 4: if (In(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, s = -1; 0 < r;) { var o = 31 - zt(r); i = 1 << o, o = t[o], o > s && (s = o), r &= ~i } if (r = s, r = be() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * AS(r / 1960)) - r, 10 < r) { e.timeoutHandle = sc(yr.bind(null, e, Je, cn), r); break } yr(e, Je, cn); break; case 5: yr(e, Je, cn); break; default: throw Error(M(329)) } } } return rt(e, be()), e.callbackNode === n ? Oy.bind(null, e) : null } function Cc(e, t) { var n = wi; return e.current.memoizedState.isDehydrated && (Nr(e, t).flags |= 256), e = Oa(e, t), e !== 2 && (t = Je, Je = n, t !== null && Ec(t)), e } function Ec(e) { Je === null ? Je = e : Je.push.apply(Je, e) } function RS(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var s = n[r], i = s.getSnapshot; s = s.value; try { if (!$t(i(), s)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function In(e, t) { for (t &= ~qd, t &= ~ll, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - zt(t), r = 1 << n; e[n] = -1, t &= ~r } } function mp(e) { if (ee & 6) throw Error(M(327)); gs(); var t = ga(e, 0); if (!(t & 1)) return rt(e, be()), null; var n = Oa(e, t); if (e.tag !== 0 && n === 2) { var r = Yu(e); r !== 0 && (t = r, n = Cc(e, r)) } if (n === 1) throw n = Ui, Nr(e, 0), In(e, t), rt(e, be()), n; if (n === 6) throw Error(M(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, yr(e, Je, cn), rt(e, be()), null } function Jd(e, t) { var n = ee; ee |= 1; try { return e(t) } finally { ee = n, ee === 0 && (Fs = be() + 500, sl && dr()) } } function Ir(e) { Wn !== null && Wn.tag === 0 && !(ee & 6) && gs(); var t = ee; ee |= 1; var n = St.transition, r = ne; try { if (St.transition = null, ne = 1, e) return e() } finally { ne = r, St.transition = n, ee = t, !(ee & 6) && dr() } } function ef() { lt = is.current, ue(is) } function Nr(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, iS(n)), Ce !== null) for (n = Ce.return; n !== null;) { var r = n; switch (Od(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && ba(); break; case 3: Ds(), ue(tt), ue($e), Ud(); break; case 5: $d(r); break; case 4: Ds(); break; case 13: ue(me); break; case 19: ue(me); break; case 10: Vd(r.type._context); break; case 22: case 23: ef() }n = n.return } if (je = e, Ce = e = er(e.current, null), Oe = lt = t, Ae = 0, Ui = null, qd = ll = Lr = 0, Je = wi = null, wr !== null) { for (t = 0; t < wr.length; t++)if (n = wr[t], r = n.interleaved, r !== null) { n.interleaved = null; var s = r.next, i = n.pending; if (i !== null) { var o = i.next; i.next = s, r.next = o } n.pending = r } wr = null } return e } function Fy(e, t) { do { var n = Ce; try { if (Id(), qo.current = Na, Ra) { for (var r = ye.memoizedState; r !== null;) { var s = r.queue; s !== null && (s.pending = null), r = r.next } Ra = !1 } if (Fr = 0, Ne = Pe = ye = null, vi = !1, zi = 0, Yd.current = null, n === null || n.return === null) { Ae = 1, Ui = t, Ce = null; break } e: { var i = e, o = n.return, a = n, l = t; if (t = Oe, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = a, d = c.tag; if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) { var f = c.alternate; f ? (c.updateQueue = f.updateQueue, c.memoizedState = f.memoizedState, c.lanes = f.lanes) : (c.updateQueue = null, c.memoizedState = null) } var h = np(o); if (h !== null) { h.flags &= -257, rp(h, o, a, i, t), h.mode & 1 && tp(i, u, t), t = h, l = u; var x = t.updateQueue; if (x === null) { var y = new Set; y.add(l), t.updateQueue = y } else x.add(l); break e } else { if (!(t & 1)) { tp(i, u, t), tf(); break e } l = Error(M(426)) } } else if (fe && a.mode & 1) { var b = np(o); if (b !== null) { !(b.flags & 65536) && (b.flags |= 256), rp(b, o, a, i, t), Fd(Os(l, a)); break e } } i = l = Os(l, a), Ae !== 4 && (Ae = 2), wi === null ? wi = [i] : wi.push(i), i = o; do { switch (i.tag) { case 3: i.flags |= 65536, t &= -t, i.lanes |= t; var p = vy(i, l, t); Qh(i, p); break e; case 1: a = l; var m = i.type, v = i.stateNode; if (!(i.flags & 128) && (typeof m.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (Zn === null || !Zn.has(v)))) { i.flags |= 65536, t &= -t, i.lanes |= t; var S = xy(i, a, t); Qh(i, S); break e } }i = i.return } while (i !== null) } Vy(n) } catch (T) { t = T, Ce === n && n !== null && (Ce = n = n.return); continue } break } while (!0) } function Ly() { var e = ja.current; return ja.current = Na, e === null ? Na : e } function tf() { (Ae === 0 || Ae === 3 || Ae === 2) && (Ae = 4), je === null || !(Lr & 268435455) && !(ll & 268435455) || In(je, Oe) } function Oa(e, t) { var n = ee; ee |= 2; var r = Ly(); (je !== e || Oe !== t) && (cn = null, Nr(e, t)); do try { NS(); break } catch (s) { Fy(e, s) } while (!0); if (Id(), ee = n, ja.current = r, Ce !== null) throw Error(M(261)); return je = null, Oe = 0, Ae } function NS() { for (; Ce !== null;)Iy(Ce) } function jS() { for (; Ce !== null && !nb();)Iy(Ce) } function Iy(e) { var t = zy(e.alternate, e, lt); e.memoizedProps = e.pendingProps, t === null ? Vy(e) : Ce = t, Yd.current = null } function Vy(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = CS(n, t), n !== null) { n.flags &= 32767, Ce = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Ae = 6, Ce = null; return } } else if (n = TS(n, t, lt), n !== null) { Ce = n; return } if (t = t.sibling, t !== null) { Ce = t; return } Ce = t = e } while (t !== null); Ae === 0 && (Ae = 5) } function yr(e, t, n) { var r = ne, s = St.transition; try { St.transition = null, ne = 1, MS(e, t, n, r) } finally { St.transition = s, ne = r } return null } function MS(e, t, n, r) { do gs(); while (Wn !== null); if (ee & 6) throw Error(M(327)); n = e.finishedWork; var s = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(M(177)); e.callbackNode = null, e.callbackPriority = 0; var i = n.lanes | n.childLanes; if (fb(e, i), e === je && (Ce = je = null, Oe = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Oo || (Oo = !0, By(ma, function () { return gs(), null })), i = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || i) { i = St.transition, St.transition = null; var o = ne; ne = 1; var a = ee; ee |= 4, Yd.current = null, PS(e, n), My(n, e), Zb(nc), ya = !!tc, nc = tc = null, e.current = n, kS(n), rb(), ee = a, ne = o, St.transition = i } else e.current = n; if (Oo && (Oo = !1, Wn = e, Da = s), i = e.pendingLanes, i === 0 && (Zn = null), ob(n.stateNode), rt(e, be()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)s = t[n], r(s.value, { componentStack: s.stack, digest: s.digest }); if (Ma) throw Ma = !1, e = Sc, Sc = null, e; return Da & 1 && e.tag !== 0 && gs(), i = e.pendingLanes, i & 1 ? e === Tc ? bi++ : (bi = 0, Tc = e) : bi = 0, dr(), null } function gs() { if (Wn !== null) { var e = v0(Da), t = St.transition, n = ne; try { if (St.transition = null, ne = 16 > e ? 16 : e, Wn === null) var r = !1; else { if (e = Wn, Wn = null, Da = 0, ee & 6) throw Error(M(331)); var s = ee; for (ee |= 4, I = e.current; I !== null;) { var i = I, o = i.child; if (I.flags & 16) { var a = i.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (I = u; I !== null;) { var c = I; switch (c.tag) { case 0: case 11: case 15: xi(8, c, i) }var d = c.child; if (d !== null) d.return = c, I = d; else for (; I !== null;) { c = I; var f = c.sibling, h = c.return; if (Ry(c), c === u) { I = null; break } if (f !== null) { f.return = h, I = f; break } I = h } } } var x = i.alternate; if (x !== null) { var y = x.child; if (y !== null) { x.child = null; do { var b = y.sibling; y.sibling = null, y = b } while (y !== null) } } I = i } } if (i.subtreeFlags & 2064 && o !== null) o.return = i, I = o; else e: for (; I !== null;) { if (i = I, i.flags & 2048) switch (i.tag) { case 0: case 11: case 15: xi(9, i, i.return) }var p = i.sibling; if (p !== null) { p.return = i.return, I = p; break e } I = i.return } } var m = e.current; for (I = m; I !== null;) { o = I; var v = o.child; if (o.subtreeFlags & 2064 && v !== null) v.return = o, I = v; else e: for (o = m; I !== null;) { if (a = I, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: al(9, a) } } catch (T) { we(a, a.return, T) } if (a === o) { I = null; break e } var S = a.sibling; if (S !== null) { S.return = a.return, I = S; break e } I = a.return } } if (ee = s, dr(), en && typeof en.onPostCommitFiberRoot == "function") try { en.onPostCommitFiberRoot(Ja, e) } catch { } r = !0 } return r } finally { ne = n, St.transition = t } } return !1 } function gp(e, t, n) { t = Os(n, t), t = vy(e, t, 1), e = qn(e, t, 1), t = Xe(), e !== null && (no(e, 1, t), rt(e, t)) } function we(e, t, n) { if (e.tag === 3) gp(e, e, n); else for (; t !== null;) { if (t.tag === 3) { gp(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Zn === null || !Zn.has(r))) { e = Os(n, e), e = xy(t, e, 1), t = qn(t, e, 1), e = Xe(), t !== null && (no(t, 1, e), rt(t, e)); break } } t = t.return } } function DS(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = Xe(), e.pingedLanes |= e.suspendedLanes & n, je === e && (Oe & n) === n && (Ae === 4 || Ae === 3 && (Oe & 130023424) === Oe && 500 > be() - Zd ? Nr(e, 0) : qd |= n), rt(e, t) } function _y(e, t) { t === 0 && (e.mode & 1 ? (t = Co, Co <<= 1, !(Co & 130023424) && (Co = 4194304)) : t = 1); var n = Xe(); e = xn(e, t), e !== null && (no(e, t, n), rt(e, n)) } function OS(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), _y(e, n) } function FS(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, s = e.memoizedState; s !== null && (n = s.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(M(314)) }r !== null && r.delete(t), _y(e, n) } var zy; zy = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || tt.current) et = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return et = !1, SS(e, t, n); et = !!(e.flags & 131072) } else et = !1, fe && t.flags & 1048576 && W0(t, Ca, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Jo(e, t), e = t.pendingProps; var s = Ns(t, $e.current); ms(t, n), s = Hd(null, t, r, e, s, n); var i = Kd(); return t.flags |= 1, typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, nt(r) ? (i = !0, Sa(t)) : i = !1, t.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, zd(t), s.updater = ol, t.stateNode = s, s._reactInternals = t, dc(t, r, e, n), t = pc(null, t, r, !0, i, n)) : (t.tag = 0, fe && i && Dd(t), We(null, t, s, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Jo(e, t), e = t.pendingProps, s = r._init, r = s(r._payload), t.type = r, s = t.tag = IS(r), e = Ot(r, e), s) { case 0: t = hc(null, t, r, e, n); break e; case 1: t = op(null, t, r, e, n); break e; case 11: t = sp(null, t, r, e, n); break e; case 14: t = ip(null, t, r, Ot(r.type, e), n); break e }throw Error(M(306, r, "")) } return t; case 0: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Ot(r, s), hc(e, t, r, s, n); case 1: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Ot(r, s), op(e, t, r, s, n); case 3: e: { if (Ty(t), e === null) throw Error(M(387)); r = t.pendingProps, i = t.memoizedState, s = i.element, Y0(e, t), ka(t, r, null, n); var o = t.memoizedState; if (r = o.element, i.isDehydrated) if (i = { element: r, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, t.updateQueue.baseState = i, t.memoizedState = i, t.flags & 256) { s = Os(Error(M(423)), t), t = ap(e, t, r, n, s); break e } else if (r !== s) { s = Os(Error(M(424)), t), t = ap(e, t, r, n, s); break e } else for (ct = Yn(t.stateNode.containerInfo.firstChild), dt = t, fe = !0, _t = null, n = X0(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (js(), r === s) { t = wn(e, t, n); break e } We(e, t, r, n) } t = t.child } return t; case 5: return q0(t), e === null && lc(t), r = t.type, s = t.pendingProps, i = e !== null ? e.memoizedProps : null, o = s.children, rc(r, s) ? o = null : i !== null && rc(r, i) && (t.flags |= 32), Sy(e, t), We(e, t, o, n), t.child; case 6: return e === null && lc(t), null; case 13: return Cy(e, t, n); case 4: return Bd(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = Ms(t, null, r, n) : We(e, t, r, n), t.child; case 11: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Ot(r, s), sp(e, t, r, s, n); case 7: return We(e, t, t.pendingProps, n), t.child; case 8: return We(e, t, t.pendingProps.children, n), t.child; case 12: return We(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, s = t.pendingProps, i = t.memoizedProps, o = s.value, ie(Ea, r._currentValue), r._currentValue = o, i !== null) if ($t(i.value, o)) { if (i.children === s.children && !tt.current) { t = wn(e, t, n); break e } } else for (i = t.child, i !== null && (i.return = t); i !== null;) { var a = i.dependencies; if (a !== null) { o = i.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (i.tag === 1) { l = gn(-1, n & -n), l.tag = 2; var u = i.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } i.lanes |= n, l = i.alternate, l !== null && (l.lanes |= n), uc(i.return, n, t), a.lanes |= n; break } l = l.next } } else if (i.tag === 10) o = i.type === t.type ? null : i.child; else if (i.tag === 18) { if (o = i.return, o === null) throw Error(M(341)); o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), uc(o, n, t), o = i.sibling } else o = i.child; if (o !== null) o.return = i; else for (o = i; o !== null;) { if (o === t) { o = null; break } if (i = o.sibling, i !== null) { i.return = o.return, o = i; break } o = o.return } i = o } We(e, t, s.children, n), t = t.child } return t; case 9: return s = t.type, r = t.pendingProps.children, ms(t, n), s = Et(s), r = r(s), t.flags |= 1, We(e, t, r, n), t.child; case 14: return r = t.type, s = Ot(r, t.pendingProps), s = Ot(r.type, s), ip(e, t, r, s, n); case 15: return wy(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Ot(r, s), Jo(e, t), t.tag = 1, nt(r) ? (e = !0, Sa(t)) : e = !1, ms(t, n), yy(t, r, s), dc(t, r, s, n), pc(null, t, r, !0, e, n); case 19: return Ey(e, t, n); case 22: return by(e, t, n) }throw Error(M(156, t.tag)) }; function By(e, t) { return p0(e, t) } function LS(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function wt(e, t, n, r) { return new LS(e, t, n, r) } function nf(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function IS(e) { if (typeof e == "function") return nf(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === bd) return 11; if (e === Sd) return 14 } return 2 } function er(e, t) { var n = e.alternate; return n === null ? (n = wt(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function na(e, t, n, r, s, i) { var o = 2; if (r = e, typeof e == "function") nf(e) && (o = 1); else if (typeof e == "string") o = 5; else e: switch (e) { case Qr: return jr(n.children, s, i, t); case wd: o = 8, s |= 8; break; case Fu: return e = wt(12, n, t, s | 2), e.elementType = Fu, e.lanes = i, e; case Lu: return e = wt(13, n, t, s), e.elementType = Lu, e.lanes = i, e; case Iu: return e = wt(19, n, t, s), e.elementType = Iu, e.lanes = i, e; case qg: return ul(n, s, i, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case Qg: o = 10; break e; case Yg: o = 9; break e; case bd: o = 11; break e; case Sd: o = 14; break e; case On: o = 16, r = null; break e }throw Error(M(130, e == null ? e : typeof e, "")) }return t = wt(o, n, t, s), t.elementType = e, t.type = r, t.lanes = i, t } function jr(e, t, n, r) { return e = wt(7, e, r, t), e.lanes = n, e } function ul(e, t, n, r) { return e = wt(22, e, r, t), e.elementType = qg, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function lu(e, t, n) { return e = wt(6, e, null, t), e.lanes = n, e } function uu(e, t, n) { return t = wt(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function VS(e, t, n, r, s) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ul(0), this.expirationTimes = Ul(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ul(0), this.identifierPrefix = r, this.onRecoverableError = s, this.mutableSourceEagerHydrationData = null } function rf(e, t, n, r, s, i, o, a, l) { return e = new VS(e, t, n, a, l), t === 1 ? (t = 1, i === !0 && (t |= 8)) : t = 0, i = wt(3, null, null, t), e.current = i, i.stateNode = e, i.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, zd(i), e } function _S(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Xr, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function $y(e) { if (!e) return nr; e = e._reactInternals; e: { if (zr(e) !== e || e.tag !== 1) throw Error(M(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (nt(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(M(171)) } if (e.tag === 1) { var n = e.type; if (nt(n)) return $0(e, n, t) } return t } function Uy(e, t, n, r, s, i, o, a, l) { return e = rf(n, r, !0, e, s, i, o, a, l), e.context = $y(null), n = e.current, r = Xe(), s = Jn(n), i = gn(r, s), i.callback = t ?? null, qn(n, i, s), e.current.lanes = s, no(e, s, r), rt(e, r), e } function cl(e, t, n, r) { var s = t.current, i = Xe(), o = Jn(s); return n = $y(n), t.context === null ? t.context = n : t.pendingContext = n, t = gn(i, o), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = qn(s, t, o), e !== null && (Bt(e, s, o, i), Yo(e, s, o)), o } function Fa(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function yp(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function sf(e, t) { yp(e, t), (e = e.alternate) && yp(e, t) } function zS() { return null } var Wy = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function of(e) { this._internalRoot = e } dl.prototype.render = of.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(M(409)); cl(e, t, null, null) }; dl.prototype.unmount = of.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; Ir(function () { cl(null, e, null, null) }), t[vn] = null } }; function dl(e) { this._internalRoot = e } dl.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = b0(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Ln.length && t !== 0 && t < Ln[n].priority; n++); Ln.splice(n, 0, e), n === 0 && T0(e) } }; function af(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function fl(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function vp() { } function BS(e, t, n, r, s) { if (s) { if (typeof r == "function") { var i = r; r = function () { var u = Fa(o); i.call(u) } } var o = Uy(t, r, e, 0, null, !1, !1, "", vp); return e._reactRootContainer = o, e[vn] = o.current, Fi(e.nodeType === 8 ? e.parentNode : e), Ir(), o } for (; s = e.lastChild;)e.removeChild(s); if (typeof r == "function") { var a = r; r = function () { var u = Fa(l); a.call(u) } } var l = rf(e, 0, !1, null, null, !1, !1, "", vp); return e._reactRootContainer = l, e[vn] = l.current, Fi(e.nodeType === 8 ? e.parentNode : e), Ir(function () { cl(t, l, n, r) }), l } function hl(e, t, n, r, s) { var i = n._reactRootContainer; if (i) { var o = i; if (typeof s == "function") { var a = s; s = function () { var l = Fa(o); a.call(l) } } cl(t, o, e, s) } else o = BS(n, t, e, s, r); return Fa(o) } x0 = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = ci(t.pendingLanes); n !== 0 && (Ed(t, n | 1), rt(t, be()), !(ee & 6) && (Fs = be() + 500, dr())) } break; case 13: Ir(function () { var r = xn(e, 1); if (r !== null) { var s = Xe(); Bt(r, e, 1, s) } }), sf(e, 1) } }; Pd = function (e) { if (e.tag === 13) { var t = xn(e, 134217728); if (t !== null) { var n = Xe(); Bt(t, e, 134217728, n) } sf(e, 134217728) } }; w0 = function (e) { if (e.tag === 13) { var t = Jn(e), n = xn(e, t); if (n !== null) { var r = Xe(); Bt(n, e, t, r) } sf(e, t) } }; b0 = function () { return ne }; S0 = function (e, t) { var n = ne; try { return ne = e, t() } finally { ne = n } }; Gu = function (e, t, n) { switch (t) { case "input": if (zu(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var s = rl(r); if (!s) throw Error(M(90)); Jg(r), zu(r, s) } } } break; case "textarea": t0(e, n); break; case "select": t = n.value, t != null && ds(e, !!n.multiple, t, !1) } }; l0 = Jd; u0 = Ir; var $S = { usingClientEntryPoint: !1, Events: [so, Jr, rl, o0, a0, Jd] }, si = { findFiberByHostInstance: xr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, US = { bundleType: si.bundleType, version: si.version, rendererPackageName: si.rendererPackageName, rendererConfig: si.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Cn.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = f0(e), e === null ? null : e.stateNode }, findFiberByHostInstance: si.findFiberByHostInstance || zS, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Fo = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Fo.isDisabled && Fo.supportsFiber) try { Ja = Fo.inject(US), en = Fo } catch { } } pt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = $S; pt.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!af(t)) throw Error(M(200)); return _S(e, t, null, n) }; pt.createRoot = function (e, t) { if (!af(e)) throw Error(M(299)); var n = !1, r = "", s = Wy; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (s = t.onRecoverableError)), t = rf(e, 1, !1, null, null, n, !1, r, s), e[vn] = t.current, Fi(e.nodeType === 8 ? e.parentNode : e), new of(t) }; pt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(M(188)) : (e = Object.keys(e).join(","), Error(M(268, e))); return e = f0(t), e = e === null ? null : e.stateNode, e }; pt.flushSync = function (e) { return Ir(e) }; pt.hydrate = function (e, t, n) { if (!fl(t)) throw Error(M(200)); return hl(null, e, t, !0, n) }; pt.hydrateRoot = function (e, t, n) { if (!af(e)) throw Error(M(405)); var r = n != null && n.hydratedSources || null, s = !1, i = "", o = Wy; if (n != null && (n.unstable_strictMode === !0 && (s = !0), n.identifierPrefix !== void 0 && (i = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), t = Uy(t, null, e, 1, n ?? null, s, !1, i, o), e[vn] = t.current, Fi(e), r) for (e = 0; e < r.length; e++)n = r[e], s = n._getVersion, s = s(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, s] : t.mutableSourceEagerHydrationData.push(n, s); return new dl(t) }; pt.render = function (e, t, n) { if (!fl(t)) throw Error(M(200)); return hl(null, e, t, !1, n) }; pt.unmountComponentAtNode = function (e) { if (!fl(e)) throw Error(M(40)); return e._reactRootContainer ? (Ir(function () { hl(null, null, e, !1, function () { e._reactRootContainer = null, e[vn] = null }) }), !0) : !1 }; pt.unstable_batchedUpdates = Jd; pt.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!fl(n)) throw Error(M(200)); if (e == null || e._reactInternals === void 0) throw Error(M(38)); return hl(e, t, n, !1, r) }; pt.version = "18.3.1-next-f1338f8080-20240426"; function Hy() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Hy) } catch (e) { console.error(e) } } Hy(), Hg.exports = pt; var oo = Hg.exports; const Ky = Mg(oo); var Gy, xp = oo; Gy = xp.createRoot, xp.hydrateRoot; const WS = 1, HS = 1e6; let cu = 0; function KS() { return cu = (cu + 1) % Number.MAX_SAFE_INTEGER, cu.toString() } const du = new Map, wp = e => { if (du.has(e)) return; const t = setTimeout(() => { du.delete(e), Si({ type: "REMOVE_TOAST", toastId: e }) }, HS); du.set(e, t) }, GS = (e, t) => { switch (t.type) { case "ADD_TOAST": return { ...e, toasts: [t.toast, ...e.toasts].slice(0, WS) }; case "UPDATE_TOAST": return { ...e, toasts: e.toasts.map(n => n.id === t.toast.id ? { ...n, ...t.toast } : n) }; case "DISMISS_TOAST": { const { toastId: n } = t; return n ? wp(n) : e.toasts.forEach(r => { wp(r.id) }), { ...e, toasts: e.toasts.map(r => r.id === n || n === void 0 ? { ...r, open: !1 } : r) } } case "REMOVE_TOAST": return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter(n => n.id !== t.toastId) } } }, ra = []; let sa = { toasts: [] }; function Si(e) { sa = GS(sa, e), ra.forEach(t => { t(sa) }) } function XS({ ...e }) { const t = KS(), n = s => Si({ type: "UPDATE_TOAST", toast: { ...s, id: t } }), r = () => Si({ type: "DISMISS_TOAST", toastId: t }); return Si({ type: "ADD_TOAST", toast: { ...e, id: t, open: !0, onOpenChange: s => { s || r() } } }), { id: t, dismiss: r, update: n } } function QS() { const [e, t] = w.useState(sa); return w.useEffect(() => (ra.push(t), () => { const n = ra.indexOf(t); n > -1 && ra.splice(n, 1) }), [e]), { ...e, toast: XS, dismiss: n => Si({ type: "DISMISS_TOAST", toastId: n }) } } function ke(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (s) { if (e == null || e(s), n === !1 || !s.defaultPrevented) return t == null ? void 0 : t(s) } } function bp(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function Xy(...e) { return t => { let n = !1; const r = e.map(s => { const i = bp(s, t); return !n && typeof i == "function" && (n = !0), i }); if (n) return () => { for (let s = 0; s < r.length; s++) { const i = r[s]; typeof i == "function" ? i() : bp(e[s], null) } } } } function Ut(...e) { return w.useCallback(Xy(...e), e) } function pl(e, t = []) { let n = []; function r(i, o) { const a = w.createContext(o), l = n.length; n = [...n, o]; const u = d => { var p; const { scope: f, children: h, ...x } = d, y = ((p = f == null ? void 0 : f[e]) == null ? void 0 : p[l]) || a, b = w.useMemo(() => x, Object.values(x)); return g.jsx(y.Provider, { value: b, children: h }) }; u.displayName = i + "Provider"; function c(d, f) { var y; const h = ((y = f == null ? void 0 : f[e]) == null ? void 0 : y[l]) || a, x = w.useContext(h); if (x) return x; if (o !== void 0) return o; throw new Error(`\`${d}\` must be used within \`${i}\``) } return [u, c] } const s = () => { const i = n.map(o => w.createContext(o)); return function (a) { const l = (a == null ? void 0 : a[e]) || i; return w.useMemo(() => ({ [`__scope${e}`]: { ...a, [e]: l } }), [a, l]) } }; return s.scopeName = e, [r, YS(s, ...t)] } function YS(...e) { const t = e[0]; if (e.length === 1) return t; const n = () => { const r = e.map(s => ({ useScope: s(), scopeName: s.scopeName })); return function (i) { const o = r.reduce((a, { useScope: l, scopeName: u }) => { const d = l(i)[`__scope${u}`]; return { ...a, ...d } }, {}); return w.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]) } }; return n.scopeName = t.scopeName, n } function Pc(e) { const t = qS(e), n = w.forwardRef((r, s) => { const { children: i, ...o } = r, a = w.Children.toArray(i), l = a.find(JS); if (l) { const u = l.props.children, c = a.map(d => d === l ? w.Children.count(u) > 1 ? w.Children.only(null) : w.isValidElement(u) ? u.props.children : null : d); return g.jsx(t, { ...o, ref: s, children: w.isValidElement(u) ? w.cloneElement(u, void 0, c) : null }) } return g.jsx(t, { ...o, ref: s, children: i }) }); return n.displayName = `${e}.Slot`, n } function qS(e) { const t = w.forwardRef((n, r) => { const { children: s, ...i } = n; if (w.isValidElement(s)) { const o = tT(s), a = eT(i, s.props); return s.type !== w.Fragment && (a.ref = r ? Xy(r, o) : o), w.cloneElement(s, a) } return w.Children.count(s) > 1 ? w.Children.only(null) : null }); return t.displayName = `${e}.SlotClone`, t } var Qy = Symbol("radix.slottable"); function ZS(e) { const t = ({ children: n }) => g.jsx(g.Fragment, { children: n }); return t.displayName = `${e}.Slottable`, t.__radixId = Qy, t } function JS(e) { return w.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Qy } function eT(e, t) { const n = { ...t }; for (const r in t) { const s = e[r], i = t[r]; /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => { const l = i(...a); return s(...a), l } : s && (n[r] = s) : r === "style" ? n[r] = { ...s, ...i } : r === "className" && (n[r] = [s, i].filter(Boolean).join(" ")) } return { ...e, ...n } } function tT(e) { var r, s; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } function nT(e) { const t = e + "CollectionProvider", [n, r] = pl(t), [s, i] = n(t, { collectionRef: { current: null }, itemMap: new Map }), o = y => { const { scope: b, children: p } = y, m = D.useRef(null), v = D.useRef(new Map).current; return g.jsx(s, { scope: b, itemMap: v, collectionRef: m, children: p }) }; o.displayName = t; const a = e + "CollectionSlot", l = Pc(a), u = D.forwardRef((y, b) => { const { scope: p, children: m } = y, v = i(a, p), S = Ut(b, v.collectionRef); return g.jsx(l, { ref: S, children: m }) }); u.displayName = a; const c = e + "CollectionItemSlot", d = "data-radix-collection-item", f = Pc(c), h = D.forwardRef((y, b) => { const { scope: p, children: m, ...v } = y, S = D.useRef(null), T = Ut(b, S), C = i(c, p); return D.useEffect(() => (C.itemMap.set(S, { ref: S, ...v }), () => void C.itemMap.delete(S))), g.jsx(f, { [d]: "", ref: T, children: m }) }); h.displayName = c; function x(y) { const b = i(e + "CollectionConsumer", y); return D.useCallback(() => { const m = b.collectionRef.current; if (!m) return []; const v = Array.from(m.querySelectorAll(`[${d}]`)); return Array.from(b.itemMap.values()).sort((C, E) => v.indexOf(C.ref.current) - v.indexOf(E.ref.current)) }, [b.collectionRef, b.itemMap]) } return [{ Provider: o, Slot: u, ItemSlot: h }, x, r] } var rT = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], it = rT.reduce((e, t) => { const n = Pc(`Primitive.${t}`), r = w.forwardRef((s, i) => { const { asChild: o, ...a } = s, l = o ? n : t; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), g.jsx(l, { ...a, ref: i }) }); return r.displayName = `Primitive.${t}`, { ...e, [t]: r } }, {}); function Yy(e, t) { e && oo.flushSync(() => e.dispatchEvent(t)) } function rr(e) { const t = w.useRef(e); return w.useEffect(() => { t.current = e }), w.useMemo(() => (...n) => { var r; return (r = t.current) == null ? void 0 : r.call(t, ...n) }, []) } function sT(e, t = globalThis == null ? void 0 : globalThis.document) { const n = rr(e); w.useEffect(() => { const r = s => { s.key === "Escape" && n(s) }; return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 }) }, [n, t]) } var iT = "DismissableLayer", kc = "dismissableLayer.update", oT = "dismissableLayer.pointerDownOutside", aT = "dismissableLayer.focusOutside", Sp, qy = w.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), lf = w.forwardRef((e, t) => { const { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: r, onPointerDownOutside: s, onFocusOutside: i, onInteractOutside: o, onDismiss: a, ...l } = e, u = w.useContext(qy), [c, d] = w.useState(null), f = (c == null ? void 0 : c.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = w.useState({}), x = Ut(t, E => d(E)), y = Array.from(u.layers), [b] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), p = y.indexOf(b), m = c ? y.indexOf(c) : -1, v = u.layersWithOutsidePointerEventsDisabled.size > 0, S = m >= p, T = uT(E => { const P = E.target, N = [...u.branches].some(j => j.contains(P)); !S || N || (s == null || s(E), o == null || o(E), E.defaultPrevented || a == null || a()) }, f), C = cT(E => { const P = E.target;[...u.branches].some(j => j.contains(P)) || (i == null || i(E), o == null || o(E), E.defaultPrevented || a == null || a()) }, f); return sT(E => { m === u.layers.size - 1 && (r == null || r(E), !E.defaultPrevented && a && (E.preventDefault(), a())) }, f), w.useEffect(() => { if (c) return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (Sp = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(c)), u.layers.add(c), Tp(), () => { n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = Sp) } }, [c, f, n, u]), w.useEffect(() => () => { c && (u.layers.delete(c), u.layersWithOutsidePointerEventsDisabled.delete(c), Tp()) }, [c, u]), w.useEffect(() => { const E = () => h({}); return document.addEventListener(kc, E), () => document.removeEventListener(kc, E) }, []), g.jsx(it.div, { ...l, ref: x, style: { pointerEvents: v ? S ? "auto" : "none" : void 0, ...e.style }, onFocusCapture: ke(e.onFocusCapture, C.onFocusCapture), onBlurCapture: ke(e.onBlurCapture, C.onBlurCapture), onPointerDownCapture: ke(e.onPointerDownCapture, T.onPointerDownCapture) }) }); lf.displayName = iT; var lT = "DismissableLayerBranch", Zy = w.forwardRef((e, t) => { const n = w.useContext(qy), r = w.useRef(null), s = Ut(t, r); return w.useEffect(() => { const i = r.current; if (i) return n.branches.add(i), () => { n.branches.delete(i) } }, [n.branches]), g.jsx(it.div, { ...e, ref: s }) }); Zy.displayName = lT; function uT(e, t = globalThis == null ? void 0 : globalThis.document) { const n = rr(e), r = w.useRef(!1), s = w.useRef(() => { }); return w.useEffect(() => { const i = a => { if (a.target && !r.current) { let l = function () { Jy(oT, n, u, { discrete: !0 }) }; const u = { originalEvent: a }; a.pointerType === "touch" ? (t.removeEventListener("click", s.current), s.current = l, t.addEventListener("click", s.current, { once: !0 })) : l() } else t.removeEventListener("click", s.current); r.current = !1 }, o = window.setTimeout(() => { t.addEventListener("pointerdown", i) }, 0); return () => { window.clearTimeout(o), t.removeEventListener("pointerdown", i), t.removeEventListener("click", s.current) } }, [t, n]), { onPointerDownCapture: () => r.current = !0 } } function cT(e, t = globalThis == null ? void 0 : globalThis.document) { const n = rr(e), r = w.useRef(!1); return w.useEffect(() => { const s = i => { i.target && !r.current && Jy(aT, n, { originalEvent: i }, { discrete: !1 }) }; return t.addEventListener("focusin", s), () => t.removeEventListener("focusin", s) }, [t, n]), { onFocusCapture: () => r.current = !0, onBlurCapture: () => r.current = !1 } } function Tp() { const e = new CustomEvent(kc); document.dispatchEvent(e) } function Jy(e, t, n, { discrete: r }) { const s = n.originalEvent.target, i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n }); t && s.addEventListener(e, t, { once: !0 }), r ? Yy(s, i) : s.dispatchEvent(i) } var dT = lf, fT = Zy, sr = globalThis != null && globalThis.document ? w.useLayoutEffect : () => { }, hT = "Portal", ev = w.forwardRef((e, t) => { var a; const { container: n, ...r } = e, [s, i] = w.useState(!1); sr(() => i(!0), []); const o = n || s && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body); return o ? Ky.createPortal(g.jsx(it.div, { ...r, ref: t }), o) : null }); ev.displayName = hT; function pT(e, t) { return w.useReducer((n, r) => t[n][r] ?? n, e) } var uf = e => { const { present: t, children: n } = e, r = mT(t), s = typeof n == "function" ? n({ present: r.isPresent }) : w.Children.only(n), i = Ut(r.ref, gT(s)); return typeof n == "function" || r.isPresent ? w.cloneElement(s, { ref: i }) : null }; uf.displayName = "Presence"; function mT(e) { const [t, n] = w.useState(), r = w.useRef(null), s = w.useRef(e), i = w.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = pT(o, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return w.useEffect(() => { const u = Lo(r.current); i.current = a === "mounted" ? u : "none" }, [a]), sr(() => { const u = r.current, c = s.current; if (c !== e) { const f = i.current, h = Lo(u); e ? l("MOUNT") : h === "none" || (u == null ? void 0 : u.display) === "none" ? l("UNMOUNT") : l(c && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), s.current = e } }, [e, l]), sr(() => { if (t) { let u; const c = t.ownerDocument.defaultView ?? window, d = h => { const y = Lo(r.current).includes(h.animationName); if (h.target === t && y && (l("ANIMATION_END"), !s.current)) { const b = t.style.animationFillMode; t.style.animationFillMode = "forwards", u = c.setTimeout(() => { t.style.animationFillMode === "forwards" && (t.style.animationFillMode = b) }) } }, f = h => { h.target === t && (i.current = Lo(r.current)) }; return t.addEventListener("animationstart", f), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => { c.clearTimeout(u), t.removeEventListener("animationstart", f), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d) } } else l("ANIMATION_END") }, [t, l]), { isPresent: ["mounted", "unmountSuspended"].includes(a), ref: w.useCallback(u => { r.current = u ? getComputedStyle(u) : null, n(u) }, []) } } function Lo(e) { return (e == null ? void 0 : e.animationName) || "none" } function gT(e) { var r, s; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } var yT = Ug[" useInsertionEffect ".trim().toString()] || sr; function vT({ prop: e, defaultProp: t, onChange: n = () => { }, caller: r }) { const [s, i, o] = xT({ defaultProp: t, onChange: n }), a = e !== void 0, l = a ? e : s; { const c = w.useRef(e !== void 0); w.useEffect(() => { const d = c.current; d !== a && console.warn(`${r} is changing from ${d ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), c.current = a }, [a, r]) } const u = w.useCallback(c => { var d; if (a) { const f = wT(c) ? c(e) : c; f !== e && ((d = o.current) == null || d.call(o, f)) } else i(c) }, [a, e, i, o]); return [l, u] } function xT({ defaultProp: e, onChange: t }) { const [n, r] = w.useState(e), s = w.useRef(n), i = w.useRef(t); return yT(() => { i.current = t }, [t]), w.useEffect(() => { var o; s.current !== n && ((o = i.current) == null || o.call(i, n), s.current = n) }, [n, s]), [n, r, i] } function wT(e) { return typeof e == "function" } var bT = Object.freeze({ position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }), ST = "VisuallyHidden", ml = w.forwardRef((e, t) => g.jsx(it.span, { ...e, ref: t, style: { ...bT, ...e.style } })); ml.displayName = ST; var TT = ml, cf = "ToastProvider", [df, CT, ET] = nT("Toast"), [tv, jj] = pl("Toast", [ET]), [PT, gl] = tv(cf), nv = e => { const { __scopeToast: t, label: n = "Notification", duration: r = 5e3, swipeDirection: s = "right", swipeThreshold: i = 50, children: o } = e, [a, l] = w.useState(null), [u, c] = w.useState(0), d = w.useRef(!1), f = w.useRef(!1); return n.trim() || console.error(`Invalid prop \`label\` supplied to \`${cf}\`. Expected non-empty \`string\`.`), g.jsx(df.Provider, { scope: t, children: g.jsx(PT, { scope: t, label: n, duration: r, swipeDirection: s, swipeThreshold: i, toastCount: u, viewport: a, onViewportChange: l, onToastAdd: w.useCallback(() => c(h => h + 1), []), onToastRemove: w.useCallback(() => c(h => h - 1), []), isFocusedToastEscapeKeyDownRef: d, isClosePausedRef: f, children: o }) }) }; nv.displayName = cf; var rv = "ToastViewport", kT = ["F8"], Ac = "toast.viewportPause", Rc = "toast.viewportResume", sv = w.forwardRef((e, t) => { const { __scopeToast: n, hotkey: r = kT, label: s = "Notifications ({hotkey})", ...i } = e, o = gl(rv, n), a = CT(n), l = w.useRef(null), u = w.useRef(null), c = w.useRef(null), d = w.useRef(null), f = Ut(t, d, o.onViewportChange), h = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), x = o.toastCount > 0; w.useEffect(() => { const b = p => { var v; r.length !== 0 && r.every(S => p[S] || p.code === S) && ((v = d.current) == null || v.focus()) }; return document.addEventListener("keydown", b), () => document.removeEventListener("keydown", b) }, [r]), w.useEffect(() => { const b = l.current, p = d.current; if (x && b && p) { const m = () => { if (!o.isClosePausedRef.current) { const C = new CustomEvent(Ac); p.dispatchEvent(C), o.isClosePausedRef.current = !0 } }, v = () => { if (o.isClosePausedRef.current) { const C = new CustomEvent(Rc); p.dispatchEvent(C), o.isClosePausedRef.current = !1 } }, S = C => { !b.contains(C.relatedTarget) && v() }, T = () => { b.contains(document.activeElement) || v() }; return b.addEventListener("focusin", m), b.addEventListener("focusout", S), b.addEventListener("pointermove", m), b.addEventListener("pointerleave", T), window.addEventListener("blur", m), window.addEventListener("focus", v), () => { b.removeEventListener("focusin", m), b.removeEventListener("focusout", S), b.removeEventListener("pointermove", m), b.removeEventListener("pointerleave", T), window.removeEventListener("blur", m), window.removeEventListener("focus", v) } } }, [x, o.isClosePausedRef]); const y = w.useCallback(({ tabbingDirection: b }) => { const m = a().map(v => { const S = v.ref.current, T = [S, ...zT(S)]; return b === "forwards" ? T : T.reverse() }); return (b === "forwards" ? m.reverse() : m).flat() }, [a]); return w.useEffect(() => { const b = d.current; if (b) { const p = m => { var T, C, E; const v = m.altKey || m.ctrlKey || m.metaKey; if (m.key === "Tab" && !v) { const P = document.activeElement, N = m.shiftKey; if (m.target === b && N) { (T = u.current) == null || T.focus(); return } const L = y({ tabbingDirection: N ? "backwards" : "forwards" }), H = L.findIndex(O => O === P); fu(L.slice(H + 1)) ? m.preventDefault() : N ? (C = u.current) == null || C.focus() : (E = c.current) == null || E.focus() } }; return b.addEventListener("keydown", p), () => b.removeEventListener("keydown", p) } }, [a, y]), g.jsxs(fT, { ref: l, role: "region", "aria-label": s.replace("{hotkey}", h), tabIndex: -1, style: { pointerEvents: x ? void 0 : "none" }, children: [x && g.jsx(Nc, { ref: u, onFocusFromOutsideViewport: () => { const b = y({ tabbingDirection: "forwards" }); fu(b) } }), g.jsx(df.Slot, { scope: n, children: g.jsx(it.ol, { tabIndex: -1, ...i, ref: f }) }), x && g.jsx(Nc, { ref: c, onFocusFromOutsideViewport: () => { const b = y({ tabbingDirection: "backwards" }); fu(b) } })] }) }); sv.displayName = rv; var iv = "ToastFocusProxy", Nc = w.forwardRef((e, t) => { const { __scopeToast: n, onFocusFromOutsideViewport: r, ...s } = e, i = gl(iv, n); return g.jsx(ml, { "aria-hidden": !0, tabIndex: 0, ...s, ref: t, style: { position: "fixed" }, onFocus: o => { var u; const a = o.relatedTarget; !((u = i.viewport) != null && u.contains(a)) && r() } }) }); Nc.displayName = iv; var ao = "Toast", AT = "toast.swipeStart", RT = "toast.swipeMove", NT = "toast.swipeCancel", jT = "toast.swipeEnd", ov = w.forwardRef((e, t) => { const { forceMount: n, open: r, defaultOpen: s, onOpenChange: i, ...o } = e, [a, l] = vT({ prop: r, defaultProp: s ?? !0, onChange: i, caller: ao }); return g.jsx(uf, { present: n || a, children: g.jsx(OT, { open: a, ...o, ref: t, onClose: () => l(!1), onPause: rr(e.onPause), onResume: rr(e.onResume), onSwipeStart: ke(e.onSwipeStart, u => { u.currentTarget.setAttribute("data-swipe", "start") }), onSwipeMove: ke(e.onSwipeMove, u => { const { x: c, y: d } = u.detail.delta; u.currentTarget.setAttribute("data-swipe", "move"), u.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${c}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${d}px`) }), onSwipeCancel: ke(e.onSwipeCancel, u => { u.currentTarget.setAttribute("data-swipe", "cancel"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-y") }), onSwipeEnd: ke(e.onSwipeEnd, u => { const { x: c, y: d } = u.detail.delta; u.currentTarget.setAttribute("data-swipe", "end"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${c}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${d}px`), l(!1) }) }) }) }); ov.displayName = ao; var [MT, DT] = tv(ao, { onClose() { } }), OT = w.forwardRef((e, t) => { const { __scopeToast: n, type: r = "foreground", duration: s, open: i, onClose: o, onEscapeKeyDown: a, onPause: l, onResume: u, onSwipeStart: c, onSwipeMove: d, onSwipeCancel: f, onSwipeEnd: h, ...x } = e, y = gl(ao, n), [b, p] = w.useState(null), m = Ut(t, O => p(O)), v = w.useRef(null), S = w.useRef(null), T = s || y.duration, C = w.useRef(0), E = w.useRef(T), P = w.useRef(0), { onToastAdd: N, onToastRemove: j } = y, z = rr(() => { var K; (b == null ? void 0 : b.contains(document.activeElement)) && ((K = y.viewport) == null || K.focus()), o() }), L = w.useCallback(O => { !O || O === 1 / 0 || (window.clearTimeout(P.current), C.current = new Date().getTime(), P.current = window.setTimeout(z, O)) }, [z]); w.useEffect(() => { const O = y.viewport; if (O) { const K = () => { L(E.current), u == null || u() }, U = () => { const V = new Date().getTime() - C.current; E.current = E.current - V, window.clearTimeout(P.current), l == null || l() }; return O.addEventListener(Ac, U), O.addEventListener(Rc, K), () => { O.removeEventListener(Ac, U), O.removeEventListener(Rc, K) } } }, [y.viewport, T, l, u, L]), w.useEffect(() => { i && !y.isClosePausedRef.current && L(T) }, [i, T, y.isClosePausedRef, L]), w.useEffect(() => (N(), () => j()), [N, j]); const H = w.useMemo(() => b ? hv(b) : null, [b]); return y.viewport ? g.jsxs(g.Fragment, { children: [H && g.jsx(FT, { __scopeToast: n, role: "status", "aria-live": r === "foreground" ? "assertive" : "polite", "aria-atomic": !0, children: H }), g.jsx(MT, { scope: n, onClose: z, children: oo.createPortal(g.jsx(df.ItemSlot, { scope: n, children: g.jsx(dT, { asChild: !0, onEscapeKeyDown: ke(a, () => { y.isFocusedToastEscapeKeyDownRef.current || z(), y.isFocusedToastEscapeKeyDownRef.current = !1 }), children: g.jsx(it.li, { role: "status", "aria-live": "off", "aria-atomic": !0, tabIndex: 0, "data-state": i ? "open" : "closed", "data-swipe-direction": y.swipeDirection, ...x, ref: m, style: { userSelect: "none", touchAction: "none", ...e.style }, onKeyDown: ke(e.onKeyDown, O => { O.key === "Escape" && (a == null || a(O.nativeEvent), O.nativeEvent.defaultPrevented || (y.isFocusedToastEscapeKeyDownRef.current = !0, z())) }), onPointerDown: ke(e.onPointerDown, O => { O.button === 0 && (v.current = { x: O.clientX, y: O.clientY }) }), onPointerMove: ke(e.onPointerMove, O => { if (!v.current) return; const K = O.clientX - v.current.x, U = O.clientY - v.current.y, V = !!S.current, k = ["left", "right"].includes(y.swipeDirection), R = ["left", "up"].includes(y.swipeDirection) ? Math.min : Math.max, F = k ? R(0, K) : 0, W = k ? 0 : R(0, U), B = O.pointerType === "touch" ? 10 : 2, Y = { x: F, y: W }, q = { originalEvent: O, delta: Y }; V ? (S.current = Y, Io(RT, d, q, { discrete: !1 })) : Cp(Y, y.swipeDirection, B) ? (S.current = Y, Io(AT, c, q, { discrete: !1 }), O.target.setPointerCapture(O.pointerId)) : (Math.abs(K) > B || Math.abs(U) > B) && (v.current = null) }), onPointerUp: ke(e.onPointerUp, O => { const K = S.current, U = O.target; if (U.hasPointerCapture(O.pointerId) && U.releasePointerCapture(O.pointerId), S.current = null, v.current = null, K) { const V = O.currentTarget, k = { originalEvent: O, delta: K }; Cp(K, y.swipeDirection, y.swipeThreshold) ? Io(jT, h, k, { discrete: !0 }) : Io(NT, f, k, { discrete: !0 }), V.addEventListener("click", R => R.preventDefault(), { once: !0 }) } }) }) }) }), y.viewport) })] }) : null }), FT = e => { const { __scopeToast: t, children: n, ...r } = e, s = gl(ao, t), [i, o] = w.useState(!1), [a, l] = w.useState(!1); return VT(() => o(!0)), w.useEffect(() => { const u = window.setTimeout(() => l(!0), 1e3); return () => window.clearTimeout(u) }, []), a ? null : g.jsx(ev, { asChild: !0, children: g.jsx(ml, { ...r, children: i && g.jsxs(g.Fragment, { children: [s.label, " ", n] }) }) }) }, LT = "ToastTitle", av = w.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e; return g.jsx(it.div, { ...r, ref: t }) }); av.displayName = LT; var IT = "ToastDescription", lv = w.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e; return g.jsx(it.div, { ...r, ref: t }) }); lv.displayName = IT; var uv = "ToastAction", cv = w.forwardRef((e, t) => { const { altText: n, ...r } = e; return n.trim() ? g.jsx(fv, { altText: n, asChild: !0, children: g.jsx(ff, { ...r, ref: t }) }) : (console.error(`Invalid prop \`altText\` supplied to \`${uv}\`. Expected non-empty \`string\`.`), null) }); cv.displayName = uv; var dv = "ToastClose", ff = w.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e, s = DT(dv, n); return g.jsx(fv, { asChild: !0, children: g.jsx(it.button, { type: "button", ...r, ref: t, onClick: ke(e.onClick, s.onClose) }) }) }); ff.displayName = dv; var fv = w.forwardRef((e, t) => { const { __scopeToast: n, altText: r, ...s } = e; return g.jsx(it.div, { "data-radix-toast-announce-exclude": "", "data-radix-toast-announce-alt": r || void 0, ...s, ref: t }) }); function hv(e) { const t = []; return Array.from(e.childNodes).forEach(r => { if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), _T(r)) { const s = r.ariaHidden || r.hidden || r.style.display === "none", i = r.dataset.radixToastAnnounceExclude === ""; if (!s) if (i) { const o = r.dataset.radixToastAnnounceAlt; o && t.push(o) } else t.push(...hv(r)) } }), t } function Io(e, t, n, { discrete: r }) { const s = n.originalEvent.currentTarget, i = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n }); t && s.addEventListener(e, t, { once: !0 }), r ? Yy(s, i) : s.dispatchEvent(i) } var Cp = (e, t, n = 0) => { const r = Math.abs(e.x), s = Math.abs(e.y), i = r > s; return t === "left" || t === "right" ? i && r > n : !i && s > n }; function VT(e = () => { }) { const t = rr(e); sr(() => { let n = 0, r = 0; return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => { window.cancelAnimationFrame(n), window.cancelAnimationFrame(r) } }, [t]) } function _T(e) { return e.nodeType === e.ELEMENT_NODE } function zT(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const s = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t } function fu(e) { const t = document.activeElement; return e.some(n => n === t ? !0 : (n.focus(), document.activeElement !== t)) } var BT = nv, pv = sv, mv = ov, gv = av, yv = lv, vv = cv, xv = ff; function wv(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var s = e.length; for (t = 0; t < s; t++)e[t] && (n = wv(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function bv() { for (var e, t, n = 0, r = "", s = arguments.length; n < s; n++)(e = arguments[n]) && (t = wv(e)) && (r && (r += " "), r += t); return r } const Ep = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, Pp = bv, $T = (e, t) => n => { var r; if ((t == null ? void 0 : t.variants) == null) return Pp(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className); const { variants: s, defaultVariants: i } = t, o = Object.keys(s).map(u => { const c = n == null ? void 0 : n[u], d = i == null ? void 0 : i[u]; if (c === null) return null; const f = Ep(c) || Ep(d); return s[u][f] }), a = n && Object.entries(n).reduce((u, c) => { let [d, f] = c; return f === void 0 || (u[d] = f), u }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, c) => { let { class: d, className: f, ...h } = c; return Object.entries(h).every(x => { let [y, b] = x; return Array.isArray(b) ? b.includes({ ...i, ...a }[y]) : { ...i, ...a }[y] === b }) ? [...u, d, f] : u }, []); return Pp(e, o, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className) };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const UT = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Sv = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim();/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var WT = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const HT = w.forwardRef(({ color: e = "currentColor", size: t = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: s = "", children: i, iconNode: o, ...a }, l) => w.createElement("svg", { ref: l, ...WT, width: t, height: t, stroke: e, strokeWidth: r ? Number(n) * 24 / Number(t) : n, className: Sv("lucide", s), ...a }, [...o.map(([u, c]) => w.createElement(u, c)), ...Array.isArray(i) ? i : [i]]));/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const KT = (e, t) => { const n = w.forwardRef(({ className: r, ...s }, i) => w.createElement(HT, { ref: i, iconNode: t, className: Sv(`lucide-${UT(e)}`, r), ...s })); return n.displayName = `${e}`, n };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const GT = KT("X", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]), hf = "-", XT = e => { const t = YT(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e; return { getClassGroupId: o => { const a = o.split(hf); return a[0] === "" && a.length !== 1 && a.shift(), Tv(a, t) || QT(o) }, getConflictingClassGroupIds: (o, a) => { const l = n[o] || []; return a && r[o] ? [...l, ...r[o]] : l } } }, Tv = (e, t) => { var o; if (e.length === 0) return t.classGroupId; const n = e[0], r = t.nextPart.get(n), s = r ? Tv(e.slice(1), r) : void 0; if (s) return s; if (t.validators.length === 0) return; const i = e.join(hf); return (o = t.validators.find(({ validator: a }) => a(i))) == null ? void 0 : o.classGroupId }, kp = /^\[(.+)\]$/, QT = e => { if (kp.test(e)) { const t = kp.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":")); if (n) return "arbitrary.." + n } }, YT = e => { const { theme: t, prefix: n } = e, r = { nextPart: new Map, validators: [] }; return ZT(Object.entries(e.classGroups), n).forEach(([i, o]) => { jc(o, r, i, t) }), r }, jc = (e, t, n, r) => { e.forEach(s => { if (typeof s == "string") { const i = s === "" ? t : Ap(t, s); i.classGroupId = n; return } if (typeof s == "function") { if (qT(s)) { jc(s(r), t, n, r); return } t.validators.push({ validator: s, classGroupId: n }); return } Object.entries(s).forEach(([i, o]) => { jc(o, Ap(t, i), n, r) }) }) }, Ap = (e, t) => { let n = e; return t.split(hf).forEach(r => { n.nextPart.has(r) || n.nextPart.set(r, { nextPart: new Map, validators: [] }), n = n.nextPart.get(r) }), n }, qT = e => e.isThemeGetter, ZT = (e, t) => t ? e.map(([n, r]) => { const s = r.map(i => typeof i == "string" ? t + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([o, a]) => [t + o, a])) : i); return [n, s] }) : e, JT = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, n = new Map, r = new Map; const s = (i, o) => { n.set(i, o), t++, t > e && (t = 0, r = n, n = new Map) }; return { get(i) { let o = n.get(i); if (o !== void 0) return o; if ((o = r.get(i)) !== void 0) return s(i, o), o }, set(i, o) { n.has(i) ? n.set(i, o) : s(i, o) } } }, Cv = "!", eC = e => { const { separator: t, experimentalParseClassName: n } = e, r = t.length === 1, s = t[0], i = t.length, o = a => { const l = []; let u = 0, c = 0, d; for (let b = 0; b < a.length; b++) { let p = a[b]; if (u === 0) { if (p === s && (r || a.slice(b, b + i) === t)) { l.push(a.slice(c, b)), c = b + i; continue } if (p === "/") { d = b; continue } } p === "[" ? u++ : p === "]" && u-- } const f = l.length === 0 ? a : a.substring(c), h = f.startsWith(Cv), x = h ? f.substring(1) : f, y = d && d > c ? d - c : void 0; return { modifiers: l, hasImportantModifier: h, baseClassName: x, maybePostfixModifierPosition: y } }; return n ? a => n({ className: a, parseClassName: o }) : o }, tC = e => { if (e.length <= 1) return e; const t = []; let n = []; return e.forEach(r => { r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r) }), t.push(...n.sort()), t }, nC = e => ({ cache: JT(e.cacheSize), parseClassName: eC(e), ...XT(e) }), rC = /\s+/, sC = (e, t) => { const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: s } = t, i = [], o = e.trim().split(rC); let a = ""; for (let l = o.length - 1; l >= 0; l -= 1) { const u = o[l], { modifiers: c, hasImportantModifier: d, baseClassName: f, maybePostfixModifierPosition: h } = n(u); let x = !!h, y = r(x ? f.substring(0, h) : f); if (!y) { if (!x) { a = u + (a.length > 0 ? " " + a : a); continue } if (y = r(f), !y) { a = u + (a.length > 0 ? " " + a : a); continue } x = !1 } const b = tC(c).join(":"), p = d ? b + Cv : b, m = p + y; if (i.includes(m)) continue; i.push(m); const v = s(y, x); for (let S = 0; S < v.length; ++S) { const T = v[S]; i.push(p + T) } a = u + (a.length > 0 ? " " + a : a) } return a }; function iC() { let e = 0, t, n, r = ""; for (; e < arguments.length;)(t = arguments[e++]) && (n = Ev(t)) && (r && (r += " "), r += n); return r } const Ev = e => { if (typeof e == "string") return e; let t, n = ""; for (let r = 0; r < e.length; r++)e[r] && (t = Ev(e[r])) && (n && (n += " "), n += t); return n }; function oC(e, ...t) { let n, r, s, i = o; function o(l) { const u = t.reduce((c, d) => d(c), e()); return n = nC(u), r = n.cache.get, s = n.cache.set, i = a, a(l) } function a(l) { const u = r(l); if (u) return u; const c = sC(l, n); return s(l, c), c } return function () { return i(iC.apply(null, arguments)) } } const ae = e => { const t = n => n[e] || []; return t.isThemeGetter = !0, t }, Pv = /^\[(?:([a-z-]+):)?(.+)\]$/i, aC = /^\d+\/\d+$/, lC = new Set(["px", "full", "screen"]), uC = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, cC = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, dC = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, fC = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, hC = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, ln = e => ys(e) || lC.has(e) || aC.test(e), Rn = e => Us(e, "length", bC), ys = e => !!e && !Number.isNaN(Number(e)), hu = e => Us(e, "number", ys), ii = e => !!e && Number.isInteger(Number(e)), pC = e => e.endsWith("%") && ys(e.slice(0, -1)), Q = e => Pv.test(e), Nn = e => uC.test(e), mC = new Set(["length", "size", "percentage"]), gC = e => Us(e, mC, kv), yC = e => Us(e, "position", kv), vC = new Set(["image", "url"]), xC = e => Us(e, vC, TC), wC = e => Us(e, "", SC), oi = () => !0, Us = (e, t, n) => { const r = Pv.exec(e); return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1 }, bC = e => cC.test(e) && !dC.test(e), kv = () => !1, SC = e => fC.test(e), TC = e => hC.test(e), CC = () => { const e = ae("colors"), t = ae("spacing"), n = ae("blur"), r = ae("brightness"), s = ae("borderColor"), i = ae("borderRadius"), o = ae("borderSpacing"), a = ae("borderWidth"), l = ae("contrast"), u = ae("grayscale"), c = ae("hueRotate"), d = ae("invert"), f = ae("gap"), h = ae("gradientColorStops"), x = ae("gradientColorStopPositions"), y = ae("inset"), b = ae("margin"), p = ae("opacity"), m = ae("padding"), v = ae("saturate"), S = ae("scale"), T = ae("sepia"), C = ae("skew"), E = ae("space"), P = ae("translate"), N = () => ["auto", "contain", "none"], j = () => ["auto", "hidden", "clip", "visible", "scroll"], z = () => ["auto", Q, t], L = () => [Q, t], H = () => ["", ln, Rn], O = () => ["auto", ys, Q], K = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], U = () => ["solid", "dashed", "dotted", "double", "none"], V = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], k = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], R = () => ["", "0", Q], F = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], W = () => [ys, Q]; return { cacheSize: 500, separator: ":", theme: { colors: [oi], spacing: [ln, Rn], blur: ["none", "", Nn, Q], brightness: W(), borderColor: [e], borderRadius: ["none", "", "full", Nn, Q], borderSpacing: L(), borderWidth: H(), contrast: W(), grayscale: R(), hueRotate: W(), invert: R(), gap: L(), gradientColorStops: [e], gradientColorStopPositions: [pC, Rn], inset: z(), margin: z(), opacity: W(), padding: L(), saturate: W(), scale: W(), sepia: R(), skew: W(), space: L(), translate: L() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", Q] }], container: ["container"], columns: [{ columns: [Nn] }], "break-after": [{ "break-after": F() }], "break-before": [{ "break-before": F() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...K(), Q] }], overflow: [{ overflow: j() }], "overflow-x": [{ "overflow-x": j() }], "overflow-y": [{ "overflow-y": j() }], overscroll: [{ overscroll: N() }], "overscroll-x": [{ "overscroll-x": N() }], "overscroll-y": [{ "overscroll-y": N() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [y] }], "inset-x": [{ "inset-x": [y] }], "inset-y": [{ "inset-y": [y] }], start: [{ start: [y] }], end: [{ end: [y] }], top: [{ top: [y] }], right: [{ right: [y] }], bottom: [{ bottom: [y] }], left: [{ left: [y] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", ii, Q] }], basis: [{ basis: z() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", Q] }], grow: [{ grow: R() }], shrink: [{ shrink: R() }], order: [{ order: ["first", "last", "none", ii, Q] }], "grid-cols": [{ "grid-cols": [oi] }], "col-start-end": [{ col: ["auto", { span: ["full", ii, Q] }, Q] }], "col-start": [{ "col-start": O() }], "col-end": [{ "col-end": O() }], "grid-rows": [{ "grid-rows": [oi] }], "row-start-end": [{ row: ["auto", { span: [ii, Q] }, Q] }], "row-start": [{ "row-start": O() }], "row-end": [{ "row-end": O() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", Q] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", Q] }], gap: [{ gap: [f] }], "gap-x": [{ "gap-x": [f] }], "gap-y": [{ "gap-y": [f] }], "justify-content": [{ justify: ["normal", ...k()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...k(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...k(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [m] }], px: [{ px: [m] }], py: [{ py: [m] }], ps: [{ ps: [m] }], pe: [{ pe: [m] }], pt: [{ pt: [m] }], pr: [{ pr: [m] }], pb: [{ pb: [m] }], pl: [{ pl: [m] }], m: [{ m: [b] }], mx: [{ mx: [b] }], my: [{ my: [b] }], ms: [{ ms: [b] }], me: [{ me: [b] }], mt: [{ mt: [b] }], mr: [{ mr: [b] }], mb: [{ mb: [b] }], ml: [{ ml: [b] }], "space-x": [{ "space-x": [E] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [E] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Q, t] }], "min-w": [{ "min-w": [Q, t, "min", "max", "fit"] }], "max-w": [{ "max-w": [Q, t, "none", "full", "min", "max", "fit", "prose", { screen: [Nn] }, Nn] }], h: [{ h: [Q, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [Q, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [Q, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [Q, t, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", Nn, Rn] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", hu] }], "font-family": [{ font: [oi] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Q] }], "line-clamp": [{ "line-clamp": ["none", ys, hu] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", ln, Q] }], "list-image": [{ "list-image": ["none", Q] }], "list-style-type": [{ list: ["none", "disc", "decimal", Q] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [e] }], "placeholder-opacity": [{ "placeholder-opacity": [p] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [e] }], "text-opacity": [{ "text-opacity": [p] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...U(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", ln, Rn] }], "underline-offset": [{ "underline-offset": ["auto", ln, Q] }], "text-decoration-color": [{ decoration: [e] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: L() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Q] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", Q] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [p] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...K(), yC] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", gC] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, xC] }], "bg-color": [{ bg: [e] }], "gradient-from-pos": [{ from: [x] }], "gradient-via-pos": [{ via: [x] }], "gradient-to-pos": [{ to: [x] }], "gradient-from": [{ from: [h] }], "gradient-via": [{ via: [h] }], "gradient-to": [{ to: [h] }], rounded: [{ rounded: [i] }], "rounded-s": [{ "rounded-s": [i] }], "rounded-e": [{ "rounded-e": [i] }], "rounded-t": [{ "rounded-t": [i] }], "rounded-r": [{ "rounded-r": [i] }], "rounded-b": [{ "rounded-b": [i] }], "rounded-l": [{ "rounded-l": [i] }], "rounded-ss": [{ "rounded-ss": [i] }], "rounded-se": [{ "rounded-se": [i] }], "rounded-ee": [{ "rounded-ee": [i] }], "rounded-es": [{ "rounded-es": [i] }], "rounded-tl": [{ "rounded-tl": [i] }], "rounded-tr": [{ "rounded-tr": [i] }], "rounded-br": [{ "rounded-br": [i] }], "rounded-bl": [{ "rounded-bl": [i] }], "border-w": [{ border: [a] }], "border-w-x": [{ "border-x": [a] }], "border-w-y": [{ "border-y": [a] }], "border-w-s": [{ "border-s": [a] }], "border-w-e": [{ "border-e": [a] }], "border-w-t": [{ "border-t": [a] }], "border-w-r": [{ "border-r": [a] }], "border-w-b": [{ "border-b": [a] }], "border-w-l": [{ "border-l": [a] }], "border-opacity": [{ "border-opacity": [p] }], "border-style": [{ border: [...U(), "hidden"] }], "divide-x": [{ "divide-x": [a] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [a] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [p] }], "divide-style": [{ divide: U() }], "border-color": [{ border: [s] }], "border-color-x": [{ "border-x": [s] }], "border-color-y": [{ "border-y": [s] }], "border-color-s": [{ "border-s": [s] }], "border-color-e": [{ "border-e": [s] }], "border-color-t": [{ "border-t": [s] }], "border-color-r": [{ "border-r": [s] }], "border-color-b": [{ "border-b": [s] }], "border-color-l": [{ "border-l": [s] }], "divide-color": [{ divide: [s] }], "outline-style": [{ outline: ["", ...U()] }], "outline-offset": [{ "outline-offset": [ln, Q] }], "outline-w": [{ outline: [ln, Rn] }], "outline-color": [{ outline: [e] }], "ring-w": [{ ring: H() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [e] }], "ring-opacity": [{ "ring-opacity": [p] }], "ring-offset-w": [{ "ring-offset": [ln, Rn] }], "ring-offset-color": [{ "ring-offset": [e] }], shadow: [{ shadow: ["", "inner", "none", Nn, wC] }], "shadow-color": [{ shadow: [oi] }], opacity: [{ opacity: [p] }], "mix-blend": [{ "mix-blend": [...V(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": V() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [n] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [l] }], "drop-shadow": [{ "drop-shadow": ["", "none", Nn, Q] }], grayscale: [{ grayscale: [u] }], "hue-rotate": [{ "hue-rotate": [c] }], invert: [{ invert: [d] }], saturate: [{ saturate: [v] }], sepia: [{ sepia: [T] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [n] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [l] }], "backdrop-grayscale": [{ "backdrop-grayscale": [u] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [c] }], "backdrop-invert": [{ "backdrop-invert": [d] }], "backdrop-opacity": [{ "backdrop-opacity": [p] }], "backdrop-saturate": [{ "backdrop-saturate": [v] }], "backdrop-sepia": [{ "backdrop-sepia": [T] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [o] }], "border-spacing-x": [{ "border-spacing-x": [o] }], "border-spacing-y": [{ "border-spacing-y": [o] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Q] }], duration: [{ duration: W() }], ease: [{ ease: ["linear", "in", "out", "in-out", Q] }], delay: [{ delay: W() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", Q] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [S] }], "scale-x": [{ "scale-x": [S] }], "scale-y": [{ "scale-y": [S] }], rotate: [{ rotate: [ii, Q] }], "translate-x": [{ "translate-x": [P] }], "translate-y": [{ "translate-y": [P] }], "skew-x": [{ "skew-x": [C] }], "skew-y": [{ "skew-y": [C] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Q] }], accent: [{ accent: ["auto", e] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Q] }], "caret-color": [{ caret: [e] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": L() }], "scroll-mx": [{ "scroll-mx": L() }], "scroll-my": [{ "scroll-my": L() }], "scroll-ms": [{ "scroll-ms": L() }], "scroll-me": [{ "scroll-me": L() }], "scroll-mt": [{ "scroll-mt": L() }], "scroll-mr": [{ "scroll-mr": L() }], "scroll-mb": [{ "scroll-mb": L() }], "scroll-ml": [{ "scroll-ml": L() }], "scroll-p": [{ "scroll-p": L() }], "scroll-px": [{ "scroll-px": L() }], "scroll-py": [{ "scroll-py": L() }], "scroll-ps": [{ "scroll-ps": L() }], "scroll-pe": [{ "scroll-pe": L() }], "scroll-pt": [{ "scroll-pt": L() }], "scroll-pr": [{ "scroll-pr": L() }], "scroll-pb": [{ "scroll-pb": L() }], "scroll-pl": [{ "scroll-pl": L() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", Q] }], fill: [{ fill: [e, "none"] }], "stroke-w": [{ stroke: [ln, Rn, hu] }], stroke: [{ stroke: [e, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }, EC = oC(CC); function Br(...e) { return EC(bv(e)) } const PC = BT, Av = w.forwardRef(({ className: e, ...t }, n) => g.jsx(pv, { ref: n, className: Br("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", e), ...t })); Av.displayName = pv.displayName; const kC = $T("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", { variants: { variant: { default: "border bg-background text-foreground", destructive: "destructive group border-destructive bg-destructive text-destructive-foreground" } }, defaultVariants: { variant: "default" } }), Rv = w.forwardRef(({ className: e, variant: t, ...n }, r) => g.jsx(mv, { ref: r, className: Br(kC({ variant: t }), e), ...n })); Rv.displayName = mv.displayName; const AC = w.forwardRef(({ className: e, ...t }, n) => g.jsx(vv, { ref: n, className: Br("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50", e), ...t })); AC.displayName = vv.displayName; const Nv = w.forwardRef(({ className: e, ...t }, n) => g.jsx(xv, { ref: n, className: Br("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", e), "toast-close": "", ...t, children: g.jsx(GT, { className: "h-4 w-4" }) })); Nv.displayName = xv.displayName; const jv = w.forwardRef(({ className: e, ...t }, n) => g.jsx(gv, { ref: n, className: Br("text-sm font-semibold", e), ...t })); jv.displayName = gv.displayName; const Mv = w.forwardRef(({ className: e, ...t }, n) => g.jsx(yv, { ref: n, className: Br("text-sm opacity-90", e), ...t })); Mv.displayName = yv.displayName; function RC() { const { toasts: e } = QS(); return g.jsxs(PC, { children: [e.map(function ({ id: t, title: n, description: r, action: s, ...i }) { return g.jsxs(Rv, { ...i, children: [g.jsxs("div", { className: "grid gap-1", children: [n && g.jsx(jv, { children: n }), r && g.jsx(Mv, { children: r })] }), s, g.jsx(Nv, {})] }, t) }), g.jsx(Av, {})] }) } var Rp = ["light", "dark"], NC = "(prefers-color-scheme: dark)", jC = w.createContext(void 0), MC = { setTheme: e => { }, themes: [] }, DC = () => { var e; return (e = w.useContext(jC)) != null ? e : MC }; w.memo(({ forcedTheme: e, storageKey: t, attribute: n, enableSystem: r, enableColorScheme: s, defaultTheme: i, value: o, attrs: a, nonce: l }) => { let u = i === "system", c = n === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${a.map(x => `'${x}'`).join(",")})`};` : `var d=document.documentElement,n='${n}',s='setAttribute';`, d = s ? Rp.includes(i) && i ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${i}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", f = (x, y = !1, b = !0) => { let p = o ? o[x] : x, m = y ? x + "|| ''" : `'${p}'`, v = ""; return s && b && !y && Rp.includes(x) && (v += `d.style.colorScheme = '${x}';`), n === "class" ? y || p ? v += `c.add(${m})` : v += "null" : p && (v += `d[s](n,${m})`), v }, h = e ? `!function(){${c}${f(e)}}()` : r ? `!function(){try{${c}var e=localStorage.getItem('${t}');if('system'===e||(!e&&${u})){var t='${NC}',m=window.matchMedia(t);if(m.media!==t||m.matches){${f("dark")}}else{${f("light")}}}else if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${f(o ? "x[e]" : "e", !0)}}${u ? "" : "else{" + f(i, !1, !1) + "}"}${d}}catch(e){}}()` : `!function(){try{${c}var e=localStorage.getItem('${t}');if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${f(o ? "x[e]" : "e", !0)}}else{${f(i, !1, !1)};}${d}}catch(t){}}();`; return w.createElement("script", { nonce: l, dangerouslySetInnerHTML: { __html: h } }) }); var OC = e => { switch (e) { case "success": return IC; case "info": return _C; case "warning": return VC; case "error": return zC; default: return null } }, FC = Array(12).fill(0), LC = ({ visible: e, className: t }) => D.createElement("div", { className: ["sonner-loading-wrapper", t].filter(Boolean).join(" "), "data-visible": e }, D.createElement("div", { className: "sonner-spinner" }, FC.map((n, r) => D.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${r}` })))), IC = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, D.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), VC = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, D.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), _C = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, D.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), zC = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, D.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" })), BC = D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, D.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), D.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })), $C = () => { let [e, t] = D.useState(document.hidden); return D.useEffect(() => { let n = () => { t(document.hidden) }; return document.addEventListener("visibilitychange", n), () => window.removeEventListener("visibilitychange", n) }, []), e }, Mc = 1, UC = class { constructor() { this.subscribe = e => (this.subscribers.push(e), () => { let t = this.subscribers.indexOf(e); this.subscribers.splice(t, 1) }), this.publish = e => { this.subscribers.forEach(t => t(e)) }, this.addToast = e => { this.publish(e), this.toasts = [...this.toasts, e] }, this.create = e => { var t; let { message: n, ...r } = e, s = typeof (e == null ? void 0 : e.id) == "number" || ((t = e.id) == null ? void 0 : t.length) > 0 ? e.id : Mc++, i = this.toasts.find(a => a.id === s), o = e.dismissible === void 0 ? !0 : e.dismissible; return this.dismissedToasts.has(s) && this.dismissedToasts.delete(s), i ? this.toasts = this.toasts.map(a => a.id === s ? (this.publish({ ...a, ...e, id: s, title: n }), { ...a, ...e, id: s, dismissible: o, title: n }) : a) : this.addToast({ title: n, ...r, dismissible: o, id: s }), s }, this.dismiss = e => (this.dismissedToasts.add(e), e || this.toasts.forEach(t => { this.subscribers.forEach(n => n({ id: t.id, dismiss: !0 })) }), this.subscribers.forEach(t => t({ id: e, dismiss: !0 })), e), this.message = (e, t) => this.create({ ...t, message: e }), this.error = (e, t) => this.create({ ...t, message: e, type: "error" }), this.success = (e, t) => this.create({ ...t, type: "success", message: e }), this.info = (e, t) => this.create({ ...t, type: "info", message: e }), this.warning = (e, t) => this.create({ ...t, type: "warning", message: e }), this.loading = (e, t) => this.create({ ...t, type: "loading", message: e }), this.promise = (e, t) => { if (!t) return; let n; t.loading !== void 0 && (n = this.create({ ...t, promise: e, type: "loading", message: t.loading, description: typeof t.description != "function" ? t.description : void 0 })); let r = e instanceof Promise ? e : e(), s = n !== void 0, i, o = r.then(async l => { if (i = ["resolve", l], D.isValidElement(l)) s = !1, this.create({ id: n, type: "default", message: l }); else if (HC(l) && !l.ok) { s = !1; let u = typeof t.error == "function" ? await t.error(`HTTP error! status: ${l.status}`) : t.error, c = typeof t.description == "function" ? await t.description(`HTTP error! status: ${l.status}`) : t.description; this.create({ id: n, type: "error", message: u, description: c }) } else if (t.success !== void 0) { s = !1; let u = typeof t.success == "function" ? await t.success(l) : t.success, c = typeof t.description == "function" ? await t.description(l) : t.description; this.create({ id: n, type: "success", message: u, description: c }) } }).catch(async l => { if (i = ["reject", l], t.error !== void 0) { s = !1; let u = typeof t.error == "function" ? await t.error(l) : t.error, c = typeof t.description == "function" ? await t.description(l) : t.description; this.create({ id: n, type: "error", message: u, description: c }) } }).finally(() => { var l; s && (this.dismiss(n), n = void 0), (l = t.finally) == null || l.call(t) }), a = () => new Promise((l, u) => o.then(() => i[0] === "reject" ? u(i[1]) : l(i[1])).catch(u)); return typeof n != "string" && typeof n != "number" ? { unwrap: a } : Object.assign(n, { unwrap: a }) }, this.custom = (e, t) => { let n = (t == null ? void 0 : t.id) || Mc++; return this.create({ jsx: e(n), id: n, ...t }), n }, this.getActiveToasts = () => this.toasts.filter(e => !this.dismissedToasts.has(e.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = new Set } }, Ze = new UC, WC = (e, t) => { let n = (t == null ? void 0 : t.id) || Mc++; return Ze.addToast({ title: e, ...t, id: n }), n }, HC = e => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", KC = WC, GC = () => Ze.toasts, XC = () => Ze.getActiveToasts(); Object.assign(KC, { success: Ze.success, info: Ze.info, warning: Ze.warning, error: Ze.error, custom: Ze.custom, message: Ze.message, promise: Ze.promise, dismiss: Ze.dismiss, loading: Ze.loading }, { getHistory: GC, getToasts: XC }); function QC(e, { insertAt: t } = {}) { if (typeof document > "u") return; let n = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style"); r.type = "text/css", t === "top" && n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r), r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e)) } QC(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`); function Vo(e) { return e.label !== void 0 } var YC = 3, qC = "32px", ZC = "16px", Np = 4e3, JC = 356, eE = 14, tE = 20, nE = 200; function jt(...e) { return e.filter(Boolean).join(" ") } function rE(e) { let [t, n] = e.split("-"), r = []; return t && r.push(t), n && r.push(n), r } var sE = e => { var t, n, r, s, i, o, a, l, u, c, d; let { invert: f, toast: h, unstyled: x, interacting: y, setHeights: b, visibleToasts: p, heights: m, index: v, toasts: S, expanded: T, removeToast: C, defaultRichColors: E, closeButton: P, style: N, cancelButtonStyle: j, actionButtonStyle: z, className: L = "", descriptionClassName: H = "", duration: O, position: K, gap: U, loadingIcon: V, expandByDefault: k, classNames: R, icons: F, closeButtonAriaLabel: W = "Close toast", pauseWhenPageIsHidden: B } = e, [Y, q] = D.useState(null), [he, Se] = D.useState(null), [J, ce] = D.useState(!1), [se, ot] = D.useState(!1), [qe, Re] = D.useState(!1), [at, mo] = D.useState(!1), [Dl, go] = D.useState(!1), [Ol, Qs] = D.useState(0), [$r, sh] = D.useState(0), Ys = D.useRef(h.duration || O || Np), ih = D.useRef(null), hr = D.useRef(null), uw = v === 0, cw = v + 1 <= p, gt = h.type, Ur = h.dismissible !== !1, dw = h.className || "", fw = h.descriptionClassName || "", yo = D.useMemo(() => m.findIndex(G => G.toastId === h.id) || 0, [m, h.id]), hw = D.useMemo(() => { var G; return (G = h.closeButton) != null ? G : P }, [h.closeButton, P]), oh = D.useMemo(() => h.duration || O || Np, [h.duration, O]), Fl = D.useRef(0), Wr = D.useRef(0), ah = D.useRef(0), Hr = D.useRef(null), [pw, mw] = K.split("-"), lh = D.useMemo(() => m.reduce((G, re, de) => de >= yo ? G : G + re.height, 0), [m, yo]), uh = $C(), gw = h.invert || f, Ll = gt === "loading"; Wr.current = D.useMemo(() => yo * U + lh, [yo, lh]), D.useEffect(() => { Ys.current = oh }, [oh]), D.useEffect(() => { ce(!0) }, []), D.useEffect(() => { let G = hr.current; if (G) { let re = G.getBoundingClientRect().height; return sh(re), b(de => [{ toastId: h.id, height: re, position: h.position }, ...de]), () => b(de => de.filter(kt => kt.toastId !== h.id)) } }, [b, h.id]), D.useLayoutEffect(() => { if (!J) return; let G = hr.current, re = G.style.height; G.style.height = "auto"; let de = G.getBoundingClientRect().height; G.style.height = re, sh(de), b(kt => kt.find(At => At.toastId === h.id) ? kt.map(At => At.toastId === h.id ? { ...At, height: de } : At) : [{ toastId: h.id, height: de, position: h.position }, ...kt]) }, [J, h.title, h.description, b, h.id]); let En = D.useCallback(() => { ot(!0), Qs(Wr.current), b(G => G.filter(re => re.toastId !== h.id)), setTimeout(() => { C(h) }, nE) }, [h, C, b, Wr]); D.useEffect(() => { if (h.promise && gt === "loading" || h.duration === 1 / 0 || h.type === "loading") return; let G; return T || y || B && uh ? (() => { if (ah.current < Fl.current) { let re = new Date().getTime() - Fl.current; Ys.current = Ys.current - re } ah.current = new Date().getTime() })() : Ys.current !== 1 / 0 && (Fl.current = new Date().getTime(), G = setTimeout(() => { var re; (re = h.onAutoClose) == null || re.call(h, h), En() }, Ys.current)), () => clearTimeout(G) }, [T, y, h, gt, B, uh, En]), D.useEffect(() => { h.delete && En() }, [En, h.delete]); function yw() { var G, re, de; return F != null && F.loading ? D.createElement("div", { className: jt(R == null ? void 0 : R.loader, (G = h == null ? void 0 : h.classNames) == null ? void 0 : G.loader, "sonner-loader"), "data-visible": gt === "loading" }, F.loading) : V ? D.createElement("div", { className: jt(R == null ? void 0 : R.loader, (re = h == null ? void 0 : h.classNames) == null ? void 0 : re.loader, "sonner-loader"), "data-visible": gt === "loading" }, V) : D.createElement(LC, { className: jt(R == null ? void 0 : R.loader, (de = h == null ? void 0 : h.classNames) == null ? void 0 : de.loader), visible: gt === "loading" }) } return D.createElement("li", { tabIndex: 0, ref: hr, className: jt(L, dw, R == null ? void 0 : R.toast, (t = h == null ? void 0 : h.classNames) == null ? void 0 : t.toast, R == null ? void 0 : R.default, R == null ? void 0 : R[gt], (n = h == null ? void 0 : h.classNames) == null ? void 0 : n[gt]), "data-sonner-toast": "", "data-rich-colors": (r = h.richColors) != null ? r : E, "data-styled": !(h.jsx || h.unstyled || x), "data-mounted": J, "data-promise": !!h.promise, "data-swiped": Dl, "data-removed": se, "data-visible": cw, "data-y-position": pw, "data-x-position": mw, "data-index": v, "data-front": uw, "data-swiping": qe, "data-dismissible": Ur, "data-type": gt, "data-invert": gw, "data-swipe-out": at, "data-swipe-direction": he, "data-expanded": !!(T || k && J), style: { "--index": v, "--toasts-before": v, "--z-index": S.length - v, "--offset": `${se ? Ol : Wr.current}px`, "--initial-height": k ? "auto" : `${$r}px`, ...N, ...h.style }, onDragEnd: () => { Re(!1), q(null), Hr.current = null }, onPointerDown: G => { Ll || !Ur || (ih.current = new Date, Qs(Wr.current), G.target.setPointerCapture(G.pointerId), G.target.tagName !== "BUTTON" && (Re(!0), Hr.current = { x: G.clientX, y: G.clientY })) }, onPointerUp: () => { var G, re, de, kt; if (at || !Ur) return; Hr.current = null; let At = Number(((G = hr.current) == null ? void 0 : G.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), Pn = Number(((re = hr.current) == null ? void 0 : re.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), pr = new Date().getTime() - ((de = ih.current) == null ? void 0 : de.getTime()), Rt = Y === "x" ? At : Pn, kn = Math.abs(Rt) / pr; if (Math.abs(Rt) >= tE || kn > .11) { Qs(Wr.current), (kt = h.onDismiss) == null || kt.call(h, h), Se(Y === "x" ? At > 0 ? "right" : "left" : Pn > 0 ? "down" : "up"), En(), mo(!0), go(!1); return } Re(!1), q(null) }, onPointerMove: G => { var re, de, kt, At; if (!Hr.current || !Ur || ((re = window.getSelection()) == null ? void 0 : re.toString().length) > 0) return; let Pn = G.clientY - Hr.current.y, pr = G.clientX - Hr.current.x, Rt = (de = e.swipeDirections) != null ? de : rE(K); !Y && (Math.abs(pr) > 1 || Math.abs(Pn) > 1) && q(Math.abs(pr) > Math.abs(Pn) ? "x" : "y"); let kn = { x: 0, y: 0 }; Y === "y" ? (Rt.includes("top") || Rt.includes("bottom")) && (Rt.includes("top") && Pn < 0 || Rt.includes("bottom") && Pn > 0) && (kn.y = Pn) : Y === "x" && (Rt.includes("left") || Rt.includes("right")) && (Rt.includes("left") && pr < 0 || Rt.includes("right") && pr > 0) && (kn.x = pr), (Math.abs(kn.x) > 0 || Math.abs(kn.y) > 0) && go(!0), (kt = hr.current) == null || kt.style.setProperty("--swipe-amount-x", `${kn.x}px`), (At = hr.current) == null || At.style.setProperty("--swipe-amount-y", `${kn.y}px`) } }, hw && !h.jsx ? D.createElement("button", { "aria-label": W, "data-disabled": Ll, "data-close-button": !0, onClick: Ll || !Ur ? () => { } : () => { var G; En(), (G = h.onDismiss) == null || G.call(h, h) }, className: jt(R == null ? void 0 : R.closeButton, (s = h == null ? void 0 : h.classNames) == null ? void 0 : s.closeButton) }, (i = F == null ? void 0 : F.close) != null ? i : BC) : null, h.jsx || w.isValidElement(h.title) ? h.jsx ? h.jsx : typeof h.title == "function" ? h.title() : h.title : D.createElement(D.Fragment, null, gt || h.icon || h.promise ? D.createElement("div", { "data-icon": "", className: jt(R == null ? void 0 : R.icon, (o = h == null ? void 0 : h.classNames) == null ? void 0 : o.icon) }, h.promise || h.type === "loading" && !h.icon ? h.icon || yw() : null, h.type !== "loading" ? h.icon || (F == null ? void 0 : F[gt]) || OC(gt) : null) : null, D.createElement("div", { "data-content": "", className: jt(R == null ? void 0 : R.content, (a = h == null ? void 0 : h.classNames) == null ? void 0 : a.content) }, D.createElement("div", { "data-title": "", className: jt(R == null ? void 0 : R.title, (l = h == null ? void 0 : h.classNames) == null ? void 0 : l.title) }, typeof h.title == "function" ? h.title() : h.title), h.description ? D.createElement("div", { "data-description": "", className: jt(H, fw, R == null ? void 0 : R.description, (u = h == null ? void 0 : h.classNames) == null ? void 0 : u.description) }, typeof h.description == "function" ? h.description() : h.description) : null), w.isValidElement(h.cancel) ? h.cancel : h.cancel && Vo(h.cancel) ? D.createElement("button", { "data-button": !0, "data-cancel": !0, style: h.cancelButtonStyle || j, onClick: G => { var re, de; Vo(h.cancel) && Ur && ((de = (re = h.cancel).onClick) == null || de.call(re, G), En()) }, className: jt(R == null ? void 0 : R.cancelButton, (c = h == null ? void 0 : h.classNames) == null ? void 0 : c.cancelButton) }, h.cancel.label) : null, w.isValidElement(h.action) ? h.action : h.action && Vo(h.action) ? D.createElement("button", { "data-button": !0, "data-action": !0, style: h.actionButtonStyle || z, onClick: G => { var re, de; Vo(h.action) && ((de = (re = h.action).onClick) == null || de.call(re, G), !G.defaultPrevented && En()) }, className: jt(R == null ? void 0 : R.actionButton, (d = h == null ? void 0 : h.classNames) == null ? void 0 : d.actionButton) }, h.action.label) : null)) }; function jp() { if (typeof window > "u" || typeof document > "u") return "ltr"; let e = document.documentElement.getAttribute("dir"); return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e } function iE(e, t) { let n = {}; return [e, t].forEach((r, s) => { let i = s === 1, o = i ? "--mobile-offset" : "--offset", a = i ? ZC : qC; function l(u) { ["top", "right", "bottom", "left"].forEach(c => { n[`${o}-${c}`] = typeof u == "number" ? `${u}px` : u }) } typeof r == "number" || typeof r == "string" ? l(r) : typeof r == "object" ? ["top", "right", "bottom", "left"].forEach(u => { r[u] === void 0 ? n[`${o}-${u}`] = a : n[`${o}-${u}`] = typeof r[u] == "number" ? `${r[u]}px` : r[u] }) : l(a) }), n } var oE = w.forwardRef(function (e, t) { let { invert: n, position: r = "bottom-right", hotkey: s = ["altKey", "KeyT"], expand: i, closeButton: o, className: a, offset: l, mobileOffset: u, theme: c = "light", richColors: d, duration: f, style: h, visibleToasts: x = YC, toastOptions: y, dir: b = jp(), gap: p = eE, loadingIcon: m, icons: v, containerAriaLabel: S = "Notifications", pauseWhenPageIsHidden: T } = e, [C, E] = D.useState([]), P = D.useMemo(() => Array.from(new Set([r].concat(C.filter(B => B.position).map(B => B.position)))), [C, r]), [N, j] = D.useState([]), [z, L] = D.useState(!1), [H, O] = D.useState(!1), [K, U] = D.useState(c !== "system" ? c : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), V = D.useRef(null), k = s.join("+").replace(/Key/g, "").replace(/Digit/g, ""), R = D.useRef(null), F = D.useRef(!1), W = D.useCallback(B => { E(Y => { var q; return (q = Y.find(he => he.id === B.id)) != null && q.delete || Ze.dismiss(B.id), Y.filter(({ id: he }) => he !== B.id) }) }, []); return D.useEffect(() => Ze.subscribe(B => { if (B.dismiss) { E(Y => Y.map(q => q.id === B.id ? { ...q, delete: !0 } : q)); return } setTimeout(() => { Ky.flushSync(() => { E(Y => { let q = Y.findIndex(he => he.id === B.id); return q !== -1 ? [...Y.slice(0, q), { ...Y[q], ...B }, ...Y.slice(q + 1)] : [B, ...Y] }) }) }) }), []), D.useEffect(() => { if (c !== "system") { U(c); return } if (c === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? U("dark") : U("light")), typeof window > "u") return; let B = window.matchMedia("(prefers-color-scheme: dark)"); try { B.addEventListener("change", ({ matches: Y }) => { U(Y ? "dark" : "light") }) } catch { B.addListener(({ matches: q }) => { try { U(q ? "dark" : "light") } catch (he) { console.error(he) } }) } }, [c]), D.useEffect(() => { C.length <= 1 && L(!1) }, [C]), D.useEffect(() => { let B = Y => { var q, he; s.every(Se => Y[Se] || Y.code === Se) && (L(!0), (q = V.current) == null || q.focus()), Y.code === "Escape" && (document.activeElement === V.current || (he = V.current) != null && he.contains(document.activeElement)) && L(!1) }; return document.addEventListener("keydown", B), () => document.removeEventListener("keydown", B) }, [s]), D.useEffect(() => { if (V.current) return () => { R.current && (R.current.focus({ preventScroll: !0 }), R.current = null, F.current = !1) } }, [V.current]), D.createElement("section", { ref: t, "aria-label": `${S} ${k}`, tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: !0 }, P.map((B, Y) => { var q; let [he, Se] = B.split("-"); return C.length ? D.createElement("ol", { key: B, dir: b === "auto" ? jp() : b, tabIndex: -1, ref: V, className: a, "data-sonner-toaster": !0, "data-theme": K, "data-y-position": he, "data-lifted": z && C.length > 1 && !i, "data-x-position": Se, style: { "--front-toast-height": `${((q = N[0]) == null ? void 0 : q.height) || 0}px`, "--width": `${JC}px`, "--gap": `${p}px`, ...h, ...iE(l, u) }, onBlur: J => { F.current && !J.currentTarget.contains(J.relatedTarget) && (F.current = !1, R.current && (R.current.focus({ preventScroll: !0 }), R.current = null)) }, onFocus: J => { J.target instanceof HTMLElement && J.target.dataset.dismissible === "false" || F.current || (F.current = !0, R.current = J.relatedTarget) }, onMouseEnter: () => L(!0), onMouseMove: () => L(!0), onMouseLeave: () => { H || L(!1) }, onDragEnd: () => L(!1), onPointerDown: J => { J.target instanceof HTMLElement && J.target.dataset.dismissible === "false" || O(!0) }, onPointerUp: () => O(!1) }, C.filter(J => !J.position && Y === 0 || J.position === B).map((J, ce) => { var se, ot; return D.createElement(sE, { key: J.id, icons: v, index: ce, toast: J, defaultRichColors: d, duration: (se = y == null ? void 0 : y.duration) != null ? se : f, className: y == null ? void 0 : y.className, descriptionClassName: y == null ? void 0 : y.descriptionClassName, invert: n, visibleToasts: x, closeButton: (ot = y == null ? void 0 : y.closeButton) != null ? ot : o, interacting: H, position: B, style: y == null ? void 0 : y.style, unstyled: y == null ? void 0 : y.unstyled, classNames: y == null ? void 0 : y.classNames, cancelButtonStyle: y == null ? void 0 : y.cancelButtonStyle, actionButtonStyle: y == null ? void 0 : y.actionButtonStyle, removeToast: W, toasts: C.filter(qe => qe.position == J.position), heights: N.filter(qe => qe.position == J.position), setHeights: j, expandByDefault: i, gap: p, loadingIcon: m, expanded: z, pauseWhenPageIsHidden: T, swipeDirections: e.swipeDirections }) })) : null })) }); const aE = ({ ...e }) => { const { theme: t = "system" } = DC(); return g.jsx(oE, { theme: t, className: "toaster group", toastOptions: { classNames: { toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg", description: "group-[.toast]:text-muted-foreground", actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground", cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground" } }, ...e }) }, lE = ["top", "right", "bottom", "left"], ir = Math.min, ut = Math.max, La = Math.round, _o = Math.floor, nn = e => ({ x: e, y: e }), uE = { left: "right", right: "left", bottom: "top", top: "bottom" }, cE = { start: "end", end: "start" }; function Dc(e, t, n) { return ut(e, ir(t, n)) } function bn(e, t) { return typeof e == "function" ? e(t) : e } function Sn(e) { return e.split("-")[0] } function Ws(e) { return e.split("-")[1] } function pf(e) { return e === "x" ? "y" : "x" } function mf(e) { return e === "y" ? "height" : "width" } const dE = new Set(["top", "bottom"]); function Jt(e) { return dE.has(Sn(e)) ? "y" : "x" } function gf(e) { return pf(Jt(e)) } function fE(e, t, n) { n === void 0 && (n = !1); const r = Ws(e), s = gf(e), i = mf(s); let o = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top"; return t.reference[i] > t.floating[i] && (o = Ia(o)), [o, Ia(o)] } function hE(e) { const t = Ia(e); return [Oc(e), t, Oc(t)] } function Oc(e) { return e.replace(/start|end/g, t => cE[t]) } const Mp = ["left", "right"], Dp = ["right", "left"], pE = ["top", "bottom"], mE = ["bottom", "top"]; function gE(e, t, n) { switch (e) { case "top": case "bottom": return n ? t ? Dp : Mp : t ? Mp : Dp; case "left": case "right": return t ? pE : mE; default: return [] } } function yE(e, t, n, r) { const s = Ws(e); let i = gE(Sn(e), n === "start", r); return s && (i = i.map(o => o + "-" + s), t && (i = i.concat(i.map(Oc)))), i } function Ia(e) { return e.replace(/left|right|bottom|top/g, t => uE[t]) } function vE(e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } } function Dv(e) { return typeof e != "number" ? vE(e) : { top: e, right: e, bottom: e, left: e } } function Va(e) { const { x: t, y: n, width: r, height: s } = e; return { width: r, height: s, top: n, left: t, right: t + r, bottom: n + s, x: t, y: n } } function Op(e, t, n) { let { reference: r, floating: s } = e; const i = Jt(t), o = gf(t), a = mf(o), l = Sn(t), u = i === "y", c = r.x + r.width / 2 - s.width / 2, d = r.y + r.height / 2 - s.height / 2, f = r[a] / 2 - s[a] / 2; let h; switch (l) { case "top": h = { x: c, y: r.y - s.height }; break; case "bottom": h = { x: c, y: r.y + r.height }; break; case "right": h = { x: r.x + r.width, y: d }; break; case "left": h = { x: r.x - s.width, y: d }; break; default: h = { x: r.x, y: r.y } }switch (Ws(t)) { case "start": h[o] -= f * (n && u ? -1 : 1); break; case "end": h[o] += f * (n && u ? -1 : 1); break }return h } const xE = async (e, t, n) => { const { placement: r = "bottom", strategy: s = "absolute", middleware: i = [], platform: o } = n, a = i.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t)); let u = await o.getElementRects({ reference: e, floating: t, strategy: s }), { x: c, y: d } = Op(u, r, l), f = r, h = {}, x = 0; for (let y = 0; y < a.length; y++) { const { name: b, fn: p } = a[y], { x: m, y: v, data: S, reset: T } = await p({ x: c, y: d, initialPlacement: r, placement: f, strategy: s, middlewareData: h, rects: u, platform: o, elements: { reference: e, floating: t } }); c = m ?? c, d = v ?? d, h = { ...h, [b]: { ...h[b], ...S } }, T && x <= 50 && (x++, typeof T == "object" && (T.placement && (f = T.placement), T.rects && (u = T.rects === !0 ? await o.getElementRects({ reference: e, floating: t, strategy: s }) : T.rects), { x: c, y: d } = Op(u, f, l)), y = -1) } return { x: c, y: d, placement: f, strategy: s, middlewareData: h } }; async function Wi(e, t) { var n; t === void 0 && (t = {}); const { x: r, y: s, platform: i, rects: o, elements: a, strategy: l } = e, { boundary: u = "clippingAncestors", rootBoundary: c = "viewport", elementContext: d = "floating", altBoundary: f = !1, padding: h = 0 } = bn(t, e), x = Dv(h), b = a[f ? d === "floating" ? "reference" : "floating" : d], p = Va(await i.getClippingRect({ element: (n = await (i.isElement == null ? void 0 : i.isElement(b))) == null || n ? b : b.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)), boundary: u, rootBoundary: c, strategy: l })), m = d === "floating" ? { x: r, y: s, width: o.floating.width, height: o.floating.height } : o.reference, v = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), S = await (i.isElement == null ? void 0 : i.isElement(v)) ? await (i.getScale == null ? void 0 : i.getScale(v)) || { x: 1, y: 1 } : { x: 1, y: 1 }, T = Va(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: a, rect: m, offsetParent: v, strategy: l }) : m); return { top: (p.top - T.top + x.top) / S.y, bottom: (T.bottom - p.bottom + x.bottom) / S.y, left: (p.left - T.left + x.left) / S.x, right: (T.right - p.right + x.right) / S.x } } const wE = e => ({ name: "arrow", options: e, async fn(t) { const { x: n, y: r, placement: s, rects: i, platform: o, elements: a, middlewareData: l } = t, { element: u, padding: c = 0 } = bn(e, t) || {}; if (u == null) return {}; const d = Dv(c), f = { x: n, y: r }, h = gf(s), x = mf(h), y = await o.getDimensions(u), b = h === "y", p = b ? "top" : "left", m = b ? "bottom" : "right", v = b ? "clientHeight" : "clientWidth", S = i.reference[x] + i.reference[h] - f[h] - i.floating[x], T = f[h] - i.reference[h], C = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u)); let E = C ? C[v] : 0; (!E || !await (o.isElement == null ? void 0 : o.isElement(C))) && (E = a.floating[v] || i.floating[x]); const P = S / 2 - T / 2, N = E / 2 - y[x] / 2 - 1, j = ir(d[p], N), z = ir(d[m], N), L = j, H = E - y[x] - z, O = E / 2 - y[x] / 2 + P, K = Dc(L, O, H), U = !l.arrow && Ws(s) != null && O !== K && i.reference[x] / 2 - (O < L ? j : z) - y[x] / 2 < 0, V = U ? O < L ? O - L : O - H : 0; return { [h]: f[h] + V, data: { [h]: K, centerOffset: O - K - V, ...U && { alignmentOffset: V } }, reset: U } } }), bE = function (e) { return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) { var n, r; const { placement: s, middlewareData: i, rects: o, initialPlacement: a, platform: l, elements: u } = t, { mainAxis: c = !0, crossAxis: d = !0, fallbackPlacements: f, fallbackStrategy: h = "bestFit", fallbackAxisSideDirection: x = "none", flipAlignment: y = !0, ...b } = bn(e, t); if ((n = i.arrow) != null && n.alignmentOffset) return {}; const p = Sn(s), m = Jt(a), v = Sn(a) === a, S = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), T = f || (v || !y ? [Ia(a)] : hE(a)), C = x !== "none"; !f && C && T.push(...yE(a, y, x, S)); const E = [a, ...T], P = await Wi(t, b), N = []; let j = ((r = i.flip) == null ? void 0 : r.overflows) || []; if (c && N.push(P[p]), d) { const O = fE(s, o, S); N.push(P[O[0]], P[O[1]]) } if (j = [...j, { placement: s, overflows: N }], !N.every(O => O <= 0)) { var z, L; const O = (((z = i.flip) == null ? void 0 : z.index) || 0) + 1, K = E[O]; if (K && (!(d === "alignment" ? m !== Jt(K) : !1) || j.every(k => k.overflows[0] > 0 && Jt(k.placement) === m))) return { data: { index: O, overflows: j }, reset: { placement: K } }; let U = (L = j.filter(V => V.overflows[0] <= 0).sort((V, k) => V.overflows[1] - k.overflows[1])[0]) == null ? void 0 : L.placement; if (!U) switch (h) { case "bestFit": { var H; const V = (H = j.filter(k => { if (C) { const R = Jt(k.placement); return R === m || R === "y" } return !0 }).map(k => [k.placement, k.overflows.filter(R => R > 0).reduce((R, F) => R + F, 0)]).sort((k, R) => k[1] - R[1])[0]) == null ? void 0 : H[0]; V && (U = V); break } case "initialPlacement": U = a; break }if (s !== U) return { reset: { placement: U } } } return {} } } }; function Fp(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function Lp(e) { return lE.some(t => e[t] >= 0) } const SE = function (e) { return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) { const { rects: n } = t, { strategy: r = "referenceHidden", ...s } = bn(e, t); switch (r) { case "referenceHidden": { const i = await Wi(t, { ...s, elementContext: "reference" }), o = Fp(i, n.reference); return { data: { referenceHiddenOffsets: o, referenceHidden: Lp(o) } } } case "escaped": { const i = await Wi(t, { ...s, altBoundary: !0 }), o = Fp(i, n.floating); return { data: { escapedOffsets: o, escaped: Lp(o) } } } default: return {} } } } }, Ov = new Set(["left", "top"]); async function TE(e, t) { const { placement: n, platform: r, elements: s } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), o = Sn(n), a = Ws(n), l = Jt(n) === "y", u = Ov.has(o) ? -1 : 1, c = i && l ? -1 : 1, d = bn(t, e); let { mainAxis: f, crossAxis: h, alignmentAxis: x } = typeof d == "number" ? { mainAxis: d, crossAxis: 0, alignmentAxis: null } : { mainAxis: d.mainAxis || 0, crossAxis: d.crossAxis || 0, alignmentAxis: d.alignmentAxis }; return a && typeof x == "number" && (h = a === "end" ? x * -1 : x), l ? { x: h * c, y: f * u } : { x: f * u, y: h * c } } const CE = function (e) { return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) { var n, r; const { x: s, y: i, placement: o, middlewareData: a } = t, l = await TE(t, e); return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : { x: s + l.x, y: i + l.y, data: { ...l, placement: o } } } } }, EE = function (e) { return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) { const { x: n, y: r, placement: s } = t, { mainAxis: i = !0, crossAxis: o = !1, limiter: a = { fn: b => { let { x: p, y: m } = b; return { x: p, y: m } } }, ...l } = bn(e, t), u = { x: n, y: r }, c = await Wi(t, l), d = Jt(Sn(s)), f = pf(d); let h = u[f], x = u[d]; if (i) { const b = f === "y" ? "top" : "left", p = f === "y" ? "bottom" : "right", m = h + c[b], v = h - c[p]; h = Dc(m, h, v) } if (o) { const b = d === "y" ? "top" : "left", p = d === "y" ? "bottom" : "right", m = x + c[b], v = x - c[p]; x = Dc(m, x, v) } const y = a.fn({ ...t, [f]: h, [d]: x }); return { ...y, data: { x: y.x - n, y: y.y - r, enabled: { [f]: i, [d]: o } } } } } }, PE = function (e) { return e === void 0 && (e = {}), { options: e, fn(t) { const { x: n, y: r, placement: s, rects: i, middlewareData: o } = t, { offset: a = 0, mainAxis: l = !0, crossAxis: u = !0 } = bn(e, t), c = { x: n, y: r }, d = Jt(s), f = pf(d); let h = c[f], x = c[d]; const y = bn(a, t), b = typeof y == "number" ? { mainAxis: y, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y }; if (l) { const v = f === "y" ? "height" : "width", S = i.reference[f] - i.floating[v] + b.mainAxis, T = i.reference[f] + i.reference[v] - b.mainAxis; h < S ? h = S : h > T && (h = T) } if (u) { var p, m; const v = f === "y" ? "width" : "height", S = Ov.has(Sn(s)), T = i.reference[d] - i.floating[v] + (S && ((p = o.offset) == null ? void 0 : p[d]) || 0) + (S ? 0 : b.crossAxis), C = i.reference[d] + i.reference[v] + (S ? 0 : ((m = o.offset) == null ? void 0 : m[d]) || 0) - (S ? b.crossAxis : 0); x < T ? x = T : x > C && (x = C) } return { [f]: h, [d]: x } } } }, kE = function (e) { return e === void 0 && (e = {}), { name: "size", options: e, async fn(t) { var n, r; const { placement: s, rects: i, platform: o, elements: a } = t, { apply: l = () => { }, ...u } = bn(e, t), c = await Wi(t, u), d = Sn(s), f = Ws(s), h = Jt(s) === "y", { width: x, height: y } = i.floating; let b, p; d === "top" || d === "bottom" ? (b = d, p = f === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (p = d, b = f === "end" ? "top" : "bottom"); const m = y - c.top - c.bottom, v = x - c.left - c.right, S = ir(y - c[b], m), T = ir(x - c[p], v), C = !t.middlewareData.shift; let E = S, P = T; if ((n = t.middlewareData.shift) != null && n.enabled.x && (P = v), (r = t.middlewareData.shift) != null && r.enabled.y && (E = m), C && !f) { const j = ut(c.left, 0), z = ut(c.right, 0), L = ut(c.top, 0), H = ut(c.bottom, 0); h ? P = x - 2 * (j !== 0 || z !== 0 ? j + z : ut(c.left, c.right)) : E = y - 2 * (L !== 0 || H !== 0 ? L + H : ut(c.top, c.bottom)) } await l({ ...t, availableWidth: P, availableHeight: E }); const N = await o.getDimensions(a.floating); return x !== N.width || y !== N.height ? { reset: { rects: !0 } } : {} } } }; function yl() { return typeof window < "u" } function Hs(e) { return Fv(e) ? (e.nodeName || "").toLowerCase() : "#document" } function ft(e) { var t; return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window } function an(e) { var t; return (t = (Fv(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement } function Fv(e) { return yl() ? e instanceof Node || e instanceof ft(e).Node : !1 } function Wt(e) { return yl() ? e instanceof Element || e instanceof ft(e).Element : !1 } function sn(e) { return yl() ? e instanceof HTMLElement || e instanceof ft(e).HTMLElement : !1 } function Ip(e) { return !yl() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ft(e).ShadowRoot } const AE = new Set(["inline", "contents"]); function lo(e) { const { overflow: t, overflowX: n, overflowY: r, display: s } = Ht(e); return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !AE.has(s) } const RE = new Set(["table", "td", "th"]); function NE(e) { return RE.has(Hs(e)) } const jE = [":popover-open", ":modal"]; function vl(e) { return jE.some(t => { try { return e.matches(t) } catch { return !1 } }) } const ME = ["transform", "translate", "scale", "rotate", "perspective"], DE = ["transform", "translate", "scale", "rotate", "perspective", "filter"], OE = ["paint", "layout", "strict", "content"]; function yf(e) { const t = vf(), n = Wt(e) ? Ht(e) : e; return ME.some(r => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || DE.some(r => (n.willChange || "").includes(r)) || OE.some(r => (n.contain || "").includes(r)) } function FE(e) { let t = or(e); for (; sn(t) && !Ls(t);) { if (yf(t)) return t; if (vl(t)) return null; t = or(t) } return null } function vf() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } const LE = new Set(["html", "body", "#document"]); function Ls(e) { return LE.has(Hs(e)) } function Ht(e) { return ft(e).getComputedStyle(e) } function xl(e) { return Wt(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY } } function or(e) { if (Hs(e) === "html") return e; const t = e.assignedSlot || e.parentNode || Ip(e) && e.host || an(e); return Ip(t) ? t.host : t } function Lv(e) { const t = or(e); return Ls(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : sn(t) && lo(t) ? t : Lv(t) } function Hi(e, t, n) { var r; t === void 0 && (t = []), n === void 0 && (n = !0); const s = Lv(e), i = s === ((r = e.ownerDocument) == null ? void 0 : r.body), o = ft(s); if (i) { const a = Fc(o); return t.concat(o, o.visualViewport || [], lo(s) ? s : [], a && n ? Hi(a) : []) } return t.concat(s, Hi(s, [], n)) } function Fc(e) { return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null } function Iv(e) { const t = Ht(e); let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0; const s = sn(e), i = s ? e.offsetWidth : n, o = s ? e.offsetHeight : r, a = La(n) !== i || La(r) !== o; return a && (n = i, r = o), { width: n, height: r, $: a } } function xf(e) { return Wt(e) ? e : e.contextElement } function vs(e) { const t = xf(e); if (!sn(t)) return nn(1); const n = t.getBoundingClientRect(), { width: r, height: s, $: i } = Iv(t); let o = (i ? La(n.width) : n.width) / r, a = (i ? La(n.height) : n.height) / s; return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: o, y: a } } const IE = nn(0); function Vv(e) { const t = ft(e); return !vf() || !t.visualViewport ? IE : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } } function VE(e, t, n) { return t === void 0 && (t = !1), !n || t && n !== ft(e) ? !1 : t } function Vr(e, t, n, r) { t === void 0 && (t = !1), n === void 0 && (n = !1); const s = e.getBoundingClientRect(), i = xf(e); let o = nn(1); t && (r ? Wt(r) && (o = vs(r)) : o = vs(e)); const a = VE(i, n, r) ? Vv(i) : nn(0); let l = (s.left + a.x) / o.x, u = (s.top + a.y) / o.y, c = s.width / o.x, d = s.height / o.y; if (i) { const f = ft(i), h = r && Wt(r) ? ft(r) : r; let x = f, y = Fc(x); for (; y && r && h !== x;) { const b = vs(y), p = y.getBoundingClientRect(), m = Ht(y), v = p.left + (y.clientLeft + parseFloat(m.paddingLeft)) * b.x, S = p.top + (y.clientTop + parseFloat(m.paddingTop)) * b.y; l *= b.x, u *= b.y, c *= b.x, d *= b.y, l += v, u += S, x = ft(y), y = Fc(x) } } return Va({ width: c, height: d, x: l, y: u }) } function wf(e, t) { const n = xl(e).scrollLeft; return t ? t.left + n : Vr(an(e)).left + n } function _v(e, t, n) { n === void 0 && (n = !1); const r = e.getBoundingClientRect(), s = r.left + t.scrollLeft - (n ? 0 : wf(e, r)), i = r.top + t.scrollTop; return { x: s, y: i } } function _E(e) { let { elements: t, rect: n, offsetParent: r, strategy: s } = e; const i = s === "fixed", o = an(r), a = t ? vl(t.floating) : !1; if (r === o || a && i) return n; let l = { scrollLeft: 0, scrollTop: 0 }, u = nn(1); const c = nn(0), d = sn(r); if ((d || !d && !i) && ((Hs(r) !== "body" || lo(o)) && (l = xl(r)), sn(r))) { const h = Vr(r); u = vs(r), c.x = h.x + r.clientLeft, c.y = h.y + r.clientTop } const f = o && !d && !i ? _v(o, l, !0) : nn(0); return { width: n.width * u.x, height: n.height * u.y, x: n.x * u.x - l.scrollLeft * u.x + c.x + f.x, y: n.y * u.y - l.scrollTop * u.y + c.y + f.y } } function zE(e) { return Array.from(e.getClientRects()) } function BE(e) { const t = an(e), n = xl(e), r = e.ownerDocument.body, s = ut(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = ut(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight); let o = -n.scrollLeft + wf(e); const a = -n.scrollTop; return Ht(r).direction === "rtl" && (o += ut(t.clientWidth, r.clientWidth) - s), { width: s, height: i, x: o, y: a } } function $E(e, t) { const n = ft(e), r = an(e), s = n.visualViewport; let i = r.clientWidth, o = r.clientHeight, a = 0, l = 0; if (s) { i = s.width, o = s.height; const u = vf(); (!u || u && t === "fixed") && (a = s.offsetLeft, l = s.offsetTop) } return { width: i, height: o, x: a, y: l } } const UE = new Set(["absolute", "fixed"]); function WE(e, t) { const n = Vr(e, !0, t === "fixed"), r = n.top + e.clientTop, s = n.left + e.clientLeft, i = sn(e) ? vs(e) : nn(1), o = e.clientWidth * i.x, a = e.clientHeight * i.y, l = s * i.x, u = r * i.y; return { width: o, height: a, x: l, y: u } } function Vp(e, t, n) { let r; if (t === "viewport") r = $E(e, n); else if (t === "document") r = BE(an(e)); else if (Wt(t)) r = WE(t, n); else { const s = Vv(e); r = { x: t.x - s.x, y: t.y - s.y, width: t.width, height: t.height } } return Va(r) } function zv(e, t) { const n = or(e); return n === t || !Wt(n) || Ls(n) ? !1 : Ht(n).position === "fixed" || zv(n, t) } function HE(e, t) { const n = t.get(e); if (n) return n; let r = Hi(e, [], !1).filter(a => Wt(a) && Hs(a) !== "body"), s = null; const i = Ht(e).position === "fixed"; let o = i ? or(e) : e; for (; Wt(o) && !Ls(o);) { const a = Ht(o), l = yf(o); !l && a.position === "fixed" && (s = null), (i ? !l && !s : !l && a.position === "static" && !!s && UE.has(s.position) || lo(o) && !l && zv(e, o)) ? r = r.filter(c => c !== o) : s = a, o = or(o) } return t.set(e, r), r } function KE(e) { let { element: t, boundary: n, rootBoundary: r, strategy: s } = e; const o = [...n === "clippingAncestors" ? vl(t) ? [] : HE(t, this._c) : [].concat(n), r], a = o[0], l = o.reduce((u, c) => { const d = Vp(t, c, s); return u.top = ut(d.top, u.top), u.right = ir(d.right, u.right), u.bottom = ir(d.bottom, u.bottom), u.left = ut(d.left, u.left), u }, Vp(t, a, s)); return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top } } function GE(e) { const { width: t, height: n } = Iv(e); return { width: t, height: n } } function XE(e, t, n) { const r = sn(t), s = an(t), i = n === "fixed", o = Vr(e, !0, i, t); let a = { scrollLeft: 0, scrollTop: 0 }; const l = nn(0); function u() { l.x = wf(s) } if (r || !r && !i) if ((Hs(t) !== "body" || lo(s)) && (a = xl(t)), r) { const h = Vr(t, !0, i, t); l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop } else s && u(); i && !r && s && u(); const c = s && !r && !i ? _v(s, a) : nn(0), d = o.left + a.scrollLeft - l.x - c.x, f = o.top + a.scrollTop - l.y - c.y; return { x: d, y: f, width: o.width, height: o.height } } function pu(e) { return Ht(e).position === "static" } function _p(e, t) { if (!sn(e) || Ht(e).position === "fixed") return null; if (t) return t(e); let n = e.offsetParent; return an(e) === n && (n = n.ownerDocument.body), n } function Bv(e, t) { const n = ft(e); if (vl(e)) return n; if (!sn(e)) { let s = or(e); for (; s && !Ls(s);) { if (Wt(s) && !pu(s)) return s; s = or(s) } return n } let r = _p(e, t); for (; r && NE(r) && pu(r);)r = _p(r, t); return r && Ls(r) && pu(r) && !yf(r) ? n : r || FE(e) || n } const QE = async function (e) { const t = this.getOffsetParent || Bv, n = this.getDimensions, r = await n(e.floating); return { reference: XE(e.reference, await t(e.floating), e.strategy), floating: { x: 0, y: 0, width: r.width, height: r.height } } }; function YE(e) { return Ht(e).direction === "rtl" } const qE = { convertOffsetParentRelativeRectToViewportRelativeRect: _E, getDocumentElement: an, getClippingRect: KE, getOffsetParent: Bv, getElementRects: QE, getClientRects: zE, getDimensions: GE, getScale: vs, isElement: Wt, isRTL: YE }; function $v(e, t) { return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height } function ZE(e, t) { let n = null, r; const s = an(e); function i() { var a; clearTimeout(r), (a = n) == null || a.disconnect(), n = null } function o(a, l) { a === void 0 && (a = !1), l === void 0 && (l = 1), i(); const u = e.getBoundingClientRect(), { left: c, top: d, width: f, height: h } = u; if (a || t(), !f || !h) return; const x = _o(d), y = _o(s.clientWidth - (c + f)), b = _o(s.clientHeight - (d + h)), p = _o(c), v = { rootMargin: -x + "px " + -y + "px " + -b + "px " + -p + "px", threshold: ut(0, ir(1, l)) || 1 }; let S = !0; function T(C) { const E = C[0].intersectionRatio; if (E !== l) { if (!S) return o(); E ? o(!1, E) : r = setTimeout(() => { o(!1, 1e-7) }, 1e3) } E === 1 && !$v(u, e.getBoundingClientRect()) && o(), S = !1 } try { n = new IntersectionObserver(T, { ...v, root: s.ownerDocument }) } catch { n = new IntersectionObserver(T, v) } n.observe(e) } return o(!0), i } function JE(e, t, n, r) { r === void 0 && (r = {}); const { ancestorScroll: s = !0, ancestorResize: i = !0, elementResize: o = typeof ResizeObserver == "function", layoutShift: a = typeof IntersectionObserver == "function", animationFrame: l = !1 } = r, u = xf(e), c = s || i ? [...u ? Hi(u) : [], ...Hi(t)] : []; c.forEach(p => { s && p.addEventListener("scroll", n, { passive: !0 }), i && p.addEventListener("resize", n) }); const d = u && a ? ZE(u, n) : null; let f = -1, h = null; o && (h = new ResizeObserver(p => { let [m] = p; m && m.target === u && h && (h.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => { var v; (v = h) == null || v.observe(t) })), n() }), u && !l && h.observe(u), h.observe(t)); let x, y = l ? Vr(e) : null; l && b(); function b() { const p = Vr(e); y && !$v(y, p) && n(), y = p, x = requestAnimationFrame(b) } return n(), () => { var p; c.forEach(m => { s && m.removeEventListener("scroll", n), i && m.removeEventListener("resize", n) }), d == null || d(), (p = h) == null || p.disconnect(), h = null, l && cancelAnimationFrame(x) } } const eP = CE, tP = EE, nP = bE, rP = kE, sP = SE, zp = wE, iP = PE, oP = (e, t, n) => { const r = new Map, s = { platform: qE, ...n }, i = { ...s.platform, _c: r }; return xE(e, t, { ...s, platform: i }) }; var aP = typeof document < "u", lP = function () { }, ia = aP ? w.useLayoutEffect : lP; function _a(e, t) { if (e === t) return !0; if (typeof e != typeof t) return !1; if (typeof e == "function" && e.toString() === t.toString()) return !0; let n, r, s; if (e && t && typeof e == "object") { if (Array.isArray(e)) { if (n = e.length, n !== t.length) return !1; for (r = n; r-- !== 0;)if (!_a(e[r], t[r])) return !1; return !0 } if (s = Object.keys(e), n = s.length, n !== Object.keys(t).length) return !1; for (r = n; r-- !== 0;)if (!{}.hasOwnProperty.call(t, s[r])) return !1; for (r = n; r-- !== 0;) { const i = s[r]; if (!(i === "_owner" && e.$$typeof) && !_a(e[i], t[i])) return !1 } return !0 } return e !== e && t !== t } function Uv(e) { return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function Bp(e, t) { const n = Uv(e); return Math.round(t * n) / n } function mu(e) { const t = w.useRef(e); return ia(() => { t.current = e }), t } function uP(e) { e === void 0 && (e = {}); const { placement: t = "bottom", strategy: n = "absolute", middleware: r = [], platform: s, elements: { reference: i, floating: o } = {}, transform: a = !0, whileElementsMounted: l, open: u } = e, [c, d] = w.useState({ x: 0, y: 0, strategy: n, placement: t, middlewareData: {}, isPositioned: !1 }), [f, h] = w.useState(r); _a(f, r) || h(r); const [x, y] = w.useState(null), [b, p] = w.useState(null), m = w.useCallback(k => { k !== C.current && (C.current = k, y(k)) }, []), v = w.useCallback(k => { k !== E.current && (E.current = k, p(k)) }, []), S = i || x, T = o || b, C = w.useRef(null), E = w.useRef(null), P = w.useRef(c), N = l != null, j = mu(l), z = mu(s), L = mu(u), H = w.useCallback(() => { if (!C.current || !E.current) return; const k = { placement: t, strategy: n, middleware: f }; z.current && (k.platform = z.current), oP(C.current, E.current, k).then(R => { const F = { ...R, isPositioned: L.current !== !1 }; O.current && !_a(P.current, F) && (P.current = F, oo.flushSync(() => { d(F) })) }) }, [f, t, n, z, L]); ia(() => { u === !1 && P.current.isPositioned && (P.current.isPositioned = !1, d(k => ({ ...k, isPositioned: !1 }))) }, [u]); const O = w.useRef(!1); ia(() => (O.current = !0, () => { O.current = !1 }), []), ia(() => { if (S && (C.current = S), T && (E.current = T), S && T) { if (j.current) return j.current(S, T, H); H() } }, [S, T, H, j, N]); const K = w.useMemo(() => ({ reference: C, floating: E, setReference: m, setFloating: v }), [m, v]), U = w.useMemo(() => ({ reference: S, floating: T }), [S, T]), V = w.useMemo(() => { const k = { position: n, left: 0, top: 0 }; if (!U.floating) return k; const R = Bp(U.floating, c.x), F = Bp(U.floating, c.y); return a ? { ...k, transform: "translate(" + R + "px, " + F + "px)", ...Uv(U.floating) >= 1.5 && { willChange: "transform" } } : { position: n, left: R, top: F } }, [n, a, U.floating, c.x, c.y]); return w.useMemo(() => ({ ...c, update: H, refs: K, elements: U, floatingStyles: V }), [c, H, K, U, V]) } const cP = e => { function t(n) { return {}.hasOwnProperty.call(n, "current") } return { name: "arrow", options: e, fn(n) { const { element: r, padding: s } = typeof e == "function" ? e(n) : e; return r && t(r) ? r.current != null ? zp({ element: r.current, padding: s }).fn(n) : {} : r ? zp({ element: r, padding: s }).fn(n) : {} } } }, dP = (e, t) => ({ ...eP(e), options: [e, t] }), fP = (e, t) => ({ ...tP(e), options: [e, t] }), hP = (e, t) => ({ ...iP(e), options: [e, t] }), pP = (e, t) => ({ ...nP(e), options: [e, t] }), mP = (e, t) => ({ ...rP(e), options: [e, t] }), gP = (e, t) => ({ ...sP(e), options: [e, t] }), yP = (e, t) => ({ ...cP(e), options: [e, t] }); var vP = "Arrow", Wv = w.forwardRef((e, t) => { const { children: n, width: r = 10, height: s = 5, ...i } = e; return g.jsx(it.svg, { ...i, ref: t, width: r, height: s, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: e.asChild ? n : g.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); Wv.displayName = vP; var xP = Wv; function wP(e) { const [t, n] = w.useState(void 0); return sr(() => { if (e) { n({ width: e.offsetWidth, height: e.offsetHeight }); const r = new ResizeObserver(s => { if (!Array.isArray(s) || !s.length) return; const i = s[0]; let o, a; if ("borderBoxSize" in i) { const l = i.borderBoxSize, u = Array.isArray(l) ? l[0] : l; o = u.inlineSize, a = u.blockSize } else o = e.offsetWidth, a = e.offsetHeight; n({ width: o, height: a }) }); return r.observe(e, { box: "border-box" }), () => r.unobserve(e) } else n(void 0) }, [e]), t } var Hv = "Popper", [Kv, Gv] = pl(Hv), [Mj, Xv] = Kv(Hv), Qv = "PopperAnchor", Yv = w.forwardRef((e, t) => { const { __scopePopper: n, virtualRef: r, ...s } = e, i = Xv(Qv, n), o = w.useRef(null), a = Ut(t, o); return w.useEffect(() => { i.onAnchorChange((r == null ? void 0 : r.current) || o.current) }), r ? null : g.jsx(it.div, { ...s, ref: a }) }); Yv.displayName = Qv; var bf = "PopperContent", [bP, SP] = Kv(bf), qv = w.forwardRef((e, t) => { var J, ce, se, ot, qe, Re; const { __scopePopper: n, side: r = "bottom", sideOffset: s = 0, align: i = "center", alignOffset: o = 0, arrowPadding: a = 0, avoidCollisions: l = !0, collisionBoundary: u = [], collisionPadding: c = 0, sticky: d = "partial", hideWhenDetached: f = !1, updatePositionStrategy: h = "optimized", onPlaced: x, ...y } = e, b = Xv(bf, n), [p, m] = w.useState(null), v = Ut(t, at => m(at)), [S, T] = w.useState(null), C = wP(S), E = (C == null ? void 0 : C.width) ?? 0, P = (C == null ? void 0 : C.height) ?? 0, N = r + (i !== "center" ? "-" + i : ""), j = typeof c == "number" ? c : { top: 0, right: 0, bottom: 0, left: 0, ...c }, z = Array.isArray(u) ? u : [u], L = z.length > 0, H = { padding: j, boundary: z.filter(CP), altBoundary: L }, { refs: O, floatingStyles: K, placement: U, isPositioned: V, middlewareData: k } = uP({ strategy: "fixed", placement: N, whileElementsMounted: (...at) => JE(...at, { animationFrame: h === "always" }), elements: { reference: b.anchor }, middleware: [dP({ mainAxis: s + P, alignmentAxis: o }), l && fP({ mainAxis: !0, crossAxis: !1, limiter: d === "partial" ? hP() : void 0, ...H }), l && pP({ ...H }), mP({ ...H, apply: ({ elements: at, rects: mo, availableWidth: Dl, availableHeight: go }) => { const { width: Ol, height: Qs } = mo.reference, $r = at.floating.style; $r.setProperty("--radix-popper-available-width", `${Dl}px`), $r.setProperty("--radix-popper-available-height", `${go}px`), $r.setProperty("--radix-popper-anchor-width", `${Ol}px`), $r.setProperty("--radix-popper-anchor-height", `${Qs}px`) } }), S && yP({ element: S, padding: a }), EP({ arrowWidth: E, arrowHeight: P }), f && gP({ strategy: "referenceHidden", ...H })] }), [R, F] = ex(U), W = rr(x); sr(() => { V && (W == null || W()) }, [V, W]); const B = (J = k.arrow) == null ? void 0 : J.x, Y = (ce = k.arrow) == null ? void 0 : ce.y, q = ((se = k.arrow) == null ? void 0 : se.centerOffset) !== 0, [he, Se] = w.useState(); return sr(() => { p && Se(window.getComputedStyle(p).zIndex) }, [p]), g.jsx("div", { ref: O.setFloating, "data-radix-popper-content-wrapper": "", style: { ...K, transform: V ? K.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: he, "--radix-popper-transform-origin": [(ot = k.transformOrigin) == null ? void 0 : ot.x, (qe = k.transformOrigin) == null ? void 0 : qe.y].join(" "), ...((Re = k.hide) == null ? void 0 : Re.referenceHidden) && { visibility: "hidden", pointerEvents: "none" } }, dir: e.dir, children: g.jsx(bP, { scope: n, placedSide: R, onArrowChange: T, arrowX: B, arrowY: Y, shouldHideArrow: q, children: g.jsx(it.div, { "data-side": R, "data-align": F, ...y, ref: v, style: { ...y.style, animation: V ? void 0 : "none" } }) }) }) }); qv.displayName = bf; var Zv = "PopperArrow", TP = { top: "bottom", right: "left", bottom: "top", left: "right" }, Jv = w.forwardRef(function (t, n) { const { __scopePopper: r, ...s } = t, i = SP(Zv, r), o = TP[i.placedSide]; return g.jsx("span", { ref: i.onArrowChange, style: { position: "absolute", left: i.arrowX, top: i.arrowY, [o]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[i.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[i.placedSide], visibility: i.shouldHideArrow ? "hidden" : void 0 }, children: g.jsx(xP, { ...s, ref: n, style: { ...s.style, display: "block" } }) }) }); Jv.displayName = Zv; function CP(e) { return e !== null } var EP = e => ({ name: "transformOrigin", options: e, fn(t) { var b, p, m; const { placement: n, rects: r, middlewareData: s } = t, o = ((b = s.arrow) == null ? void 0 : b.centerOffset) !== 0, a = o ? 0 : e.arrowWidth, l = o ? 0 : e.arrowHeight, [u, c] = ex(n), d = { start: "0%", center: "50%", end: "100%" }[c], f = (((p = s.arrow) == null ? void 0 : p.x) ?? 0) + a / 2, h = (((m = s.arrow) == null ? void 0 : m.y) ?? 0) + l / 2; let x = "", y = ""; return u === "bottom" ? (x = o ? d : `${f}px`, y = `${-l}px`) : u === "top" ? (x = o ? d : `${f}px`, y = `${r.floating.height + l}px`) : u === "right" ? (x = `${-l}px`, y = o ? d : `${h}px`) : u === "left" && (x = `${r.floating.width + l}px`, y = o ? d : `${h}px`), { data: { x, y } } } }); function ex(e) { const [t, n = "center"] = e.split("-"); return [t, n] } var PP = Yv, kP = qv, AP = Jv, [wl, Dj] = pl("Tooltip", [Gv]), Sf = Gv(), tx = "TooltipProvider", RP = 700, $p = "tooltip.open", [NP, nx] = wl(tx), rx = e => { const { __scopeTooltip: t, delayDuration: n = RP, skipDelayDuration: r = 300, disableHoverableContent: s = !1, children: i } = e, o = w.useRef(!0), a = w.useRef(!1), l = w.useRef(0); return w.useEffect(() => { const u = l.current; return () => window.clearTimeout(u) }, []), g.jsx(NP, { scope: t, isOpenDelayedRef: o, delayDuration: n, onOpen: w.useCallback(() => { window.clearTimeout(l.current), o.current = !1 }, []), onClose: w.useCallback(() => { window.clearTimeout(l.current), l.current = window.setTimeout(() => o.current = !0, r) }, [r]), isPointerInTransitRef: a, onPointerInTransitChange: w.useCallback(u => { a.current = u }, []), disableHoverableContent: s, children: i }) }; rx.displayName = tx; var sx = "Tooltip", [Oj, bl] = wl(sx), Lc = "TooltipTrigger", jP = w.forwardRef((e, t) => { const { __scopeTooltip: n, ...r } = e, s = bl(Lc, n), i = nx(Lc, n), o = Sf(n), a = w.useRef(null), l = Ut(t, a, s.onTriggerChange), u = w.useRef(!1), c = w.useRef(!1), d = w.useCallback(() => u.current = !1, []); return w.useEffect(() => () => document.removeEventListener("pointerup", d), [d]), g.jsx(PP, { asChild: !0, ...o, children: g.jsx(it.button, { "aria-describedby": s.open ? s.contentId : void 0, "data-state": s.stateAttribute, ...r, ref: l, onPointerMove: ke(e.onPointerMove, f => { f.pointerType !== "touch" && !c.current && !i.isPointerInTransitRef.current && (s.onTriggerEnter(), c.current = !0) }), onPointerLeave: ke(e.onPointerLeave, () => { s.onTriggerLeave(), c.current = !1 }), onPointerDown: ke(e.onPointerDown, () => { s.open && s.onClose(), u.current = !0, document.addEventListener("pointerup", d, { once: !0 }) }), onFocus: ke(e.onFocus, () => { u.current || s.onOpen() }), onBlur: ke(e.onBlur, s.onClose), onClick: ke(e.onClick, s.onClose) }) }) }); jP.displayName = Lc; var MP = "TooltipPortal", [Fj, DP] = wl(MP, { forceMount: void 0 }), Is = "TooltipContent", ix = w.forwardRef((e, t) => { const n = DP(Is, e.__scopeTooltip), { forceMount: r = n.forceMount, side: s = "top", ...i } = e, o = bl(Is, e.__scopeTooltip); return g.jsx(uf, { present: r || o.open, children: o.disableHoverableContent ? g.jsx(ox, { side: s, ...i, ref: t }) : g.jsx(OP, { side: s, ...i, ref: t }) }) }), OP = w.forwardRef((e, t) => { const n = bl(Is, e.__scopeTooltip), r = nx(Is, e.__scopeTooltip), s = w.useRef(null), i = Ut(t, s), [o, a] = w.useState(null), { trigger: l, onClose: u } = n, c = s.current, { onPointerInTransitChange: d } = r, f = w.useCallback(() => { a(null), d(!1) }, [d]), h = w.useCallback((x, y) => { const b = x.currentTarget, p = { x: x.clientX, y: x.clientY }, m = _P(p, b.getBoundingClientRect()), v = zP(p, m), S = BP(y.getBoundingClientRect()), T = UP([...v, ...S]); a(T), d(!0) }, [d]); return w.useEffect(() => () => f(), [f]), w.useEffect(() => { if (l && c) { const x = b => h(b, c), y = b => h(b, l); return l.addEventListener("pointerleave", x), c.addEventListener("pointerleave", y), () => { l.removeEventListener("pointerleave", x), c.removeEventListener("pointerleave", y) } } }, [l, c, h, f]), w.useEffect(() => { if (o) { const x = y => { const b = y.target, p = { x: y.clientX, y: y.clientY }, m = (l == null ? void 0 : l.contains(b)) || (c == null ? void 0 : c.contains(b)), v = !$P(p, o); m ? f() : v && (f(), u()) }; return document.addEventListener("pointermove", x), () => document.removeEventListener("pointermove", x) } }, [l, c, o, u, f]), g.jsx(ox, { ...e, ref: i }) }), [FP, LP] = wl(sx, { isInside: !1 }), IP = ZS("TooltipContent"), ox = w.forwardRef((e, t) => { const { __scopeTooltip: n, children: r, "aria-label": s, onEscapeKeyDown: i, onPointerDownOutside: o, ...a } = e, l = bl(Is, n), u = Sf(n), { onClose: c } = l; return w.useEffect(() => (document.addEventListener($p, c), () => document.removeEventListener($p, c)), [c]), w.useEffect(() => { if (l.trigger) { const d = f => { const h = f.target; h != null && h.contains(l.trigger) && c() }; return window.addEventListener("scroll", d, { capture: !0 }), () => window.removeEventListener("scroll", d, { capture: !0 }) } }, [l.trigger, c]), g.jsx(lf, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: i, onPointerDownOutside: o, onFocusOutside: d => d.preventDefault(), onDismiss: c, children: g.jsxs(kP, { "data-state": l.stateAttribute, ...u, ...a, ref: t, style: { ...a.style, "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" }, children: [g.jsx(IP, { children: r }), g.jsx(FP, { scope: n, isInside: !0, children: g.jsx(TT, { id: l.contentId, role: "tooltip", children: s || r }) })] }) }) }); ix.displayName = Is; var ax = "TooltipArrow", VP = w.forwardRef((e, t) => { const { __scopeTooltip: n, ...r } = e, s = Sf(n); return LP(ax, n).isInside ? null : g.jsx(AP, { ...s, ...r, ref: t }) }); VP.displayName = ax; function _P(e, t) { const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), s = Math.abs(t.right - e.x), i = Math.abs(t.left - e.x); switch (Math.min(n, r, s, i)) { case i: return "left"; case s: return "right"; case n: return "top"; case r: return "bottom"; default: throw new Error("unreachable") } } function zP(e, t, n = 5) { const r = []; switch (t) { case "top": r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n }); break; case "bottom": r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n }); break; case "left": r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n }); break; case "right": r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n }); break }return r } function BP(e) { const { top: t, right: n, bottom: r, left: s } = e; return [{ x: s, y: t }, { x: n, y: t }, { x: n, y: r }, { x: s, y: r }] } function $P(e, t) { const { x: n, y: r } = e; let s = !1; for (let i = 0, o = t.length - 1; i < t.length; o = i++) { const a = t[i], l = t[o], u = a.x, c = a.y, d = l.x, f = l.y; c > r != f > r && n < (d - u) * (r - c) / (f - c) + u && (s = !s) } return s } function UP(e) { const t = e.slice(); return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), WP(t) } function WP(e) { if (e.length <= 1) return e.slice(); const t = []; for (let r = 0; r < e.length; r++) { const s = e[r]; for (; t.length >= 2;) { const i = t[t.length - 1], o = t[t.length - 2]; if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) t.pop(); else break } t.push(s) } t.pop(); const n = []; for (let r = e.length - 1; r >= 0; r--) { const s = e[r]; for (; n.length >= 2;) { const i = n[n.length - 1], o = n[n.length - 2]; if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) n.pop(); else break } n.push(s) } return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n) } var HP = rx, lx = ix; const KP = HP, GP = w.forwardRef(({ className: e, sideOffset: t = 4, ...n }, r) => g.jsx(lx, { ref: r, sideOffset: t, className: Br("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", e), ...n })); GP.displayName = lx.displayName; var Sl = class { constructor() { this.listeners = new Set, this.subscribe = this.subscribe.bind(this) } subscribe(e) { return this.listeners.add(e), this.onSubscribe(), () => { this.listeners.delete(e), this.onUnsubscribe() } } hasListeners() { return this.listeners.size > 0 } onSubscribe() { } onUnsubscribe() { } }, Tl = typeof window > "u" || "Deno" in globalThis; function Ft() { } function XP(e, t) { return typeof e == "function" ? e(t) : e } function QP(e) { return typeof e == "number" && e >= 0 && e !== 1 / 0 } function YP(e, t) { return Math.max(e + (t || 0) - Date.now(), 0) } function Ic(e, t) { return typeof e == "function" ? e(t) : e } function qP(e, t) { return typeof e == "function" ? e(t) : e } function Up(e, t) { const { type: n = "all", exact: r, fetchStatus: s, predicate: i, queryKey: o, stale: a } = e; if (o) { if (r) { if (t.queryHash !== Tf(o, t.options)) return !1 } else if (!Gi(t.queryKey, o)) return !1 } if (n !== "all") { const l = t.isActive(); if (n === "active" && !l || n === "inactive" && l) return !1 } return !(typeof a == "boolean" && t.isStale() !== a || s && s !== t.state.fetchStatus || i && !i(t)) } function Wp(e, t) { const { exact: n, status: r, predicate: s, mutationKey: i } = e; if (i) { if (!t.options.mutationKey) return !1; if (n) { if (Ki(t.options.mutationKey) !== Ki(i)) return !1 } else if (!Gi(t.options.mutationKey, i)) return !1 } return !(r && t.state.status !== r || s && !s(t)) } function Tf(e, t) { return ((t == null ? void 0 : t.queryKeyHashFn) || Ki)(e) } function Ki(e) { return JSON.stringify(e, (t, n) => Vc(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n) } function Gi(e, t) { return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every(n => Gi(e[n], t[n])) : !1 } function ux(e, t) { if (e === t) return e; const n = Hp(e) && Hp(t); if (n || Vc(e) && Vc(t)) { const r = n ? e : Object.keys(e), s = r.length, i = n ? t : Object.keys(t), o = i.length, a = n ? [] : {}, l = new Set(r); let u = 0; for (let c = 0; c < o; c++) { const d = n ? c : i[c]; (!n && l.has(d) || n) && e[d] === void 0 && t[d] === void 0 ? (a[d] = void 0, u++) : (a[d] = ux(e[d], t[d]), a[d] === e[d] && e[d] !== void 0 && u++) } return s === o && u === s ? e : a } return t } function Hp(e) { return Array.isArray(e) && e.length === Object.keys(e).length } function Vc(e) { if (!Kp(e)) return !1; const t = e.constructor; if (t === void 0) return !0; const n = t.prototype; return !(!Kp(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype) } function Kp(e) { return Object.prototype.toString.call(e) === "[object Object]" } function ZP(e) { return new Promise(t => { setTimeout(t, e) }) } function JP(e, t, n) { return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? ux(e, t) : t } function ek(e, t, n = 0) { const r = [...e, t]; return n && r.length > n ? r.slice(1) : r } function tk(e, t, n = 0) { const r = [t, ...e]; return n && r.length > n ? r.slice(0, -1) : r } var Cf = Symbol(); function cx(e, t) { return !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === Cf ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn } var Cr, Vn, bs, Cg, nk = (Cg = class extends Sl { constructor() { super(); te(this, Cr); te(this, Vn); te(this, bs); X(this, bs, t => { if (!Tl && window.addEventListener) { const n = () => t(); return window.addEventListener("visibilitychange", n, !1), () => { window.removeEventListener("visibilitychange", n) } } }) } onSubscribe() { A(this, Vn) || this.setEventListener(A(this, bs)) } onUnsubscribe() { var t; this.hasListeners() || ((t = A(this, Vn)) == null || t.call(this), X(this, Vn, void 0)) } setEventListener(t) { var n; X(this, bs, t), (n = A(this, Vn)) == null || n.call(this), X(this, Vn, t(r => { typeof r == "boolean" ? this.setFocused(r) : this.onFocus() })) } setFocused(t) { A(this, Cr) !== t && (X(this, Cr, t), this.onFocus()) } onFocus() { const t = this.isFocused(); this.listeners.forEach(n => { n(t) }) } isFocused() { var t; return typeof A(this, Cr) == "boolean" ? A(this, Cr) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden" } }, Cr = new WeakMap, Vn = new WeakMap, bs = new WeakMap, Cg), dx = new nk, Ss, _n, Ts, Eg, rk = (Eg = class extends Sl { constructor() { super(); te(this, Ss, !0); te(this, _n); te(this, Ts); X(this, Ts, t => { if (!Tl && window.addEventListener) { const n = () => t(!0), r = () => t(!1); return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => { window.removeEventListener("online", n), window.removeEventListener("offline", r) } } }) } onSubscribe() { A(this, _n) || this.setEventListener(A(this, Ts)) } onUnsubscribe() { var t; this.hasListeners() || ((t = A(this, _n)) == null || t.call(this), X(this, _n, void 0)) } setEventListener(t) { var n; X(this, Ts, t), (n = A(this, _n)) == null || n.call(this), X(this, _n, t(this.setOnline.bind(this))) } setOnline(t) { A(this, Ss) !== t && (X(this, Ss, t), this.listeners.forEach(r => { r(t) })) } isOnline() { return A(this, Ss) } }, Ss = new WeakMap, _n = new WeakMap, Ts = new WeakMap, Eg), za = new rk; function sk() { let e, t; const n = new Promise((s, i) => { e = s, t = i }); n.status = "pending", n.catch(() => { }); function r(s) { Object.assign(n, s), delete n.resolve, delete n.reject } return n.resolve = s => { r({ status: "fulfilled", value: s }), e(s) }, n.reject = s => { r({ status: "rejected", reason: s }), t(s) }, n } function ik(e) { return Math.min(1e3 * 2 ** e, 3e4) } function fx(e) { return (e ?? "online") === "online" ? za.isOnline() : !0 } var hx = class extends Error { constructor(e) { super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent } }; function gu(e) { return e instanceof hx } function px(e) { let t = !1, n = 0, r = !1, s; const i = sk(), o = y => { var b; r || (f(new hx(y)), (b = e.abort) == null || b.call(e)) }, a = () => { t = !0 }, l = () => { t = !1 }, u = () => dx.isFocused() && (e.networkMode === "always" || za.isOnline()) && e.canRun(), c = () => fx(e.networkMode) && e.canRun(), d = y => { var b; r || (r = !0, (b = e.onSuccess) == null || b.call(e, y), s == null || s(), i.resolve(y)) }, f = y => { var b; r || (r = !0, (b = e.onError) == null || b.call(e, y), s == null || s(), i.reject(y)) }, h = () => new Promise(y => { var b; s = p => { (r || u()) && y(p) }, (b = e.onPause) == null || b.call(e) }).then(() => { var y; s = void 0, r || (y = e.onContinue) == null || y.call(e) }), x = () => { if (r) return; let y; const b = n === 0 ? e.initialPromise : void 0; try { y = b ?? e.fn() } catch (p) { y = Promise.reject(p) } Promise.resolve(y).then(d).catch(p => { var C; if (r) return; const m = e.retry ?? (Tl ? 0 : 3), v = e.retryDelay ?? ik, S = typeof v == "function" ? v(n, p) : v, T = m === !0 || typeof m == "number" && n < m || typeof m == "function" && m(n, p); if (t || !T) { f(p); return } n++, (C = e.onFail) == null || C.call(e, n, p), ZP(S).then(() => u() ? void 0 : h()).then(() => { t ? f(p) : x() }) }) }; return { promise: i, cancel: o, continue: () => (s == null || s(), i), cancelRetry: a, continueRetry: l, canStart: c, start: () => (c() ? x() : h().then(x), i) } } var ok = e => setTimeout(e, 0); function ak() { let e = [], t = 0, n = a => { a() }, r = a => { a() }, s = ok; const i = a => { t ? e.push(a) : s(() => { n(a) }) }, o = () => { const a = e; e = [], a.length && s(() => { r(() => { a.forEach(l => { n(l) }) }) }) }; return { batch: a => { let l; t++; try { l = a() } finally { t--, t || o() } return l }, batchCalls: a => (...l) => { i(() => { a(...l) }) }, schedule: i, setNotifyFunction: a => { n = a }, setBatchNotifyFunction: a => { r = a }, setScheduler: a => { s = a } } } var He = ak(), Er, Pg, mx = (Pg = class { constructor() { te(this, Er) } destroy() { this.clearGcTimeout() } scheduleGc() { this.clearGcTimeout(), QP(this.gcTime) && X(this, Er, setTimeout(() => { this.optionalRemove() }, this.gcTime)) } updateGcTime(e) { this.gcTime = Math.max(this.gcTime || 0, e ?? (Tl ? 1 / 0 : 5 * 60 * 1e3)) } clearGcTimeout() { A(this, Er) && (clearTimeout(A(this, Er)), X(this, Er, void 0)) } }, Er = new WeakMap, Pg), Cs, Pr, yt, kr, _e, Ji, Ar, Lt, un, kg, lk = (kg = class extends mx { constructor(t) { super(); te(this, Lt); te(this, Cs); te(this, Pr); te(this, yt); te(this, kr); te(this, _e); te(this, Ji); te(this, Ar); X(this, Ar, !1), X(this, Ji, t.defaultOptions), this.setOptions(t.options), this.observers = [], X(this, kr, t.client), X(this, yt, A(this, kr).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, X(this, Cs, ck(this.options)), this.state = t.state ?? A(this, Cs), this.scheduleGc() } get meta() { return this.options.meta } get promise() { var t; return (t = A(this, _e)) == null ? void 0 : t.promise } setOptions(t) { this.options = { ...A(this, Ji), ...t }, this.updateGcTime(this.options.gcTime) } optionalRemove() { !this.observers.length && this.state.fetchStatus === "idle" && A(this, yt).remove(this) } setData(t, n) { const r = JP(this.state.data, t, this.options); return Le(this, Lt, un).call(this, { data: r, type: "success", dataUpdatedAt: n == null ? void 0 : n.updatedAt, manual: n == null ? void 0 : n.manual }), r } setState(t, n) { Le(this, Lt, un).call(this, { type: "setState", state: t, setStateOptions: n }) } cancel(t) { var r, s; const n = (r = A(this, _e)) == null ? void 0 : r.promise; return (s = A(this, _e)) == null || s.cancel(t), n ? n.then(Ft).catch(Ft) : Promise.resolve() } destroy() { super.destroy(), this.cancel({ silent: !0 }) } reset() { this.destroy(), this.setState(A(this, Cs)) } isActive() { return this.observers.some(t => qP(t.options.enabled, this) !== !1) } isDisabled() { return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Cf || this.state.dataUpdateCount + this.state.errorUpdateCount === 0 } isStatic() { return this.getObserversCount() > 0 ? this.observers.some(t => Ic(t.options.staleTime, this) === "static") : !1 } isStale() { return this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated } isStaleByTime(t = 0) { return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !YP(this.state.dataUpdatedAt, t) } onFocus() { var n; const t = this.observers.find(r => r.shouldFetchOnWindowFocus()); t == null || t.refetch({ cancelRefetch: !1 }), (n = A(this, _e)) == null || n.continue() } onOnline() { var n; const t = this.observers.find(r => r.shouldFetchOnReconnect()); t == null || t.refetch({ cancelRefetch: !1 }), (n = A(this, _e)) == null || n.continue() } addObserver(t) { this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), A(this, yt).notify({ type: "observerAdded", query: this, observer: t })) } removeObserver(t) { this.observers.includes(t) && (this.observers = this.observers.filter(n => n !== t), this.observers.length || (A(this, _e) && (A(this, Ar) ? A(this, _e).cancel({ revert: !0 }) : A(this, _e).cancelRetry()), this.scheduleGc()), A(this, yt).notify({ type: "observerRemoved", query: this, observer: t })) } getObserversCount() { return this.observers.length } invalidate() { this.state.isInvalidated || Le(this, Lt, un).call(this, { type: "invalidate" }) } fetch(t, n) { var u, c, d; if (this.state.fetchStatus !== "idle") { if (this.state.data !== void 0 && (n != null && n.cancelRefetch)) this.cancel({ silent: !0 }); else if (A(this, _e)) return A(this, _e).continueRetry(), A(this, _e).promise } if (t && this.setOptions(t), !this.options.queryFn) { const f = this.observers.find(h => h.options.queryFn); f && this.setOptions(f.options) } const r = new AbortController, s = f => { Object.defineProperty(f, "signal", { enumerable: !0, get: () => (X(this, Ar, !0), r.signal) }) }, i = () => { const f = cx(this.options, n), x = (() => { const y = { client: A(this, kr), queryKey: this.queryKey, meta: this.meta }; return s(y), y })(); return X(this, Ar, !1), this.options.persister ? this.options.persister(f, x, this) : f(x) }, a = (() => { const f = { fetchOptions: n, options: this.options, queryKey: this.queryKey, client: A(this, kr), state: this.state, fetchFn: i }; return s(f), f })(); (u = this.options.behavior) == null || u.onFetch(a, this), X(this, Pr, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((c = a.fetchOptions) == null ? void 0 : c.meta)) && Le(this, Lt, un).call(this, { type: "fetch", meta: (d = a.fetchOptions) == null ? void 0 : d.meta }); const l = f => { var h, x, y, b; gu(f) && f.silent || Le(this, Lt, un).call(this, { type: "error", error: f }), gu(f) || ((x = (h = A(this, yt).config).onError) == null || x.call(h, f, this), (b = (y = A(this, yt).config).onSettled) == null || b.call(y, this.state.data, f, this)), this.scheduleGc() }; return X(this, _e, px({ initialPromise: n == null ? void 0 : n.initialPromise, fn: a.fetchFn, abort: r.abort.bind(r), onSuccess: f => { var h, x, y, b; if (f === void 0) { l(new Error(`${this.queryHash} data is undefined`)); return } try { this.setData(f) } catch (p) { l(p); return } (x = (h = A(this, yt).config).onSuccess) == null || x.call(h, f, this), (b = (y = A(this, yt).config).onSettled) == null || b.call(y, f, this.state.error, this), this.scheduleGc() }, onError: l, onFail: (f, h) => { Le(this, Lt, un).call(this, { type: "failed", failureCount: f, error: h }) }, onPause: () => { Le(this, Lt, un).call(this, { type: "pause" }) }, onContinue: () => { Le(this, Lt, un).call(this, { type: "continue" }) }, retry: a.options.retry, retryDelay: a.options.retryDelay, networkMode: a.options.networkMode, canRun: () => !0 })), A(this, _e).start() } }, Cs = new WeakMap, Pr = new WeakMap, yt = new WeakMap, kr = new WeakMap, _e = new WeakMap, Ji = new WeakMap, Ar = new WeakMap, Lt = new WeakSet, un = function (t) { const n = r => { switch (t.type) { case "failed": return { ...r, fetchFailureCount: t.failureCount, fetchFailureReason: t.error }; case "pause": return { ...r, fetchStatus: "paused" }; case "continue": return { ...r, fetchStatus: "fetching" }; case "fetch": return { ...r, ...uk(r.data, this.options), fetchMeta: t.meta ?? null }; case "success": return X(this, Pr, void 0), { ...r, data: t.data, dataUpdateCount: r.dataUpdateCount + 1, dataUpdatedAt: t.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!t.manual && { fetchStatus: "idle", fetchFailureCount: 0, fetchFailureReason: null } }; case "error": const s = t.error; return gu(s) && s.revert && A(this, Pr) ? { ...A(this, Pr), fetchStatus: "idle" } : { ...r, error: s, errorUpdateCount: r.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: r.fetchFailureCount + 1, fetchFailureReason: s, fetchStatus: "idle", status: "error" }; case "invalidate": return { ...r, isInvalidated: !0 }; case "setState": return { ...r, ...t.state } } }; this.state = n(this.state), He.batch(() => { this.observers.forEach(r => { r.onQueryUpdate() }), A(this, yt).notify({ query: this, type: "updated", action: t }) }) }, kg); function uk(e, t) { return { fetchFailureCount: 0, fetchFailureReason: null, fetchStatus: fx(t.networkMode) ? "fetching" : "paused", ...e === void 0 && { error: null, status: "pending" } } } function ck(e) { const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, n = t !== void 0, r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0; return { data: t, dataUpdateCount: 0, dataUpdatedAt: n ? r ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: null, isInvalidated: !1, status: n ? "success" : "pending", fetchStatus: "idle" } } var Qt, Ag, dk = (Ag = class extends Sl { constructor(t = {}) { super(); te(this, Qt); this.config = t, X(this, Qt, new Map) } build(t, n, r) { const s = n.queryKey, i = n.queryHash ?? Tf(s, n); let o = this.get(i); return o || (o = new lk({ client: t, queryKey: s, queryHash: i, options: t.defaultQueryOptions(n), state: r, defaultOptions: t.getQueryDefaults(s) }), this.add(o)), o } add(t) { A(this, Qt).has(t.queryHash) || (A(this, Qt).set(t.queryHash, t), this.notify({ type: "added", query: t })) } remove(t) { const n = A(this, Qt).get(t.queryHash); n && (t.destroy(), n === t && A(this, Qt).delete(t.queryHash), this.notify({ type: "removed", query: t })) } clear() { He.batch(() => { this.getAll().forEach(t => { this.remove(t) }) }) } get(t) { return A(this, Qt).get(t) } getAll() { return [...A(this, Qt).values()] } find(t) { const n = { exact: !0, ...t }; return this.getAll().find(r => Up(n, r)) } findAll(t = {}) { const n = this.getAll(); return Object.keys(t).length > 0 ? n.filter(r => Up(t, r)) : n } notify(t) { He.batch(() => { this.listeners.forEach(n => { n(t) }) }) } onFocus() { He.batch(() => { this.getAll().forEach(t => { t.onFocus() }) }) } onOnline() { He.batch(() => { this.getAll().forEach(t => { t.onOnline() }) }) } }, Qt = new WeakMap, Ag), Yt, Ue, Rr, qt, jn, Rg, fk = (Rg = class extends mx { constructor(t) { super(); te(this, qt); te(this, Yt); te(this, Ue); te(this, Rr); this.mutationId = t.mutationId, X(this, Ue, t.mutationCache), X(this, Yt, []), this.state = t.state || hk(), this.setOptions(t.options), this.scheduleGc() } setOptions(t) { this.options = t, this.updateGcTime(this.options.gcTime) } get meta() { return this.options.meta } addObserver(t) { A(this, Yt).includes(t) || (A(this, Yt).push(t), this.clearGcTimeout(), A(this, Ue).notify({ type: "observerAdded", mutation: this, observer: t })) } removeObserver(t) { X(this, Yt, A(this, Yt).filter(n => n !== t)), this.scheduleGc(), A(this, Ue).notify({ type: "observerRemoved", mutation: this, observer: t }) } optionalRemove() { A(this, Yt).length || (this.state.status === "pending" ? this.scheduleGc() : A(this, Ue).remove(this)) } continue() { var t; return ((t = A(this, Rr)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables) } async execute(t) { var i, o, a, l, u, c, d, f, h, x, y, b, p, m, v, S, T, C, E, P; const n = () => { Le(this, qt, jn).call(this, { type: "continue" }) }; X(this, Rr, px({ fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")), onFail: (N, j) => { Le(this, qt, jn).call(this, { type: "failed", failureCount: N, error: j }) }, onPause: () => { Le(this, qt, jn).call(this, { type: "pause" }) }, onContinue: n, retry: this.options.retry ?? 0, retryDelay: this.options.retryDelay, networkMode: this.options.networkMode, canRun: () => A(this, Ue).canRun(this) })); const r = this.state.status === "pending", s = !A(this, Rr).canStart(); try { if (r) n(); else { Le(this, qt, jn).call(this, { type: "pending", variables: t, isPaused: s }), await ((o = (i = A(this, Ue).config).onMutate) == null ? void 0 : o.call(i, t, this)); const j = await ((l = (a = this.options).onMutate) == null ? void 0 : l.call(a, t)); j !== this.state.context && Le(this, qt, jn).call(this, { type: "pending", context: j, variables: t, isPaused: s }) } const N = await A(this, Rr).start(); return await ((c = (u = A(this, Ue).config).onSuccess) == null ? void 0 : c.call(u, N, t, this.state.context, this)), await ((f = (d = this.options).onSuccess) == null ? void 0 : f.call(d, N, t, this.state.context)), await ((x = (h = A(this, Ue).config).onSettled) == null ? void 0 : x.call(h, N, null, this.state.variables, this.state.context, this)), await ((b = (y = this.options).onSettled) == null ? void 0 : b.call(y, N, null, t, this.state.context)), Le(this, qt, jn).call(this, { type: "success", data: N }), N } catch (N) { try { throw await ((m = (p = A(this, Ue).config).onError) == null ? void 0 : m.call(p, N, t, this.state.context, this)), await ((S = (v = this.options).onError) == null ? void 0 : S.call(v, N, t, this.state.context)), await ((C = (T = A(this, Ue).config).onSettled) == null ? void 0 : C.call(T, void 0, N, this.state.variables, this.state.context, this)), await ((P = (E = this.options).onSettled) == null ? void 0 : P.call(E, void 0, N, t, this.state.context)), N } finally { Le(this, qt, jn).call(this, { type: "error", error: N }) } } finally { A(this, Ue).runNext(this) } } }, Yt = new WeakMap, Ue = new WeakMap, Rr = new WeakMap, qt = new WeakSet, jn = function (t) { const n = r => { switch (t.type) { case "failed": return { ...r, failureCount: t.failureCount, failureReason: t.error }; case "pause": return { ...r, isPaused: !0 }; case "continue": return { ...r, isPaused: !1 }; case "pending": return { ...r, context: t.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: t.isPaused, status: "pending", variables: t.variables, submittedAt: Date.now() }; case "success": return { ...r, data: t.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1 }; case "error": return { ...r, data: void 0, error: t.error, failureCount: r.failureCount + 1, failureReason: t.error, isPaused: !1, status: "error" } } }; this.state = n(this.state), He.batch(() => { A(this, Yt).forEach(r => { r.onMutationUpdate(t) }), A(this, Ue).notify({ mutation: this, type: "updated", action: t }) }) }, Rg); function hk() { return { context: void 0, data: void 0, error: null, failureCount: 0, failureReason: null, isPaused: !1, status: "idle", variables: void 0, submittedAt: 0 } } var hn, It, eo, Ng, pk = (Ng = class extends Sl { constructor(t = {}) { super(); te(this, hn); te(this, It); te(this, eo); this.config = t, X(this, hn, new Set), X(this, It, new Map), X(this, eo, 0) } build(t, n, r) { const s = new fk({ mutationCache: this, mutationId: ++vo(this, eo)._, options: t.defaultMutationOptions(n), state: r }); return this.add(s), s } add(t) { A(this, hn).add(t); const n = zo(t); if (typeof n == "string") { const r = A(this, It).get(n); r ? r.push(t) : A(this, It).set(n, [t]) } this.notify({ type: "added", mutation: t }) } remove(t) { if (A(this, hn).delete(t)) { const n = zo(t); if (typeof n == "string") { const r = A(this, It).get(n); if (r) if (r.length > 1) { const s = r.indexOf(t); s !== -1 && r.splice(s, 1) } else r[0] === t && A(this, It).delete(n) } } this.notify({ type: "removed", mutation: t }) } canRun(t) { const n = zo(t); if (typeof n == "string") { const r = A(this, It).get(n), s = r == null ? void 0 : r.find(i => i.state.status === "pending"); return !s || s === t } else return !0 } runNext(t) { var r; const n = zo(t); if (typeof n == "string") { const s = (r = A(this, It).get(n)) == null ? void 0 : r.find(i => i !== t && i.state.isPaused); return (s == null ? void 0 : s.continue()) ?? Promise.resolve() } else return Promise.resolve() } clear() { He.batch(() => { A(this, hn).forEach(t => { this.notify({ type: "removed", mutation: t }) }), A(this, hn).clear(), A(this, It).clear() }) } getAll() { return Array.from(A(this, hn)) } find(t) { const n = { exact: !0, ...t }; return this.getAll().find(r => Wp(n, r)) } findAll(t = {}) { return this.getAll().filter(n => Wp(t, n)) } notify(t) { He.batch(() => { this.listeners.forEach(n => { n(t) }) }) } resumePausedMutations() { const t = this.getAll().filter(n => n.state.isPaused); return He.batch(() => Promise.all(t.map(n => n.continue().catch(Ft)))) } }, hn = new WeakMap, It = new WeakMap, eo = new WeakMap, Ng); function zo(e) { var t; return (t = e.options.scope) == null ? void 0 : t.id } function Gp(e) { return { onFetch: (t, n) => { var c, d, f, h, x; const r = t.options, s = (f = (d = (c = t.fetchOptions) == null ? void 0 : c.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : f.direction, i = ((h = t.state.data) == null ? void 0 : h.pages) || [], o = ((x = t.state.data) == null ? void 0 : x.pageParams) || []; let a = { pages: [], pageParams: [] }, l = 0; const u = async () => { let y = !1; const b = v => { Object.defineProperty(v, "signal", { enumerable: !0, get: () => (t.signal.aborted ? y = !0 : t.signal.addEventListener("abort", () => { y = !0 }), t.signal) }) }, p = cx(t.options, t.fetchOptions), m = async (v, S, T) => { if (y) return Promise.reject(); if (S == null && v.pages.length) return Promise.resolve(v); const E = (() => { const z = { client: t.client, queryKey: t.queryKey, pageParam: S, direction: T ? "backward" : "forward", meta: t.options.meta }; return b(z), z })(), P = await p(E), { maxPages: N } = t.options, j = T ? tk : ek; return { pages: j(v.pages, P, N), pageParams: j(v.pageParams, S, N) } }; if (s && i.length) { const v = s === "backward", S = v ? mk : Xp, T = { pages: i, pageParams: o }, C = S(r, T); a = await m(T, C, v) } else { const v = e ?? i.length; do { const S = l === 0 ? o[0] ?? r.initialPageParam : Xp(r, a); if (l > 0 && S == null) break; a = await m(a, S), l++ } while (l < v) } return a }; t.options.persister ? t.fetchFn = () => { var y, b; return (b = (y = t.options).persister) == null ? void 0 : b.call(y, u, { client: t.client, queryKey: t.queryKey, meta: t.options.meta, signal: t.signal }, n) } : t.fetchFn = u } } } function Xp(e, { pages: t, pageParams: n }) { const r = t.length - 1; return t.length > 0 ? e.getNextPageParam(t[r], t, n[r], n) : void 0 } function mk(e, { pages: t, pageParams: n }) { var r; return t.length > 0 ? (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n) : void 0 } var xe, zn, Bn, Es, Ps, $n, ks, As, jg, gk = (jg = class { constructor(e = {}) { te(this, xe); te(this, zn); te(this, Bn); te(this, Es); te(this, Ps); te(this, $n); te(this, ks); te(this, As); X(this, xe, e.queryCache || new dk), X(this, zn, e.mutationCache || new pk), X(this, Bn, e.defaultOptions || {}), X(this, Es, new Map), X(this, Ps, new Map), X(this, $n, 0) } mount() { vo(this, $n)._++, A(this, $n) === 1 && (X(this, ks, dx.subscribe(async e => { e && (await this.resumePausedMutations(), A(this, xe).onFocus()) })), X(this, As, za.subscribe(async e => { e && (await this.resumePausedMutations(), A(this, xe).onOnline()) }))) } unmount() { var e, t; vo(this, $n)._--, A(this, $n) === 0 && ((e = A(this, ks)) == null || e.call(this), X(this, ks, void 0), (t = A(this, As)) == null || t.call(this), X(this, As, void 0)) } isFetching(e) { return A(this, xe).findAll({ ...e, fetchStatus: "fetching" }).length } isMutating(e) { return A(this, zn).findAll({ ...e, status: "pending" }).length } getQueryData(e) { var n; const t = this.defaultQueryOptions({ queryKey: e }); return (n = A(this, xe).get(t.queryHash)) == null ? void 0 : n.state.data } ensureQueryData(e) { const t = this.defaultQueryOptions(e), n = A(this, xe).build(this, t), r = n.state.data; return r === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && n.isStaleByTime(Ic(t.staleTime, n)) && this.prefetchQuery(t), Promise.resolve(r)) } getQueriesData(e) { return A(this, xe).findAll(e).map(({ queryKey: t, state: n }) => { const r = n.data; return [t, r] }) } setQueryData(e, t, n) { const r = this.defaultQueryOptions({ queryKey: e }), s = A(this, xe).get(r.queryHash), i = s == null ? void 0 : s.state.data, o = XP(t, i); if (o !== void 0) return A(this, xe).build(this, r).setData(o, { ...n, manual: !0 }) } setQueriesData(e, t, n) { return He.batch(() => A(this, xe).findAll(e).map(({ queryKey: r }) => [r, this.setQueryData(r, t, n)])) } getQueryState(e) { var n; const t = this.defaultQueryOptions({ queryKey: e }); return (n = A(this, xe).get(t.queryHash)) == null ? void 0 : n.state } removeQueries(e) { const t = A(this, xe); He.batch(() => { t.findAll(e).forEach(n => { t.remove(n) }) }) } resetQueries(e, t) { const n = A(this, xe); return He.batch(() => (n.findAll(e).forEach(r => { r.reset() }), this.refetchQueries({ type: "active", ...e }, t))) } cancelQueries(e, t = {}) { const n = { revert: !0, ...t }, r = He.batch(() => A(this, xe).findAll(e).map(s => s.cancel(n))); return Promise.all(r).then(Ft).catch(Ft) } invalidateQueries(e, t = {}) { return He.batch(() => (A(this, xe).findAll(e).forEach(n => { n.invalidate() }), (e == null ? void 0 : e.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({ ...e, type: (e == null ? void 0 : e.refetchType) ?? (e == null ? void 0 : e.type) ?? "active" }, t))) } refetchQueries(e, t = {}) { const n = { ...t, cancelRefetch: t.cancelRefetch ?? !0 }, r = He.batch(() => A(this, xe).findAll(e).filter(s => !s.isDisabled() && !s.isStatic()).map(s => { let i = s.fetch(void 0, n); return n.throwOnError || (i = i.catch(Ft)), s.state.fetchStatus === "paused" ? Promise.resolve() : i })); return Promise.all(r).then(Ft) } fetchQuery(e) { const t = this.defaultQueryOptions(e); t.retry === void 0 && (t.retry = !1); const n = A(this, xe).build(this, t); return n.isStaleByTime(Ic(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data) } prefetchQuery(e) { return this.fetchQuery(e).then(Ft).catch(Ft) } fetchInfiniteQuery(e) { return e.behavior = Gp(e.pages), this.fetchQuery(e) } prefetchInfiniteQuery(e) { return this.fetchInfiniteQuery(e).then(Ft).catch(Ft) } ensureInfiniteQueryData(e) { return e.behavior = Gp(e.pages), this.ensureQueryData(e) } resumePausedMutations() { return za.isOnline() ? A(this, zn).resumePausedMutations() : Promise.resolve() } getQueryCache() { return A(this, xe) } getMutationCache() { return A(this, zn) } getDefaultOptions() { return A(this, Bn) } setDefaultOptions(e) { X(this, Bn, e) } setQueryDefaults(e, t) { A(this, Es).set(Ki(e), { queryKey: e, defaultOptions: t }) } getQueryDefaults(e) { const t = [...A(this, Es).values()], n = {}; return t.forEach(r => { Gi(e, r.queryKey) && Object.assign(n, r.defaultOptions) }), n } setMutationDefaults(e, t) { A(this, Ps).set(Ki(e), { mutationKey: e, defaultOptions: t }) } getMutationDefaults(e) { const t = [...A(this, Ps).values()], n = {}; return t.forEach(r => { Gi(e, r.mutationKey) && Object.assign(n, r.defaultOptions) }), n } defaultQueryOptions(e) { if (e._defaulted) return e; const t = { ...A(this, Bn).queries, ...this.getQueryDefaults(e.queryKey), ...e, _defaulted: !0 }; return t.queryHash || (t.queryHash = Tf(t.queryKey, t)), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === Cf && (t.enabled = !1), t } defaultMutationOptions(e) { return e != null && e._defaulted ? e : { ...A(this, Bn).mutations, ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey), ...e, _defaulted: !0 } } clear() { A(this, xe).clear(), A(this, zn).clear() } }, xe = new WeakMap, zn = new WeakMap, Bn = new WeakMap, Es = new WeakMap, Ps = new WeakMap, $n = new WeakMap, ks = new WeakMap, As = new WeakMap, jg), yk = w.createContext(void 0), vk = ({ client: e, children: t }) => (w.useEffect(() => (e.mount(), () => { e.unmount() }), [e]), g.jsx(yk.Provider, { value: e, children: t }));/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Ba() { return Ba = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Ba.apply(this, arguments) } var Hn; (function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" })(Hn || (Hn = {})); const Qp = "popstate"; function xk(e) { e === void 0 && (e = {}); function t(r, s) { let { pathname: i, search: o, hash: a } = r.location; return _c("", { pathname: i, search: o, hash: a }, s.state && s.state.usr || null, s.state && s.state.key || "default") } function n(r, s) { return typeof s == "string" ? s : yx(s) } return bk(t, n, null, e) } function st(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function gx(e, t) { if (!e) { typeof console < "u" && console.warn(t); try { throw new Error(t) } catch { } } } function wk() { return Math.random().toString(36).substr(2, 8) } function Yp(e, t) { return { usr: e.state, key: e.key, idx: t } } function _c(e, t, n, r) { return n === void 0 && (n = null), Ba({ pathname: typeof e == "string" ? e : e.pathname, search: "", hash: "" }, typeof t == "string" ? Cl(t) : t, { state: n, key: t && t.key || r || wk() }) } function yx(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t } function Cl(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } function bk(e, t, n, r) { r === void 0 && (r = {}); let { window: s = document.defaultView, v5Compat: i = !1 } = r, o = s.history, a = Hn.Pop, l = null, u = c(); u == null && (u = 0, o.replaceState(Ba({}, o.state, { idx: u }), "")); function c() { return (o.state || { idx: null }).idx } function d() { a = Hn.Pop; let b = c(), p = b == null ? null : b - u; u = b, l && l({ action: a, location: y.location, delta: p }) } function f(b, p) { a = Hn.Push; let m = _c(y.location, b, p); u = c() + 1; let v = Yp(m, u), S = y.createHref(m); try { o.pushState(v, "", S) } catch (T) { if (T instanceof DOMException && T.name === "DataCloneError") throw T; s.location.assign(S) } i && l && l({ action: a, location: y.location, delta: 1 }) } function h(b, p) { a = Hn.Replace; let m = _c(y.location, b, p); u = c(); let v = Yp(m, u), S = y.createHref(m); o.replaceState(v, "", S), i && l && l({ action: a, location: y.location, delta: 0 }) } function x(b) { let p = s.location.origin !== "null" ? s.location.origin : s.location.href, m = typeof b == "string" ? b : yx(b); return m = m.replace(/ $/, "%20"), st(p, "No window.location.(origin|href) available to create URL for href: " + m), new URL(m, p) } let y = { get action() { return a }, get location() { return e(s, o) }, listen(b) { if (l) throw new Error("A history only accepts one active listener"); return s.addEventListener(Qp, d), l = b, () => { s.removeEventListener(Qp, d), l = null } }, createHref(b) { return t(s, b) }, createURL: x, encodeLocation(b) { let p = x(b); return { pathname: p.pathname, search: p.search, hash: p.hash } }, push: f, replace: h, go(b) { return o.go(b) } }; return y } var qp; (function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" })(qp || (qp = {})); function Sk(e, t, n) { return n === void 0 && (n = "/"), Tk(e, t, n, !1) } function Tk(e, t, n, r) { let s = typeof t == "string" ? Cl(t) : t, i = wx(s.pathname || "/", n); if (i == null) return null; let o = vx(e); Ck(o); let a = null; for (let l = 0; a == null && l < o.length; ++l) { let u = Fk(i); a = Dk(o[l], u, r) } return a } function vx(e, t, n, r) { t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = ""); let s = (i, o, a) => { let l = { relativePath: a === void 0 ? i.path || "" : a, caseSensitive: i.caseSensitive === !0, childrenIndex: o, route: i }; l.relativePath.startsWith("/") && (st(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(r.length)); let u = xs([r, l.relativePath]), c = n.concat(l); i.children && i.children.length > 0 && (st(i.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')), vx(i.children, t, c, u)), !(i.path == null && !i.index) && t.push({ path: u, score: jk(u, i.index), routesMeta: c }) }; return e.forEach((i, o) => { var a; if (i.path === "" || !((a = i.path) != null && a.includes("?"))) s(i, o); else for (let l of xx(i.path)) s(i, o, l) }), t } function xx(e) { let t = e.split("/"); if (t.length === 0) return []; let [n, ...r] = t, s = n.endsWith("?"), i = n.replace(/\?$/, ""); if (r.length === 0) return s ? [i, ""] : [i]; let o = xx(r.join("/")), a = []; return a.push(...o.map(l => l === "" ? i : [i, l].join("/"))), s && a.push(...o), a.map(l => e.startsWith("/") && l === "" ? "/" : l) } function Ck(e) { e.sort((t, n) => t.score !== n.score ? n.score - t.score : Mk(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } const Ek = /^:[\w-]+$/, Pk = 3, kk = 2, Ak = 1, Rk = 10, Nk = -2, Zp = e => e === "*"; function jk(e, t) { let n = e.split("/"), r = n.length; return n.some(Zp) && (r += Nk), t && (r += kk), n.filter(s => !Zp(s)).reduce((s, i) => s + (Ek.test(i) ? Pk : i === "" ? Ak : Rk), r) } function Mk(e, t) { return e.length === t.length && e.slice(0, -1).every((r, s) => r === t[s]) ? e[e.length - 1] - t[t.length - 1] : 0 } function Dk(e, t, n) { let { routesMeta: r } = e, s = {}, i = "/", o = []; for (let a = 0; a < r.length; ++a) { let l = r[a], u = a === r.length - 1, c = i === "/" ? t : t.slice(i.length) || "/", d = Jp({ path: l.relativePath, caseSensitive: l.caseSensitive, end: u }, c), f = l.route; if (!d && u && n && !r[r.length - 1].route.index && (d = Jp({ path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 }, c)), !d) return null; Object.assign(s, d.params), o.push({ params: s, pathname: xs([i, d.pathname]), pathnameBase: Lk(xs([i, d.pathnameBase])), route: f }), d.pathnameBase !== "/" && (i = xs([i, d.pathnameBase])) } return o } function Jp(e, t) { typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = Ok(e.path, e.caseSensitive, e.end), s = t.match(n); if (!s) return null; let i = s[0], o = i.replace(/(.)\/+$/, "$1"), a = s.slice(1); return { params: r.reduce((u, c, d) => { let { paramName: f, isOptional: h } = c; if (f === "*") { let y = a[d] || ""; o = i.slice(0, i.length - y.length).replace(/(.)\/+$/, "$1") } const x = a[d]; return h && !x ? u[f] = void 0 : u[f] = (x || "").replace(/%2F/g, "/"), u }, {}), pathname: i, pathnameBase: o, pattern: e } } function Ok(e, t, n) { t === void 0 && (t = !1), n === void 0 && (n = !0), gx(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".')); let r = [], s = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (r.push({ paramName: a, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (r.push({ paramName: "*" }), s += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? s += "\\/*$" : e !== "" && e !== "/" && (s += "(?:(?=\\/|$))"), [new RegExp(s, t ? void 0 : "i"), r] } function Fk(e) { try { return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/") } catch (t) { return gx(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e } } function wx(e, t) { if (t === "/") return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && r !== "/" ? null : e.slice(n) || "/" } const xs = e => e.join("/").replace(/\/\/+/g, "/"), Lk = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"); function Ik(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e } const bx = ["post", "put", "patch", "delete"]; new Set(bx); const Vk = ["get", ...bx]; new Set(Vk);/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function $a() { return $a = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, $a.apply(this, arguments) } const _k = w.createContext(null), zk = w.createContext(null), Sx = w.createContext(null), El = w.createContext(null), Pl = w.createContext({ outlet: null, matches: [], isDataRoute: !1 }), Tx = w.createContext(null); function Ef() { return w.useContext(El) != null } function Cx() { return Ef() || st(!1), w.useContext(El).location } function Bk(e, t) { return $k(e, t) } function $k(e, t, n, r) { Ef() || st(!1); let { navigator: s } = w.useContext(Sx), { matches: i } = w.useContext(Pl), o = i[i.length - 1], a = o ? o.params : {}; o && o.pathname; let l = o ? o.pathnameBase : "/"; o && o.route; let u = Cx(), c; if (t) { var d; let b = typeof t == "string" ? Cl(t) : t; l === "/" || (d = b.pathname) != null && d.startsWith(l) || st(!1), c = b } else c = u; let f = c.pathname || "/", h = f; if (l !== "/") { let b = l.replace(/^\//, "").split("/"); h = "/" + f.replace(/^\//, "").split("/").slice(b.length).join("/") } let x = Sk(e, { pathname: h }), y = Gk(x && x.map(b => Object.assign({}, b, { params: Object.assign({}, a, b.params), pathname: xs([l, s.encodeLocation ? s.encodeLocation(b.pathname).pathname : b.pathname]), pathnameBase: b.pathnameBase === "/" ? l : xs([l, s.encodeLocation ? s.encodeLocation(b.pathnameBase).pathname : b.pathnameBase]) })), i, n, r); return t && y ? w.createElement(El.Provider, { value: { location: $a({ pathname: "/", search: "", hash: "", state: null, key: "default" }, c), navigationType: Hn.Pop } }, y) : y } function Uk() { let e = qk(), t = Ik(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, s = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return w.createElement(w.Fragment, null, w.createElement("h2", null, "Unexpected Application Error!"), w.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? w.createElement("pre", { style: s }, n) : null, null) } const Wk = w.createElement(Uk, null); class Hk extends w.Component { constructor(t) { super(t), this.state = { location: t.location, revalidation: t.revalidation, error: t.error } } static getDerivedStateFromError(t) { return { error: t } } static getDerivedStateFromProps(t, n) { return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? { error: t.error, location: t.location, revalidation: t.revalidation } : { error: t.error !== void 0 ? t.error : n.error, location: n.location, revalidation: t.revalidation || n.revalidation } } componentDidCatch(t, n) { console.error("React Router caught the following error during render", t, n) } render() { return this.state.error !== void 0 ? w.createElement(Pl.Provider, { value: this.props.routeContext }, w.createElement(Tx.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function Kk(e) { let { routeContext: t, match: n, children: r } = e, s = w.useContext(_k); return s && s.static && s.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = n.route.id), w.createElement(Pl.Provider, { value: t }, r) } function Gk(e, t, n, r) { var s; if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) { var i; if (!n) return null; if (n.errors) e = n.matches; else if ((i = r) != null && i.v7_partialHydration && t.length === 0 && !n.initialized && n.matches.length > 0) e = n.matches; else return null } let o = e, a = (s = n) == null ? void 0 : s.errors; if (a != null) { let c = o.findIndex(d => d.route.id && (a == null ? void 0 : a[d.route.id]) !== void 0); c >= 0 || st(!1), o = o.slice(0, Math.min(o.length, c + 1)) } let l = !1, u = -1; if (n && r && r.v7_partialHydration) for (let c = 0; c < o.length; c++) { let d = o[c]; if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (u = c), d.route.id) { let { loaderData: f, errors: h } = n, x = d.route.loader && f[d.route.id] === void 0 && (!h || h[d.route.id] === void 0); if (d.route.lazy || x) { l = !0, u >= 0 ? o = o.slice(0, u + 1) : o = [o[0]]; break } } } return o.reduceRight((c, d, f) => { let h, x = !1, y = null, b = null; n && (h = a && d.route.id ? a[d.route.id] : void 0, y = d.route.errorElement || Wk, l && (u < 0 && f === 0 ? (x = !0, b = null) : u === f && (x = !0, b = d.route.hydrateFallbackElement || null))); let p = t.concat(o.slice(0, f + 1)), m = () => { let v; return h ? v = y : x ? v = b : d.route.Component ? v = w.createElement(d.route.Component, null) : d.route.element ? v = d.route.element : v = c, w.createElement(Kk, { match: d, routeContext: { outlet: c, matches: p, isDataRoute: n != null }, children: v }) }; return n && (d.route.ErrorBoundary || d.route.errorElement || f === 0) ? w.createElement(Hk, { location: n.location, revalidation: n.revalidation, component: y, error: h, children: m(), routeContext: { outlet: null, matches: p, isDataRoute: !0 } }) : m() }, null) } var zc = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(zc || {}); function Xk(e) { let t = w.useContext(zk); return t || st(!1), t } function Qk(e) { let t = w.useContext(Pl); return t || st(!1), t } function Yk(e) { let t = Qk(), n = t.matches[t.matches.length - 1]; return n.route.id || st(!1), n.route.id } function qk() { var e; let t = w.useContext(Tx), n = Xk(zc.UseRouteError), r = Yk(zc.UseRouteError); return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r] } function Zk(e, t) { e == null || e.v7_startTransition, e == null || e.v7_relativeSplatPath } function Bc(e) { st(!1) } function Jk(e) { let { basename: t = "/", children: n = null, location: r, navigationType: s = Hn.Pop, navigator: i, static: o = !1, future: a } = e; Ef() && st(!1); let l = t.replace(/^\/*/, "/"), u = w.useMemo(() => ({ basename: l, navigator: i, static: o, future: $a({ v7_relativeSplatPath: !1 }, a) }), [l, a, i, o]); typeof r == "string" && (r = Cl(r)); let { pathname: c = "/", search: d = "", hash: f = "", state: h = null, key: x = "default" } = r, y = w.useMemo(() => { let b = wx(c, l); return b == null ? null : { location: { pathname: b, search: d, hash: f, state: h, key: x }, navigationType: s } }, [l, c, d, f, h, x, s]); return y == null ? null : w.createElement(Sx.Provider, { value: u }, w.createElement(El.Provider, { children: n, value: y })) } function e2(e) { let { children: t, location: n } = e; return Bk($c(t), n) } new Promise(() => { }); function $c(e, t) { t === void 0 && (t = []); let n = []; return w.Children.forEach(e, (r, s) => { if (!w.isValidElement(r)) return; let i = [...t, s]; if (r.type === w.Fragment) { n.push.apply(n, $c(r.props.children, i)); return } r.type !== Bc && st(!1), !r.props.index || !r.props.children || st(!1); let o = { id: r.props.id || i.join("-"), caseSensitive: r.props.caseSensitive, element: r.props.element, Component: r.props.Component, index: r.props.index, path: r.props.path, loader: r.props.loader, action: r.props.action, errorElement: r.props.errorElement, ErrorBoundary: r.props.ErrorBoundary, hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null, shouldRevalidate: r.props.shouldRevalidate, handle: r.props.handle, lazy: r.props.lazy }; r.props.children && (o.children = $c(r.props.children, i)), n.push(o) }), n }/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */const t2 = "6"; try { window.__reactRouterVersion = t2 } catch { } const n2 = "startTransition", em = Ug[n2]; function r2(e) { let { basename: t, children: n, future: r, window: s } = e, i = w.useRef(); i.current == null && (i.current = xk({ window: s, v5Compat: !0 })); let o = i.current, [a, l] = w.useState({ action: o.action, location: o.location }), { v7_startTransition: u } = r || {}, c = w.useCallback(d => { u && em ? em(() => l(d)) : l(d) }, [l, u]); return w.useLayoutEffect(() => o.listen(c), [o, c]), w.useEffect(() => Zk(r), [r]), w.createElement(Jk, { basename: t, children: n, location: a.location, navigationType: a.action, navigator: o, future: r }) } var tm; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(tm || (tm = {})); var nm; (function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" })(nm || (nm = {})); const Pf = w.createContext({}); function kf(e) { const t = w.useRef(null); return t.current === null && (t.current = e()), t.current } const Ex = typeof window < "u", Px = Ex ? w.useLayoutEffect : w.useEffect, kl = w.createContext(null); function Af(e, t) { e.indexOf(t) === -1 && e.push(t) } function Ua(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } const on = (e, t, n) => n > t ? t : n < e ? e : n; let Al = () => { }, Vs = () => { }; const Tn = {}, kx = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e); function Ax(e) { return typeof e == "object" && e !== null } const Rx = e => /^0[^.\s]+$/u.test(e); function Rf(e) { let t; return () => (t === void 0 && (t = e()), t) } const Tt = e => e, s2 = (e, t) => n => t(e(n)), uo = (...e) => e.reduce(s2), Xi = (e, t, n) => { const r = t - e; return r === 0 ? 1 : (n - e) / r }; class Nf { constructor() { this.subscriptions = [] } add(t) { return Af(this.subscriptions, t), () => Ua(this.subscriptions, t) } notify(t, n, r) { const s = this.subscriptions.length; if (s) if (s === 1) this.subscriptions[0](t, n, r); else for (let i = 0; i < s; i++) { const o = this.subscriptions[i]; o && o(t, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Ct = e => e * 1e3, bt = e => e / 1e3; function Nx(e, t) { return t ? e * (1e3 / t) : 0 } const jx = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, i2 = 1e-7, o2 = 12; function a2(e, t, n, r, s) { let i, o, a = 0; do o = t + (n - t) / 2, i = jx(o, r, s) - e, i > 0 ? n = o : t = o; while (Math.abs(i) > i2 && ++a < o2); return o } function co(e, t, n, r) { if (e === t && n === r) return Tt; const s = i => a2(i, 0, 1, e, n); return i => i === 0 || i === 1 ? i : jx(s(i), t, r) } const Mx = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, Dx = e => t => 1 - e(1 - t), Ox = co(.33, 1.53, .69, .99), jf = Dx(Ox), Fx = Mx(jf), Lx = e => (e *= 2) < 1 ? .5 * jf(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), Mf = e => 1 - Math.sin(Math.acos(e)), Ix = Dx(Mf), Vx = Mx(Mf), l2 = co(.42, 0, 1, 1), u2 = co(0, 0, .58, 1), _x = co(.42, 0, .58, 1), c2 = e => Array.isArray(e) && typeof e[0] != "number", zx = e => Array.isArray(e) && typeof e[0] == "number", rm = { linear: Tt, easeIn: l2, easeInOut: _x, easeOut: u2, circIn: Mf, circInOut: Vx, circOut: Ix, backIn: jf, backInOut: Fx, backOut: Ox, anticipate: Lx }, d2 = e => typeof e == "string", sm = e => { if (zx(e)) { Vs(e.length === 4, "Cubic bezier arrays must contain four numerical values.", "cubic-bezier-length"); const [t, n, r, s] = e; return co(t, n, r, s) } else if (d2(e)) return Vs(rm[e] !== void 0, `Invalid easing type '${e}'`, "invalid-easing-type"), rm[e]; return e }, Bo = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"], im = { value: null, addProjectionMetrics: null }; function f2(e, t) { let n = new Set, r = new Set, s = !1, i = !1; const o = new WeakSet; let a = { delta: 0, timestamp: 0, isProcessing: !1 }, l = 0; function u(d) { o.has(d) && (c.schedule(d), e()), l++, d(a) } const c = { schedule: (d, f = !1, h = !1) => { const y = h && s ? n : r; return f && o.add(d), y.has(d) || y.add(d), d }, cancel: d => { r.delete(d), o.delete(d) }, process: d => { if (a = d, s) { i = !0; return } s = !0, [n, r] = [r, n], n.forEach(u), t && im.value && im.value.frameloop[t].push(l), l = 0, n.clear(), s = !1, i && (i = !1, c.process(d)) } }; return c } const h2 = 40; function Bx(e, t) { let n = !1, r = !0; const s = { delta: 0, timestamp: 0, isProcessing: !1 }, i = () => n = !0, o = Bo.reduce((v, S) => (v[S] = f2(i, t ? S : void 0), v), {}), { setup: a, read: l, resolveKeyframes: u, preUpdate: c, update: d, preRender: f, render: h, postRender: x } = o, y = () => { const v = Tn.useManualTiming ? s.timestamp : performance.now(); n = !1, Tn.useManualTiming || (s.delta = r ? 1e3 / 60 : Math.max(Math.min(v - s.timestamp, h2), 1)), s.timestamp = v, s.isProcessing = !0, a.process(s), l.process(s), u.process(s), c.process(s), d.process(s), f.process(s), h.process(s), x.process(s), s.isProcessing = !1, n && t && (r = !1, e(y)) }, b = () => { n = !0, r = !0, s.isProcessing || e(y) }; return { schedule: Bo.reduce((v, S) => { const T = o[S]; return v[S] = (C, E = !1, P = !1) => (n || b(), T.schedule(C, E, P)), v }, {}), cancel: v => { for (let S = 0; S < Bo.length; S++)o[Bo[S]].cancel(v) }, state: s, steps: o } } const { schedule: oe, cancel: ar, state: De, steps: yu } = Bx(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Tt, !0); let oa; function p2() { oa = void 0 } const Ke = { now: () => (oa === void 0 && Ke.set(De.isProcessing || Tn.useManualTiming ? De.timestamp : performance.now()), oa), set: e => { oa = e, queueMicrotask(p2) } }, $x = e => t => typeof t == "string" && t.startsWith(e), Ux = $x("--"), m2 = $x("var(--"), Df = e => m2(e) ? g2.test(e.split("/*")[0].trim()) : !1, g2 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu; function om(e) { return typeof e != "string" ? !1 : e.split("/*")[0].includes("var(--") } const Ks = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, Qi = { ...Ks, transform: e => on(0, 1, e) }, $o = { ...Ks, default: 1 }, Ti = e => Math.round(e * 1e5) / 1e5, Of = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function y2(e) { return e == null } const v2 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Ff = (e, t) => n => !!(typeof n == "string" && v2.test(n) && n.startsWith(e) || t && !y2(n) && Object.prototype.hasOwnProperty.call(n, t)), Wx = (e, t, n) => r => { if (typeof r != "string") return r; const [s, i, o, a] = r.match(Of); return { [e]: parseFloat(s), [t]: parseFloat(i), [n]: parseFloat(o), alpha: a !== void 0 ? parseFloat(a) : 1 } }, x2 = e => on(0, 255, e), vu = { ...Ks, transform: e => Math.round(x2(e)) }, Sr = { test: Ff("rgb", "red"), parse: Wx("red", "green", "blue"), transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + vu.transform(e) + ", " + vu.transform(t) + ", " + vu.transform(n) + ", " + Ti(Qi.transform(r)) + ")" }; function w2(e) { let t = "", n = "", r = "", s = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), s = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), s = e.substring(4, 5), t += t, n += n, r += r, s += s), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: s ? parseInt(s, 16) / 255 : 1 } } const Uc = { test: Ff("#"), parse: w2, transform: Sr.transform }, fo = e => ({ test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), Mn = fo("deg"), rn = fo("%"), _ = fo("px"), b2 = fo("vh"), S2 = fo("vw"), am = { ...rn, parse: e => rn.parse(e) / 100, transform: e => rn.transform(e * 100) }, os = { test: Ff("hsl", "hue"), parse: Wx("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + rn.transform(Ti(t)) + ", " + rn.transform(Ti(n)) + ", " + Ti(Qi.transform(r)) + ")" }, Te = { test: e => Sr.test(e) || Uc.test(e) || os.test(e), parse: e => Sr.test(e) ? Sr.parse(e) : os.test(e) ? os.parse(e) : Uc.parse(e), transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? Sr.transform(e) : os.transform(e), getAnimatableNone: e => { const t = Te.parse(e); return t.alpha = 0, Te.transform(t) } }, T2 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function C2(e) { var t, n; return isNaN(e) && typeof e == "string" && (((t = e.match(Of)) == null ? void 0 : t.length) || 0) + (((n = e.match(T2)) == null ? void 0 : n.length) || 0) > 0 } const Hx = "number", Kx = "color", E2 = "var", P2 = "var(", lm = "${}", k2 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Yi(e) { const t = e.toString(), n = [], r = { color: [], number: [], var: [] }, s = []; let i = 0; const a = t.replace(k2, l => (Te.test(l) ? (r.color.push(i), s.push(Kx), n.push(Te.parse(l))) : l.startsWith(P2) ? (r.var.push(i), s.push(E2), n.push(l)) : (r.number.push(i), s.push(Hx), n.push(parseFloat(l))), ++i, lm)).split(lm); return { values: n, split: a, indexes: r, types: s } } function Gx(e) { return Yi(e).values } function Xx(e) { const { split: t, types: n } = Yi(e), r = t.length; return s => { let i = ""; for (let o = 0; o < r; o++)if (i += t[o], s[o] !== void 0) { const a = n[o]; a === Hx ? i += Ti(s[o]) : a === Kx ? i += Te.transform(s[o]) : i += s[o] } return i } } const A2 = e => typeof e == "number" ? 0 : Te.test(e) ? Te.getAnimatableNone(e) : e; function R2(e) { const t = Gx(e); return Xx(e)(t.map(A2)) } const lr = { test: C2, parse: Gx, createTransformer: Xx, getAnimatableNone: R2 }; function xu(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function N2({ hue: e, saturation: t, lightness: n, alpha: r }) { e /= 360, t /= 100, n /= 100; let s = 0, i = 0, o = 0; if (!t) s = i = o = n; else { const a = n < .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a; s = xu(l, a, e + 1 / 3), i = xu(l, a, e), o = xu(l, a, e - 1 / 3) } return { red: Math.round(s * 255), green: Math.round(i * 255), blue: Math.round(o * 255), alpha: r } } function Wa(e, t) { return n => n > 0 ? t : e } const ge = (e, t, n) => e + (t - e) * n, wu = (e, t, n) => { const r = e * e, s = n * (t * t - r) + r; return s < 0 ? 0 : Math.sqrt(s) }, j2 = [Uc, Sr, os], M2 = e => j2.find(t => t.test(e)); function um(e) { const t = M2(e); if (Al(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable"), !t) return !1; let n = t.parse(e); return t === os && (n = N2(n)), n } const cm = (e, t) => { const n = um(e), r = um(t); if (!n || !r) return Wa(e, t); const s = { ...n }; return i => (s.red = wu(n.red, r.red, i), s.green = wu(n.green, r.green, i), s.blue = wu(n.blue, r.blue, i), s.alpha = ge(n.alpha, r.alpha, i), Sr.transform(s)) }, Wc = new Set(["none", "hidden"]); function D2(e, t) { return Wc.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e } function O2(e, t) { return n => ge(e, t, n) } function Lf(e) { return typeof e == "number" ? O2 : typeof e == "string" ? Df(e) ? Wa : Te.test(e) ? cm : I2 : Array.isArray(e) ? Qx : typeof e == "object" ? Te.test(e) ? cm : F2 : Wa } function Qx(e, t) { const n = [...e], r = n.length, s = e.map((i, o) => Lf(i)(i, t[o])); return i => { for (let o = 0; o < r; o++)n[o] = s[o](i); return n } } function F2(e, t) { const n = { ...e, ...t }, r = {}; for (const s in n) e[s] !== void 0 && t[s] !== void 0 && (r[s] = Lf(e[s])(e[s], t[s])); return s => { for (const i in r) n[i] = r[i](s); return n } } function L2(e, t) { const n = [], r = { color: 0, var: 0, number: 0 }; for (let s = 0; s < t.values.length; s++) { const i = t.types[s], o = e.indexes[i][r[i]], a = e.values[o] ?? 0; n[s] = a, r[i]++ } return n } const I2 = (e, t) => { const n = lr.createTransformer(t), r = Yi(e), s = Yi(t); return r.indexes.var.length === s.indexes.var.length && r.indexes.color.length === s.indexes.color.length && r.indexes.number.length >= s.indexes.number.length ? Wc.has(e) && !s.values.length || Wc.has(t) && !r.values.length ? D2(e, t) : uo(Qx(L2(r, s), s.values), n) : (Al(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different"), Wa(e, t)) }; function Yx(e, t, n) { return typeof e == "number" && typeof t == "number" && typeof n == "number" ? ge(e, t, n) : Lf(e)(e, t) } const V2 = e => { const t = ({ timestamp: n }) => e(n); return { start: (n = !0) => oe.update(t, n), stop: () => ar(t), now: () => De.isProcessing ? De.timestamp : Ke.now() } }, qx = (e, t, n = 10) => { let r = ""; const s = Math.max(Math.round(t / n), 2); for (let i = 0; i < s; i++)r += Math.round(e(i / (s - 1)) * 1e4) / 1e4 + ", "; return `linear(${r.substring(0, r.length - 2)})` }, Ha = 2e4; function If(e) { let t = 0; const n = 50; let r = e.next(t); for (; !r.done && t < Ha;)t += n, r = e.next(t); return t >= Ha ? 1 / 0 : t } function _2(e, t = 100, n) { const r = n({ ...e, keyframes: [0, t] }), s = Math.min(If(r), Ha); return { type: "keyframes", ease: i => r.next(s * i).value / t, duration: bt(s) } } const z2 = 5; function Zx(e, t, n) { const r = Math.max(t - z2, 0); return Nx(n - e(r), t - r) } const pe = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, bu = .001; function B2({ duration: e = pe.duration, bounce: t = pe.bounce, velocity: n = pe.velocity, mass: r = pe.mass }) { let s, i; Al(e <= Ct(pe.maxDuration), "Spring duration must be 10 seconds or less", "spring-duration-limit"); let o = 1 - t; o = on(pe.minDamping, pe.maxDamping, o), e = on(pe.minDuration, pe.maxDuration, bt(e)), o < 1 ? (s = u => { const c = u * o, d = c * e, f = c - n, h = Hc(u, o), x = Math.exp(-d); return bu - f / h * x }, i = u => { const d = u * o * e, f = d * n + n, h = Math.pow(o, 2) * Math.pow(u, 2) * e, x = Math.exp(-d), y = Hc(Math.pow(u, 2), o); return (-s(u) + bu > 0 ? -1 : 1) * ((f - h) * x) / y }) : (s = u => { const c = Math.exp(-u * e), d = (u - n) * e + 1; return -bu + c * d }, i = u => { const c = Math.exp(-u * e), d = (n - u) * (e * e); return c * d }); const a = 5 / e, l = U2(s, i, a); if (e = Ct(e), isNaN(l)) return { stiffness: pe.stiffness, damping: pe.damping, duration: e }; { const u = Math.pow(l, 2) * r; return { stiffness: u, damping: o * 2 * Math.sqrt(r * u), duration: e } } } const $2 = 12; function U2(e, t, n) { let r = n; for (let s = 1; s < $2; s++)r = r - e(r) / t(r); return r } function Hc(e, t) { return e * Math.sqrt(1 - t * t) } const W2 = ["duration", "bounce"], H2 = ["stiffness", "damping", "mass"]; function dm(e, t) { return t.some(n => e[n] !== void 0) } function K2(e) { let t = { velocity: pe.velocity, stiffness: pe.stiffness, damping: pe.damping, mass: pe.mass, isResolvedFromDuration: !1, ...e }; if (!dm(e, H2) && dm(e, W2)) if (e.visualDuration) { const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), s = r * r, i = 2 * on(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(s); t = { ...t, mass: pe.mass, stiffness: s, damping: i } } else { const n = B2(e); t = { ...t, ...n, mass: pe.mass }, t.isResolvedFromDuration = !0 } return t } function Ka(e = pe.visualDuration, t = pe.bounce) { const n = typeof e != "object" ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e; let { restSpeed: r, restDelta: s } = n; const i = n.keyframes[0], o = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: i }, { stiffness: l, damping: u, mass: c, duration: d, velocity: f, isResolvedFromDuration: h } = K2({ ...n, velocity: -bt(n.velocity || 0) }), x = f || 0, y = u / (2 * Math.sqrt(l * c)), b = o - i, p = bt(Math.sqrt(l / c)), m = Math.abs(b) < 5; r || (r = m ? pe.restSpeed.granular : pe.restSpeed.default), s || (s = m ? pe.restDelta.granular : pe.restDelta.default); let v; if (y < 1) { const T = Hc(p, y); v = C => { const E = Math.exp(-y * p * C); return o - E * ((x + y * p * b) / T * Math.sin(T * C) + b * Math.cos(T * C)) } } else if (y === 1) v = T => o - Math.exp(-p * T) * (b + (x + p * b) * T); else { const T = p * Math.sqrt(y * y - 1); v = C => { const E = Math.exp(-y * p * C), P = Math.min(T * C, 300); return o - E * ((x + y * p * b) * Math.sinh(P) + T * b * Math.cosh(P)) / T } } const S = { calculatedDuration: h && d || null, next: T => { const C = v(T); if (h) a.done = T >= d; else { let E = T === 0 ? x : 0; y < 1 && (E = T === 0 ? Ct(x) : Zx(v, T, C)); const P = Math.abs(E) <= r, N = Math.abs(o - C) <= s; a.done = P && N } return a.value = a.done ? o : C, a }, toString: () => { const T = Math.min(If(S), Ha), C = qx(E => S.next(T * E).value, T, 30); return T + "ms " + C }, toTransition: () => { } }; return S } Ka.applyToOptions = e => { const t = _2(e, 100, Ka); return e.ease = t.ease, e.duration = Ct(t.duration), e.type = "keyframes", e }; function Kc({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: s = 10, bounceStiffness: i = 500, modifyTarget: o, min: a, max: l, restDelta: u = .5, restSpeed: c }) { const d = e[0], f = { done: !1, value: d }, h = P => a !== void 0 && P < a || l !== void 0 && P > l, x = P => a === void 0 ? l : l === void 0 || Math.abs(a - P) < Math.abs(l - P) ? a : l; let y = n * t; const b = d + y, p = o === void 0 ? b : o(b); p !== b && (y = p - d); const m = P => -y * Math.exp(-P / r), v = P => p + m(P), S = P => { const N = m(P), j = v(P); f.done = Math.abs(N) <= u, f.value = f.done ? p : j }; let T, C; const E = P => { h(f.value) && (T = P, C = Ka({ keyframes: [f.value, x(f.value)], velocity: Zx(v, P, f.value), damping: s, stiffness: i, restDelta: u, restSpeed: c })) }; return E(0), { calculatedDuration: null, next: P => { let N = !1; return !C && T === void 0 && (N = !0, S(P), E(P)), T !== void 0 && P >= T ? C.next(P - T) : (!N && S(P), f) } } } function G2(e, t, n) { const r = [], s = n || Tn.mix || Yx, i = e.length - 1; for (let o = 0; o < i; o++) { let a = s(e[o], e[o + 1]); if (t) { const l = Array.isArray(t) ? t[o] || Tt : t; a = uo(l, a) } r.push(a) } return r } function X2(e, t, { clamp: n = !0, ease: r, mixer: s } = {}) { const i = e.length; if (Vs(i === t.length, "Both input and output ranges must be the same length", "range-length"), i === 1) return () => t[0]; if (i === 2 && t[0] === t[1]) return () => t[1]; const o = e[0] === e[1]; e[0] > e[i - 1] && (e = [...e].reverse(), t = [...t].reverse()); const a = G2(t, r, s), l = a.length, u = c => { if (o && c < e[0]) return t[0]; let d = 0; if (l > 1) for (; d < e.length - 2 && !(c < e[d + 1]); d++); const f = Xi(e[d], e[d + 1], c); return a[d](f) }; return n ? c => u(on(e[0], e[i - 1], c)) : u } function Q2(e, t) { const n = e[e.length - 1]; for (let r = 1; r <= t; r++) { const s = Xi(0, t, r); e.push(ge(n, 1, s)) } } function Y2(e) { const t = [0]; return Q2(t, e.length - 1), t } function q2(e, t) { return e.map(n => n * t) } function Z2(e, t) { return e.map(() => t || _x).splice(0, e.length - 1) } function Ci({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) { const s = c2(r) ? r.map(sm) : sm(r), i = { done: !1, value: t[0] }, o = q2(n && n.length === t.length ? n : Y2(t), e), a = X2(o, t, { ease: Array.isArray(s) ? s : Z2(t, s) }); return { calculatedDuration: e, next: l => (i.value = a(l), i.done = l >= e, i) } } const J2 = e => e !== null; function Vf(e, { repeat: t, repeatType: n = "loop" }, r, s = 1) { const i = e.filter(J2), a = s < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1; return !a || r === void 0 ? i[a] : r } const eA = { decay: Kc, inertia: Kc, tween: Ci, keyframes: Ci, spring: Ka }; function Jx(e) { typeof e.type == "string" && (e.type = eA[e.type]) } class _f { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(t => { this.resolve = t }) } notifyFinished() { this.resolve() } then(t, n) { return this.finished.then(t, n) } } const tA = e => e / 100; class zf extends _f { constructor(t) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { var r, s; const { motionValue: n } = this.options; n && n.updatedAt !== Ke.now() && this.tick(Ke.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (s = (r = this.options).onStop) == null || s.call(r)) }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause() } initAnimation() { const { options: t } = this; Jx(t); const { type: n = Ci, repeat: r = 0, repeatDelay: s = 0, repeatType: i, velocity: o = 0 } = t; let { keyframes: a } = t; const l = n || Ci; l !== Ci && typeof a[0] != "number" && (this.mixKeyframes = uo(tA, Yx(a[0], a[1])), a = [0, 100]); const u = l({ ...t, keyframes: a }); i === "mirror" && (this.mirroredGenerator = l({ ...t, keyframes: [...a].reverse(), velocity: -o })), u.calculatedDuration === null && (u.calculatedDuration = If(u)); const { calculatedDuration: c } = u; this.calculatedDuration = c, this.resolvedDuration = c + s, this.totalDuration = this.resolvedDuration * (r + 1) - s, this.generator = u } updateTime(t) { const n = Math.round(t - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n } tick(t, n = !1) { const { generator: r, totalDuration: s, mixKeyframes: i, mirroredGenerator: o, resolvedDuration: a, calculatedDuration: l } = this; if (this.startTime === null) return r.next(0); const { delay: u = 0, keyframes: c, repeat: d, repeatType: f, repeatDelay: h, type: x, onUpdate: y, finalKeyframe: b } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - s / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t); const p = this.currentTime - u * (this.playbackSpeed >= 0 ? 1 : -1), m = this.playbackSpeed >= 0 ? p < 0 : p > s; this.currentTime = Math.max(p, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = s); let v = this.currentTime, S = r; if (d) { const P = Math.min(this.currentTime, s) / a; let N = Math.floor(P), j = P % 1; !j && P >= 1 && (j = 1), j === 1 && N--, N = Math.min(N, d + 1), !!(N % 2) && (f === "reverse" ? (j = 1 - j, h && (j -= h / a)) : f === "mirror" && (S = o)), v = on(0, 1, j) * a } const T = m ? { done: !1, value: c[0] } : S.next(v); i && (T.value = i(T.value)); let { done: C } = T; !m && l !== null && (C = this.playbackSpeed >= 0 ? this.currentTime >= s : this.currentTime <= 0); const E = this.holdTime === null && (this.state === "finished" || this.state === "running" && C); return E && x !== Kc && (T.value = Vf(c, this.options, b, this.speed)), y && y(T.value), E && this.finish(), T } then(t, n) { return this.finished.then(t, n) } get duration() { return bt(this.calculatedDuration) } get iterationDuration() { const { delay: t = 0 } = this.options || {}; return this.duration + bt(t) } get time() { return bt(this.currentTime) } set time(t) { var n; t = Ct(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1) } get speed() { return this.playbackSpeed } set speed(t) { this.updateTime(Ke.now()); const n = this.playbackSpeed !== t; this.playbackSpeed = t, n && (this.time = bt(this.currentTime)) } play() { var s, i; if (this.isStopped) return; const { driver: t = V2, startTime: n } = this.options; this.driver || (this.driver = t(o => this.tick(o))), (i = (s = this.options).onPlay) == null || i.call(s); const r = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(Ke.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { var t, n; this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t) } cancel() { var t, n; this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t) } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(t) { return this.startTime = 0, this.tick(t, !0) } attachTimeline(t) { var n; return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this) } } function nA(e) { for (let t = 1; t < e.length; t++)e[t] ?? (e[t] = e[t - 1]) } const Tr = e => e * 180 / Math.PI, Gc = e => { const t = Tr(Math.atan2(e[1], e[0])); return Xc(t) }, rA = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: e => (Math.abs(e[0]) + Math.abs(e[3])) / 2, rotate: Gc, rotateZ: Gc, skewX: e => Tr(Math.atan(e[1])), skewY: e => Tr(Math.atan(e[2])), skew: e => (Math.abs(e[1]) + Math.abs(e[2])) / 2 }, Xc = e => (e = e % 360, e < 0 && (e += 360), e), fm = Gc, hm = e => Math.sqrt(e[0] * e[0] + e[1] * e[1]), pm = e => Math.sqrt(e[4] * e[4] + e[5] * e[5]), sA = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: hm, scaleY: pm, scale: e => (hm(e) + pm(e)) / 2, rotateX: e => Xc(Tr(Math.atan2(e[6], e[5]))), rotateY: e => Xc(Tr(Math.atan2(-e[2], e[0]))), rotateZ: fm, rotate: fm, skewX: e => Tr(Math.atan(e[4])), skewY: e => Tr(Math.atan(e[1])), skew: e => (Math.abs(e[1]) + Math.abs(e[4])) / 2 }; function Qc(e) { return e.includes("scale") ? 1 : 0 } function Yc(e, t) { if (!e || e === "none") return Qc(t); const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let r, s; if (n) r = sA, s = n; else { const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u); r = rA, s = a } if (!s) return Qc(t); const i = r[t], o = s[1].split(",").map(oA); return typeof i == "function" ? i(o) : o[i] } const iA = (e, t) => { const { transform: n = "none" } = getComputedStyle(e); return Yc(n, t) }; function oA(e) { return parseFloat(e.trim()) } const Gs = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Xs = new Set(Gs), mm = e => e === Ks || e === _, aA = new Set(["x", "y", "z"]), lA = Gs.filter(e => !aA.has(e)); function uA(e) { const t = []; return lA.forEach(n => { const r = e.getValue(n); r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), t } const Kn = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: (e, { transform: t }) => Yc(t, "x"), y: (e, { transform: t }) => Yc(t, "y") }; Kn.translateX = Kn.x; Kn.translateY = Kn.y; const Mr = new Set; let qc = !1, Zc = !1, Jc = !1; function e1() { if (Zc) { const e = Array.from(Mr).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), n = new Map; t.forEach(r => { const s = uA(r); s.length && (n.set(r, s), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render(); const s = n.get(r); s && s.forEach(([i, o]) => { var a; (a = r.getValue(i)) == null || a.set(o) }) }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } Zc = !1, qc = !1, Mr.forEach(e => e.complete(Jc)), Mr.clear() } function t1() { Mr.forEach(e => { e.readKeyframes(), e.needsMeasurement && (Zc = !0) }) } function cA() { Jc = !0, t1(), e1(), Jc = !1 } class Bf { constructor(t, n, r, s, i, o = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = s, this.element = i, this.isAsync = o } scheduleResolve() { this.state = "scheduled", this.isAsync ? (Mr.add(this), qc || (qc = !0, oe.read(t1), oe.resolveKeyframes(e1))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: t, name: n, element: r, motionValue: s } = this; if (t[0] === null) { const i = s == null ? void 0 : s.get(), o = t[t.length - 1]; if (i !== void 0) t[0] = i; else if (r && n) { const a = r.readValue(n, o); a != null && (t[0] = a) } t[0] === void 0 && (t[0] = o), s && i === void 0 && s.set(t[0]) } nA(t) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(t = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), Mr.delete(this) } cancel() { this.state === "scheduled" && (Mr.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const dA = e => e.startsWith("--"); function fA(e, t, n) { dA(t) ? e.style.setProperty(t, n) : e.style[t] = n } const hA = Rf(() => window.ScrollTimeline !== void 0), pA = {}; function mA(e, t) { const n = Rf(e); return () => pA[t] ?? n() } const n1 = mA(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), fi = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, gm = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: fi([0, .65, .55, 1]), circOut: fi([.55, 0, 1, .45]), backIn: fi([.31, .01, .66, -.59]), backOut: fi([.33, 1.53, .69, .99]) }; function r1(e, t) { if (e) return typeof e == "function" ? n1() ? qx(e, t) : "ease-out" : zx(e) ? fi(e) : Array.isArray(e) ? e.map(n => r1(n, t) || gm.easeOut) : gm[e] } function gA(e, t, n, { delay: r = 0, duration: s = 300, repeat: i = 0, repeatType: o = "loop", ease: a = "easeOut", times: l } = {}, u = void 0) { const c = { [t]: n }; l && (c.offset = l); const d = r1(a, s); Array.isArray(d) && (c.easing = d); const f = { delay: r, duration: s, easing: Array.isArray(d) ? "linear" : d, fill: "both", iterations: i + 1, direction: o === "reverse" ? "alternate" : "normal" }; return u && (f.pseudoElement = u), e.animate(c, f) } function s1(e) { return typeof e == "function" && "applyToOptions" in e } function yA({ type: e, ...t }) { return s1(e) && n1() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t) } class i1 extends _f { constructor(t) { if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !t) return; const { element: n, name: r, keyframes: s, pseudoElement: i, allowFlatten: o = !1, finalKeyframe: a, onComplete: l } = t; this.isPseudoElement = !!i, this.allowFlatten = o, this.options = t, Vs(typeof t.type != "string", `Mini animate() doesn't support "type" as a string.`, "mini-spring"); const u = yA(t); this.animation = gA(n, r, s, u, i), u.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !i) { const c = Vf(s, this.options, a, this.speed); this.updateMotionValue ? this.updateMotionValue(c) : fA(n, r, c), this.animation.cancel() } l == null || l(), this.notifyFinished() } } play() { this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { var t, n; (n = (t = this.animation).finish) == null || n.call(t) } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: t } = this; t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { var n, r, s; const t = (n = this.options) == null ? void 0 : n.element; !this.isPseudoElement && (t != null && t.isConnected) && ((s = (r = this.animation).commitStyles) == null || s.call(r)) } get duration() { var n, r; const t = ((r = (n = this.animation.effect) == null ? void 0 : n.getComputedTiming) == null ? void 0 : r.call(n).duration) || 0; return bt(Number(t)) } get iterationDuration() { const { delay: t = 0 } = this.options || {}; return this.duration + bt(t) } get time() { return bt(Number(this.animation.currentTime) || 0) } set time(t) { this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = Ct(t) } get speed() { return this.animation.playbackRate } set speed(t) { t < 0 && (this.finishedTime = null), this.animation.playbackRate = t } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return this.manualStartTime ?? Number(this.animation.startTime) } set startTime(t) { this.manualStartTime = this.animation.startTime = t } attachTimeline({ timeline: t, observe: n }) { var r; return this.allowFlatten && ((r = this.animation.effect) == null || r.updateTiming({ easing: "linear" })), this.animation.onfinish = null, t && hA() ? (this.animation.timeline = t, Tt) : n(this) } } const o1 = { anticipate: Lx, backInOut: Fx, circInOut: Vx }; function vA(e) { return e in o1 } function xA(e) { typeof e.ease == "string" && vA(e.ease) && (e.ease = o1[e.ease]) } const Su = 10; class wA extends i1 { constructor(t) { xA(t), Jx(t), super(t), t.startTime !== void 0 && (this.startTime = t.startTime), this.options = t } updateMotionValue(t) { const { motionValue: n, onUpdate: r, onComplete: s, element: i, ...o } = this.options; if (!n) return; if (t !== void 0) { n.set(t); return } const a = new zf({ ...o, autoplay: !1 }), l = Math.max(Su, Ke.now() - this.startTime), u = on(0, Su, l - Su); n.setWithVelocity(a.sample(Math.max(0, l - u)).value, a.sample(l).value, u), a.stop() } } const ym = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (lr.test(e) || e === "0") && !e.startsWith("url(")); function bA(e) { const t = e[0]; if (e.length === 1) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 } function SA(e, t, n, r) { const s = e[0]; if (s === null) return !1; if (t === "display" || t === "visibility") return !0; const i = e[e.length - 1], o = ym(s, t), a = ym(i, t); return Al(o === a, `You are trying to animate ${t} from "${s}" to "${i}". "${o ? i : s}" is not an animatable value.`, "value-not-animatable"), !o || !a ? !1 : bA(e) || (n === "spring" || s1(n)) && r } function ed(e) { e.duration = 0, e.type = "keyframes" } const TA = new Set(["opacity", "clipPath", "filter", "transform"]), CA = Rf(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function EA(e) { var c; const { motionValue: t, name: n, repeatDelay: r, repeatType: s, damping: i, type: o } = e; if (!(((c = t == null ? void 0 : t.owner) == null ? void 0 : c.current) instanceof HTMLElement)) return !1; const { onUpdate: l, transformTemplate: u } = t.owner.getProps(); return CA() && n && TA.has(n) && (n !== "transform" || !u) && !l && !r && s !== "mirror" && i !== 0 && o !== "inertia" } const PA = 40; class kA extends _f { constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: s = 0, repeatDelay: i = 0, repeatType: o = "loop", keyframes: a, name: l, motionValue: u, element: c, ...d }) { var x; super(), this.stop = () => { var y, b; this._animation && (this._animation.stop(), (y = this.stopTimeline) == null || y.call(this)), (b = this.keyframeResolver) == null || b.cancel() }, this.createdAt = Ke.now(); const f = { autoplay: t, delay: n, type: r, repeat: s, repeatDelay: i, repeatType: o, name: l, motionValue: u, element: c, ...d }, h = (c == null ? void 0 : c.KeyframeResolver) || Bf; this.keyframeResolver = new h(a, (y, b, p) => this.onKeyframesResolved(y, b, f, !p), l, u, c), (x = this.keyframeResolver) == null || x.scheduleResolve() } onKeyframesResolved(t, n, r, s) { var b, p; this.keyframeResolver = void 0; const { name: i, type: o, velocity: a, delay: l, isHandoff: u, onUpdate: c } = r; this.resolvedAt = Ke.now(), SA(t, i, o, a) || ((Tn.instantAnimations || !l) && (c == null || c(Vf(t, r, n))), t[0] = t[t.length - 1], ed(r), r.repeat = 0); const f = { startTime: s ? this.resolvedAt ? this.resolvedAt - this.createdAt > PA ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: n, ...r, keyframes: t }, h = !u && EA(f), x = (p = (b = f.motionValue) == null ? void 0 : b.owner) == null ? void 0 : p.current, y = h ? new wA({ ...f, element: x }) : new zf(f); y.finished.then(() => { this.notifyFinished() }).catch(Tt), this.pendingTimeline && (this.stopTimeline = y.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = y } get finished() { return this._animation ? this.animation.finished : this._finished } then(t, n) { return this.finished.finally(t).then(() => { }) } get animation() { var t; return this._animation || ((t = this.keyframeResolver) == null || t.resume(), cA()), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(t) { this.animation.time = t } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(t) { this.animation.speed = t } get startTime() { return this.animation.startTime } attachTimeline(t) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { var t; this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel() } } function a1(e, t, n, r = 0, s = 1) { const i = Array.from(e).sort((u, c) => u.sortNodePosition(c)).indexOf(t), o = e.size, a = (o - 1) * r; return typeof n == "function" ? n(i, o) : s === 1 ? i * r : a - i * r } const AA = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function RA(e) { const t = AA.exec(e); if (!t) return [,]; const [, n, r, s] = t; return [`--${n ?? r}`, s] } const NA = 4; function l1(e, t, n = 1) { Vs(n <= NA, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`, "max-css-var-depth"); const [r, s] = RA(e); if (!r) return; const i = window.getComputedStyle(t).getPropertyValue(r); if (i) { const o = i.trim(); return kx(o) ? parseFloat(o) : o } return Df(s) ? l1(s, t, n + 1) : s } const jA = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, MA = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), DA = { type: "keyframes", duration: .8 }, OA = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, FA = (e, { keyframes: t }) => t.length > 2 ? DA : Xs.has(e) ? e.startsWith("scale") ? MA(t[1]) : jA : OA, LA = e => e !== null; function IA(e, { repeat: t, repeatType: n = "loop" }, r) { const s = e.filter(LA), i = t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1; return !i || r === void 0 ? s[i] : r } function u1(e, t) { if (e != null && e.inherit && t) { const { inherit: n, ...r } = e; return { ...t, ...r } } return e } function $f(e, t) { const n = (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e; return n !== e ? u1(n, e) : n } function VA({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: s, repeat: i, repeatType: o, repeatDelay: a, from: l, elapsed: u, ...c }) { return !!Object.keys(c).length } const Uf = (e, t, n, r = {}, s, i) => o => { const a = $f(r, e) || {}, l = a.delay || r.delay || 0; let { elapsed: u = 0 } = r; u = u - Ct(l); const c = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...a, delay: -u, onUpdate: f => { t.set(f), a.onUpdate && a.onUpdate(f) }, onComplete: () => { o(), a.onComplete && a.onComplete() }, name: e, motionValue: t, element: i ? void 0 : s }; VA(a) || Object.assign(c, FA(e, c)), c.duration && (c.duration = Ct(c.duration)), c.repeatDelay && (c.repeatDelay = Ct(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from); let d = !1; if ((c.type === !1 || c.duration === 0 && !c.repeatDelay) && (ed(c), c.delay === 0 && (d = !0)), (Tn.instantAnimations || Tn.skipAnimations || s != null && s.shouldSkipAnimations) && (d = !0, ed(c), c.delay = 0), c.allowFlatten = !a.type && !a.ease, d && !i && t.get() !== void 0) { const f = IA(c.keyframes, a); if (f !== void 0) { oe.update(() => { c.onUpdate(f), c.onComplete() }); return } } return a.isSync ? new zf(c) : new kA(c) }; function vm(e) { const t = [{}, {}]; return e == null || e.values.forEach((n, r) => { t[0][r] = n.get(), t[1][r] = n.getVelocity() }), t } function Wf(e, t, n, r) { if (typeof t == "function") { const [s, i] = vm(r); t = t(n !== void 0 ? n : e.custom, s, i) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { const [s, i] = vm(r); t = t(n !== void 0 ? n : e.custom, s, i) } return t } function ws(e, t, n) { const r = e.getProps(); return Wf(r, t, n !== void 0 ? n : r.custom, e) } const c1 = new Set(["width", "height", "top", "left", "right", "bottom", ...Gs]), xm = 30, _A = e => !isNaN(parseFloat(e)); class zA { constructor(t, n = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = r => { var i; const s = Ke.now(); if (this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && ((i = this.events.change) == null || i.notify(this.current), this.dependents)) for (const o of this.dependents) o.dirty() }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner } setCurrent(t) { this.current = t, this.updatedAt = Ke.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = _A(this.current)) } setPrevFrameValue(t = this.current) { this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt } onChange(t) { return this.on("change", t) } on(t, n) { this.events[t] || (this.events[t] = new Nf); const r = this.events[t].add(n); return t === "change" ? () => { r(), oe.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const t in this.events) this.events[t].clear() } attach(t, n) { this.passiveEffect = t, this.stopPassiveEffect = n } set(t) { this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t) } setWithVelocity(t, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r } jump(t, n = !0) { this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { var t; (t = this.events.change) == null || t.notify(this.current) } addDependent(t) { this.dependents || (this.dependents = new Set), this.dependents.add(t) } removeDependent(t) { this.dependents && this.dependents.delete(t) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const t = Ke.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > xm) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, xm); return Nx(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(t) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { var t, n; (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function _s(e, t) { return new zA(e, t) } const td = e => Array.isArray(e); function BA(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, _s(n)) } function $A(e) { return td(e) ? e[e.length - 1] || 0 : e } function UA(e, t) { const n = ws(e, t); let { transitionEnd: r = {}, transition: s = {}, ...i } = n || {}; i = { ...i, ...r }; for (const o in i) { const a = $A(i[o]); BA(e, o, a) } } const Be = e => !!(e && e.getVelocity); function WA(e) { return !!(Be(e) && e.add) } function nd(e, t) { const n = e.getValue("willChange"); if (WA(n)) return n.add(t); if (!n && Tn.WillChange) { const r = new Tn.WillChange("auto"); e.addValue("willChange", r), r.add(t) } } function Hf(e) { return e.replace(/([A-Z])/g, t => `-${t.toLowerCase()}`) } const HA = "framerAppearId", d1 = "data-" + Hf(HA); function f1(e) { return e.props[d1] } function KA({ protectedKeys: e, needsAnimating: t }, n) { const r = e.hasOwnProperty(n) && t[n] !== !0; return t[n] = !1, r } function h1(e, t, { delay: n = 0, transitionOverride: r, type: s } = {}) { let { transition: i, transitionEnd: o, ...a } = t; const l = e.getDefaultTransition(); i = i ? u1(i, l) : l; const u = i == null ? void 0 : i.reduceMotion; r && (i = r); const c = [], d = s && e.animationState && e.animationState.getState()[s]; for (const f in a) { const h = e.getValue(f, e.latestValues[f] ?? null), x = a[f]; if (x === void 0 || d && KA(d, f)) continue; const y = { delay: n, ...$f(i || {}, f) }, b = h.get(); if (b !== void 0 && !h.isAnimating && !Array.isArray(x) && x === b && !y.velocity) continue; let p = !1; if (window.MotionHandoffAnimation) { const S = f1(e); if (S) { const T = window.MotionHandoffAnimation(S, f, oe); T !== null && (y.startTime = T, p = !0) } } nd(e, f); const m = u ?? e.shouldReduceMotion; h.start(Uf(f, h, x, m && c1.has(f) ? { type: !1 } : y, e, p)); const v = h.animation; v && c.push(v) } if (o) { const f = () => oe.update(() => { o && UA(e, o) }); c.length ? Promise.all(c).then(f) : f() } return c } function rd(e, t, n = {}) { var l; const r = ws(e, t, n.type === "exit" ? (l = e.presenceContext) == null ? void 0 : l.custom : void 0); let { transition: s = e.getDefaultTransition() || {} } = r || {}; n.transitionOverride && (s = n.transitionOverride); const i = r ? () => Promise.all(h1(e, r, n)) : () => Promise.resolve(), o = e.variantChildren && e.variantChildren.size ? (u = 0) => { const { delayChildren: c = 0, staggerChildren: d, staggerDirection: f } = s; return GA(e, t, u, c, d, f, n) } : () => Promise.resolve(), { when: a } = s; if (a) { const [u, c] = a === "beforeChildren" ? [i, o] : [o, i]; return u().then(() => c()) } else return Promise.all([i(), o(n.delay)]) } function GA(e, t, n = 0, r = 0, s = 0, i = 1, o) { const a = []; for (const l of e.variantChildren) l.notify("AnimationStart", t), a.push(rd(l, t, { ...o, delay: n + (typeof r == "function" ? 0 : r) + a1(e.variantChildren, l, r, s, i) }).then(() => l.notify("AnimationComplete", t))); return Promise.all(a) } function XA(e, t, n = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { const s = t.map(i => rd(e, i, n)); r = Promise.all(s) } else if (typeof t == "string") r = rd(e, t, n); else { const s = typeof t == "function" ? ws(e, t, n.custom) : t; r = Promise.all(h1(e, s, n)) } return r.then(() => { e.notify("AnimationComplete", t) }) } const QA = { test: e => e === "auto", parse: e => e }, p1 = e => t => t.test(e), m1 = [Ks, _, rn, Mn, S2, b2, QA], wm = e => m1.find(p1(e)); function YA(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Rx(e) : !0 } const qA = new Set(["brightness", "contrast", "saturate", "opacity"]); function ZA(e) { const [t, n] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; const [r] = n.match(Of) || []; if (!r) return e; const s = n.replace(r, ""); let i = qA.has(t) ? 1 : 0; return r !== n && (i *= 100), t + "(" + i + s + ")" } const JA = /\b([a-z-]*)\(.*?\)/gu, sd = { ...lr, getAnimatableNone: e => { const t = e.match(JA); return t ? t.map(ZA).join(" ") : e } }, bm = { ...Ks, transform: Math.round }, eR = { rotate: Mn, rotateX: Mn, rotateY: Mn, rotateZ: Mn, scale: $o, scaleX: $o, scaleY: $o, scaleZ: $o, skew: Mn, skewX: Mn, skewY: Mn, distance: _, translateX: _, translateY: _, translateZ: _, x: _, y: _, z: _, perspective: _, transformPerspective: _, opacity: Qi, originX: am, originY: am, originZ: _ }, Kf = { borderWidth: _, borderTopWidth: _, borderRightWidth: _, borderBottomWidth: _, borderLeftWidth: _, borderRadius: _, borderTopLeftRadius: _, borderTopRightRadius: _, borderBottomRightRadius: _, borderBottomLeftRadius: _, width: _, maxWidth: _, height: _, maxHeight: _, top: _, right: _, bottom: _, left: _, inset: _, insetBlock: _, insetBlockStart: _, insetBlockEnd: _, insetInline: _, insetInlineStart: _, insetInlineEnd: _, padding: _, paddingTop: _, paddingRight: _, paddingBottom: _, paddingLeft: _, paddingBlock: _, paddingBlockStart: _, paddingBlockEnd: _, paddingInline: _, paddingInlineStart: _, paddingInlineEnd: _, margin: _, marginTop: _, marginRight: _, marginBottom: _, marginLeft: _, marginBlock: _, marginBlockStart: _, marginBlockEnd: _, marginInline: _, marginInlineStart: _, marginInlineEnd: _, fontSize: _, backgroundPositionX: _, backgroundPositionY: _, ...eR, zIndex: bm, fillOpacity: Qi, strokeOpacity: Qi, numOctaves: bm }, tR = { ...Kf, color: Te, backgroundColor: Te, outlineColor: Te, fill: Te, stroke: Te, borderColor: Te, borderTopColor: Te, borderRightColor: Te, borderBottomColor: Te, borderLeftColor: Te, filter: sd, WebkitFilter: sd }, g1 = e => tR[e]; function y1(e, t) { let n = g1(e); return n !== sd && (n = lr), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } const nR = new Set(["auto", "none", "0"]); function rR(e, t, n) { let r = 0, s; for (; r < e.length && !s;) { const i = e[r]; typeof i == "string" && !nR.has(i) && Yi(i).values.length && (s = e[r]), r++ } if (s && n) for (const i of t) e[i] = y1(n, s) } class sR extends Bf { constructor(t, n, r, s, i) { super(t, n, r, s, i, !0) } readKeyframes() { const { unresolvedKeyframes: t, element: n, name: r } = this; if (!n || !n.current) return; super.readKeyframes(); for (let c = 0; c < t.length; c++) { let d = t[c]; if (typeof d == "string" && (d = d.trim(), Df(d))) { const f = l1(d, n.current); f !== void 0 && (t[c] = f), c === t.length - 1 && (this.finalKeyframe = d) } } if (this.resolveNoneKeyframes(), !c1.has(r) || t.length !== 2) return; const [s, i] = t, o = wm(s), a = wm(i), l = om(s), u = om(i); if (l !== u && Kn[r]) { this.needsMeasurement = !0; return } if (o !== a) if (mm(o) && mm(a)) for (let c = 0; c < t.length; c++) { const d = t[c]; typeof d == "string" && (t[c] = parseFloat(d)) } else Kn[r] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: t, name: n } = this, r = []; for (let s = 0; s < t.length; s++)(t[s] === null || YA(t[s])) && r.push(s); r.length && rR(t, r, n) } measureInitialState() { const { element: t, unresolvedKeyframes: n, name: r } = this; if (!t || !t.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Kn[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin; const s = n[n.length - 1]; s !== void 0 && t.getValue(r, s).jump(s, !1) } measureEndState() { var a; const { element: t, name: n, unresolvedKeyframes: r } = this; if (!t || !t.current) return; const s = t.getValue(n); s && s.jump(this.measuredOrigin, !1); const i = r.length - 1, o = r[i]; r[i] = Kn[n](t.measureViewportBox(), window.getComputedStyle(t.current)), o !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = o), (a = this.removedTransforms) != null && a.length && this.removedTransforms.forEach(([l, u]) => { t.getValue(l).set(u) }), this.resolveNoneKeyframes() } } const iR = new Set(["opacity", "clipPath", "filter", "transform"]); function v1(e, t, n) { if (e == null) return []; if (e instanceof EventTarget) return [e]; if (typeof e == "string") { const s = document.querySelectorAll(e); return s ? Array.from(s) : [] } return Array.from(e).filter(r => r != null) } const x1 = (e, t) => t && typeof e == "number" ? t.transform(e) : e; function id(e) { return Ax(e) && "offsetHeight" in e } const { schedule: Gf, cancel: Lj } = Bx(queueMicrotask, !1), Dt = { x: !1, y: !1 }; function w1() { return Dt.x || Dt.y } function oR(e) { return e === "x" || e === "y" ? Dt[e] ? null : (Dt[e] = !0, () => { Dt[e] = !1 }) : Dt.x || Dt.y ? null : (Dt.x = Dt.y = !0, () => { Dt.x = Dt.y = !1 }) } function b1(e, t) { const n = v1(e), r = new AbortController, s = { passive: !0, ...t, signal: r.signal }; return [n, s, () => r.abort()] } function aR(e) { return !(e.pointerType === "touch" || w1()) } function lR(e, t, n = {}) { const [r, s, i] = b1(e, n); return r.forEach(o => { let a = !1, l = !1, u; const c = () => { o.removeEventListener("pointerleave", x) }, d = b => { u && (u(b), u = void 0), c() }, f = b => { a = !1, window.removeEventListener("pointerup", f), window.removeEventListener("pointercancel", f), l && (l = !1, d(b)) }, h = () => { a = !0, window.addEventListener("pointerup", f, s), window.addEventListener("pointercancel", f, s) }, x = b => { if (b.pointerType !== "touch") { if (a) { l = !0; return } d(b) } }, y = b => { if (!aR(b)) return; l = !1; const p = t(o, b); typeof p == "function" && (u = p, o.addEventListener("pointerleave", x, s)) }; o.addEventListener("pointerenter", y, s), o.addEventListener("pointerdown", h, s) }), i } const S1 = (e, t) => t ? e === t ? !0 : S1(e, t.parentElement) : !1, Xf = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, uR = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function cR(e) { return uR.has(e.tagName) || e.isContentEditable === !0 } const dR = new Set(["INPUT", "SELECT", "TEXTAREA"]); function fR(e) { return dR.has(e.tagName) || e.isContentEditable === !0 } const aa = new WeakSet; function Sm(e) { return t => { t.key === "Enter" && e(t) } } function Tu(e, t) { e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 })) } const hR = (e, t) => { const n = e.currentTarget; if (!n) return; const r = Sm(() => { if (aa.has(n)) return; Tu(n, "down"); const s = Sm(() => { Tu(n, "up") }), i = () => Tu(n, "cancel"); n.addEventListener("keyup", s, t), n.addEventListener("blur", i, t) }); n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t) }; function Tm(e) { return Xf(e) && !w1() } const Cm = new WeakSet; function pR(e, t, n = {}) { const [r, s, i] = b1(e, n), o = a => { const l = a.currentTarget; if (!Tm(a) || Cm.has(a)) return; aa.add(l), n.stopPropagation && Cm.add(a); const u = t(l, a), c = (h, x) => { window.removeEventListener("pointerup", d), window.removeEventListener("pointercancel", f), aa.has(l) && aa.delete(l), Tm(h) && typeof u == "function" && u(h, { success: x }) }, d = h => { c(h, l === window || l === document || n.useGlobalTarget || S1(l, h.target)) }, f = h => { c(h, !1) }; window.addEventListener("pointerup", d, s), window.addEventListener("pointercancel", f, s) }; return r.forEach(a => { (n.useGlobalTarget ? window : a).addEventListener("pointerdown", o, s), id(a) && (a.addEventListener("focus", u => hR(u, s)), !cR(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0)) }), i } function Qf(e) { return Ax(e) && "ownerSVGElement" in e } const la = new WeakMap; let Dn; const T1 = (e, t, n) => (r, s) => s && s[0] ? s[0][e + "Size"] : Qf(r) && "getBBox" in r ? r.getBBox()[t] : r[n], mR = T1("inline", "width", "offsetWidth"), gR = T1("block", "height", "offsetHeight"); function yR({ target: e, borderBoxSize: t }) { var n; (n = la.get(e)) == null || n.forEach(r => { r(e, { get width() { return mR(e, t) }, get height() { return gR(e, t) } }) }) } function vR(e) { e.forEach(yR) } function xR() { typeof ResizeObserver > "u" || (Dn = new ResizeObserver(vR)) } function wR(e, t) { Dn || xR(); const n = v1(e); return n.forEach(r => { let s = la.get(r); s || (s = new Set, la.set(r, s)), s.add(t), Dn == null || Dn.observe(r) }), () => { n.forEach(r => { const s = la.get(r); s == null || s.delete(t), s != null && s.size || Dn == null || Dn.unobserve(r) }) } } const ua = new Set; let as; function bR() { as = () => { const e = { get width() { return window.innerWidth }, get height() { return window.innerHeight } }; ua.forEach(t => t(e)) }, window.addEventListener("resize", as) } function SR(e) { return ua.add(e), as || bR(), () => { ua.delete(e), !ua.size && typeof as == "function" && (window.removeEventListener("resize", as), as = void 0) } } function Em(e, t) { return typeof e == "function" ? SR(e) : wR(e, t) } function TR(e) { return Qf(e) && e.tagName === "svg" } const CR = [...m1, Te, lr], ER = e => CR.find(p1(e)), Pm = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), ls = () => ({ x: Pm(), y: Pm() }), km = () => ({ min: 0, max: 0 }), Ee = () => ({ x: km(), y: km() }), PR = new WeakMap; function Rl(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } function qi(e) { return typeof e == "string" || Array.isArray(e) } const Yf = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], qf = ["initial", ...Yf]; function Nl(e) { return Rl(e.animate) || qf.some(t => qi(e[t])) } function C1(e) { return !!(Nl(e) || e.variants) } function kR(e, t, n) { for (const r in t) { const s = t[r], i = n[r]; if (Be(s)) e.addValue(r, s); else if (Be(i)) e.addValue(r, _s(s, { owner: e })); else if (i !== s) if (e.hasValue(r)) { const o = e.getValue(r); o.liveStyle === !0 ? o.jump(s) : o.hasAnimated || o.set(s) } else { const o = e.getStaticValue(r); e.addValue(r, _s(o !== void 0 ? o : s, { owner: e })) } } for (const r in n) t[r] === void 0 && e.removeValue(r); return t } const od = { current: null }, E1 = { current: !1 }, AR = typeof window < "u"; function RR() { if (E1.current = !0, !!AR) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), t = () => od.current = e.matches; e.addEventListener("change", t), t() } else od.current = !1 } const Am = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; let Ga = {}; function P1(e) { Ga = e } function NR() { return Ga } class jR { scrapeMotionValuesFromProps(t, n, r) { return {} } constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: s, skipAnimations: i, blockInitialAnimation: o, visualState: a }, l = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.shouldSkipAnimations = !1, this.values = new Map, this.KeyframeResolver = Bf, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.hasBeenMounted = !1, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const h = Ke.now(); this.renderScheduledAt < h && (this.renderScheduledAt = h, oe.render(this.render, !1, !0)) }; const { latestValues: u, renderState: c } = a; this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = n.initial ? { ...u } : {}, this.renderState = c, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = s, this.skipAnimationsConfig = i, this.options = l, this.blockInitialAnimation = !!o, this.isControllingVariants = Nl(n), this.isVariantNode = C1(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current); const { willChange: d, ...f } = this.scrapeMotionValuesFromProps(n, {}, this); for (const h in f) { const x = f[h]; u[h] !== void 0 && Be(x) && x.set(u[h]) } } mount(t) { var n, r; if (this.hasBeenMounted) for (const s in this.initialValues) (n = this.values.get(s)) == null || n.jump(this.initialValues[s]), this.latestValues[s] = this.initialValues[s]; this.current = t, PR.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((s, i) => this.bindToMotionValue(i, s)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (E1.current || RR(), this.shouldReduceMotion = od.current), this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1, (r = this.parent) == null || r.addChild(this), this.update(this.props, this.presenceContext), this.hasBeenMounted = !0 } unmount() { var t; this.projection && this.projection.unmount(), ar(this.notifyUpdate), ar(this.render), this.valueSubscriptions.forEach(n => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (t = this.parent) == null || t.removeChild(this); for (const n in this.events) this.events[n].clear(); for (const n in this.features) { const r = this.features[n]; r && (r.unmount(), r.isMounted = !1) } this.current = null } addChild(t) { this.children.add(t), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(t) } removeChild(t) { this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t) } bindToMotionValue(t, n) { if (this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)(), n.accelerate && iR.has(t) && this.current instanceof HTMLElement) { const { factory: o, keyframes: a, times: l, ease: u, duration: c } = n.accelerate, d = new i1({ element: this.current, name: t, keyframes: a, times: l, ease: u, duration: Ct(c) }), f = o(d); this.valueSubscriptions.set(t, () => { f(), d.cancel() }); return } const r = Xs.has(t); r && this.onBindTransform && this.onBindTransform(); const s = n.on("change", o => { this.latestValues[t] = o, this.props.onUpdate && oe.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let i; typeof window < "u" && window.MotionCheckAppearSync && (i = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => { s(), i && i(), n.owner && n.stop() }) } sortNodePosition(t) { return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current) } updateFeatures() { let t = "animation"; for (t in Ga) { const n = Ga[t]; if (!n) continue; const { isEnabled: r, Feature: s } = n; if (!this.features[t] && s && r(this.props) && (this.features[t] = new s(this)), this.features[t]) { const i = this.features[t]; i.isMounted ? i.update() : (i.mount(), i.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ee() } getStaticValue(t) { return this.latestValues[t] } setStaticValue(t, n) { this.latestValues[t] = n } update(t, n) { (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < Am.length; r++) { const s = Am[r]; this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]); const i = "on" + s, o = t[i]; o && (this.propEventSubscriptions[s] = this.on(s, o)) } this.prevMotionValues = kR(this, this.scrapeMotionValuesFromProps(t, this.prevProps || {}, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(t) { return this.props.variants ? this.props.variants[t] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(t) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t) } addValue(t, n) { const r = this.values.get(t); n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get()) } removeValue(t) { this.values.delete(t); const n = this.valueSubscriptions.get(t); n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState) } hasValue(t) { return this.values.has(t) } getValue(t, n) { if (this.props.values && this.props.values[t]) return this.props.values[t]; let r = this.values.get(t); return r === void 0 && n !== void 0 && (r = _s(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r } readValue(t, n) { let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options); return r != null && (typeof r == "string" && (kx(r) || Rx(r)) ? r = parseFloat(r) : !ER(r) && lr.test(n) && (r = y1(t, n)), this.setBaseTarget(t, Be(r) ? r.get() : r)), Be(r) ? r.get() : r } setBaseTarget(t, n) { this.baseTarget[t] = n } getBaseTarget(t) { var i; const { initial: n } = this.props; let r; if (typeof n == "string" || typeof n == "object") { const o = Wf(this.props, n, (i = this.presenceContext) == null ? void 0 : i.custom); o && (r = o[t]) } if (n && r !== void 0) return r; const s = this.getBaseTargetFromProps(this.props, t); return s !== void 0 && !Be(s) ? s : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t] } on(t, n) { return this.events[t] || (this.events[t] = new Nf), this.events[t].add(n) } notify(t, ...n) { this.events[t] && this.events[t].notify(...n) } scheduleRenderMicrotask() { Gf.render(this.render) } } class k1 extends jR { constructor() { super(...arguments), this.KeyframeResolver = sR } sortInstanceNodePosition(t, n) { return t.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(t, n) { const r = t.style; return r ? r[n] : void 0 } removeValueFromRenderState(t, { vars: n, style: r }) { delete n[t], delete r[t] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: t } = this.props; Be(t) && (this.childSubscription = t.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } } class fr { constructor(t) { this.isMounted = !1, this.node = t } update() { } } function A1({ top: e, left: t, right: n, bottom: r }) { return { x: { min: t, max: n }, y: { min: e, max: r } } } function MR({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function DR(e, t) { if (!t) return e; const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function Cu(e) { return e === void 0 || e === 1 } function ad({ scale: e, scaleX: t, scaleY: n }) { return !Cu(e) || !Cu(t) || !Cu(n) } function vr(e) { return ad(e) || R1(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function R1(e) { return Rm(e.x) || Rm(e.y) } function Rm(e) { return e && e !== "0%" } function Xa(e, t, n) { const r = e - n, s = t * r; return n + s } function Nm(e, t, n, r, s) { return s !== void 0 && (e = Xa(e, s, r)), Xa(e, n, r) + t } function ld(e, t = 0, n = 1, r, s) { e.min = Nm(e.min, t, n, r, s), e.max = Nm(e.max, t, n, r, s) } function N1(e, { x: t, y: n }) { ld(e.x, t.translate, t.scale, t.originPoint), ld(e.y, n.translate, n.scale, n.originPoint) } const jm = .999999999999, Mm = 1.0000000000001; function OR(e, t, n, r = !1) { const s = n.length; if (!s) return; t.x = t.y = 1; let i, o; for (let a = 0; a < s; a++) { i = n[a], o = i.projectionDelta; const { visualElement: l } = i.options; l && l.props.style && l.props.style.display === "contents" || (r && i.options.layoutScroll && i.scroll && i !== i.root && cs(e, { x: -i.scroll.offset.x, y: -i.scroll.offset.y }), o && (t.x *= o.x.scale, t.y *= o.y.scale, N1(e, o)), r && vr(i.latestValues) && cs(e, i.latestValues)) } t.x < Mm && t.x > jm && (t.x = 1), t.y < Mm && t.y > jm && (t.y = 1) } function us(e, t) { e.min = e.min + t, e.max = e.max + t } function Dm(e, t, n, r, s = .5) { const i = ge(e.min, e.max, s); ld(e, t, n, i, r) } function cs(e, t) { Dm(e.x, t.x, t.scaleX, t.scale, t.originX), Dm(e.y, t.y, t.scaleY, t.scale, t.originY) } function j1(e, t) { return A1(DR(e.getBoundingClientRect(), t)) } function FR(e, t, n) { const r = j1(e, n), { scroll: s } = t; return s && (us(r.x, s.offset.x), us(r.y, s.offset.y)), r } const LR = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, IR = Gs.length; function VR(e, t, n) { let r = "", s = !0; for (let i = 0; i < IR; i++) { const o = Gs[i], a = e[o]; if (a === void 0) continue; let l = !0; if (typeof a == "number") l = a === (o.startsWith("scale") ? 1 : 0); else { const u = parseFloat(a); l = o.startsWith("scale") ? u === 1 : u === 0 } if (!l || n) { const u = x1(a, Kf[o]); if (!l) { s = !1; const c = LR[o] || o; r += `${c}(${u}) ` } n && (t[o] = u) } } return r = r.trim(), n ? r = n(t, s ? "" : r) : s && (r = "none"), r } function Zf(e, t, n) { const { style: r, vars: s, transformOrigin: i } = e; let o = !1, a = !1; for (const l in t) { const u = t[l]; if (Xs.has(l)) { o = !0; continue } else if (Ux(l)) { s[l] = u; continue } else { const c = x1(u, Kf[l]); l.startsWith("origin") ? (a = !0, i[l] = c) : r[l] = c } } if (t.transform || (o || n ? r.transform = VR(t, e.transform, n) : r.transform && (r.transform = "none")), a) { const { originX: l = "50%", originY: u = "50%", originZ: c = 0 } = i; r.transformOrigin = `${l} ${u} ${c}` } } function M1(e, { style: t, vars: n }, r, s) { const i = e.style; let o; for (o in t) i[o] = t[o]; s == null || s.applyProjectionStyles(i, r); for (o in n) i.setProperty(o, n[o]) } function Om(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } const ai = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (_.test(e)) e = parseFloat(e); else return e; const n = Om(e, t.target.x), r = Om(e, t.target.y); return `${n}% ${r}%` } }, _R = { correct: (e, { treeScale: t, projectionDelta: n }) => { const r = e, s = lr.parse(e); if (s.length > 5) return r; const i = lr.createTransformer(e), o = typeof s[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y; s[0 + o] /= a, s[1 + o] /= l; const u = ge(a, l, .5); return typeof s[2 + o] == "number" && (s[2 + o] /= u), typeof s[3 + o] == "number" && (s[3 + o] /= u), i(s) } }, ud = { borderRadius: { ...ai, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: ai, borderTopRightRadius: ai, borderBottomLeftRadius: ai, borderBottomRightRadius: ai, boxShadow: _R }; function D1(e, { layout: t, layoutId: n }) { return Xs.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!ud[e] || e === "opacity") } function Jf(e, t, n) { var o; const r = e.style, s = t == null ? void 0 : t.style, i = {}; if (!r) return i; for (const a in r) (Be(r[a]) || s && Be(s[a]) || D1(a, e) || ((o = n == null ? void 0 : n.getValue(a)) == null ? void 0 : o.liveStyle) !== void 0) && (i[a] = r[a]); return i } function zR(e) { return window.getComputedStyle(e) } class BR extends k1 { constructor() { super(...arguments), this.type = "html", this.renderInstance = M1 } readValueFromInstance(t, n) { var r; if (Xs.has(n)) return (r = this.projection) != null && r.isProjecting ? Qc(n) : iA(t, n); { const s = zR(t), i = (Ux(n) ? s.getPropertyValue(n) : s[n]) || 0; return typeof i == "string" ? i.trim() : i } } measureInstanceViewportBox(t, { transformPagePoint: n }) { return j1(t, n) } build(t, n, r) { Zf(t, n, r.transformTemplate) } scrapeMotionValuesFromProps(t, n, r) { return Jf(t, n, r) } } const $R = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, UR = { offset: "strokeDashoffset", array: "strokeDasharray" }; function WR(e, t, n = 1, r = 0, s = !0) { e.pathLength = 1; const i = s ? $R : UR; e[i.offset] = `${-r}`, e[i.array] = `${t} ${n}` } const HR = ["offsetDistance", "offsetPath", "offsetRotate", "offsetAnchor"]; function O1(e, { attrX: t, attrY: n, attrScale: r, pathLength: s, pathSpacing: i = 1, pathOffset: o = 0, ...a }, l, u, c) { if (Zf(e, a, u), l) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; const { attrs: d, style: f } = e; d.transform && (f.transform = d.transform, delete d.transform), (f.transform || d.transformOrigin) && (f.transformOrigin = d.transformOrigin ?? "50% 50%", delete d.transformOrigin), f.transform && (f.transformBox = (c == null ? void 0 : c.transformBox) ?? "fill-box", delete d.transformBox); for (const h of HR) d[h] !== void 0 && (f[h] = d[h], delete d[h]); t !== void 0 && (d.x = t), n !== void 0 && (d.y = n), r !== void 0 && (d.scale = r), s !== void 0 && WR(d, s, i, o, !1) } const F1 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]), L1 = e => typeof e == "string" && e.toLowerCase() === "svg"; function KR(e, t, n, r) { M1(e, t, void 0, r); for (const s in t.attrs) e.setAttribute(F1.has(s) ? s : Hf(s), t.attrs[s]) } function I1(e, t, n) { const r = Jf(e, t, n); for (const s in e) if (Be(e[s]) || Be(t[s])) { const i = Gs.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s; r[i] = e[s] } return r } class GR extends k1 { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Ee } getBaseTargetFromProps(t, n) { return t[n] } readValueFromInstance(t, n) { if (Xs.has(n)) { const r = g1(n); return r && r.default || 0 } return n = F1.has(n) ? n : Hf(n), t.getAttribute(n) } scrapeMotionValuesFromProps(t, n, r) { return I1(t, n, r) } build(t, n, r) { O1(t, n, this.isSVGTag, r.transformTemplate, r.style) } renderInstance(t, n, r, s) { KR(t, n, r, s) } mount(t) { this.isSVGTag = L1(t.tagName), super.mount(t) } } const XR = qf.length; function V1(e) { if (!e) return; if (!e.isControllingVariants) { const n = e.parent ? V1(e.parent) || {} : {}; return e.props.initial !== void 0 && (n.initial = e.props.initial), n } const t = {}; for (let n = 0; n < XR; n++) { const r = qf[n], s = e.props[r]; (qi(s) || s === !1) && (t[r] = s) } return t } function _1(e, t) { if (!Array.isArray(t)) return !1; const n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } const QR = [...Yf].reverse(), YR = Yf.length; function qR(e) { return t => Promise.all(t.map(({ animation: n, options: r }) => XA(e, n, r))) } function ZR(e) { let t = qR(e), n = Fm(), r = !0; const s = l => (u, c) => { var f; const d = ws(e, c, l === "exit" ? (f = e.presenceContext) == null ? void 0 : f.custom : void 0); if (d) { const { transition: h, transitionEnd: x, ...y } = d; u = { ...u, ...y, ...x } } return u }; function i(l) { t = l(e) } function o(l) { const { props: u } = e, c = V1(e.parent) || {}, d = [], f = new Set; let h = {}, x = 1 / 0; for (let b = 0; b < YR; b++) { const p = QR[b], m = n[p], v = u[p] !== void 0 ? u[p] : c[p], S = qi(v), T = p === l ? m.isActive : null; T === !1 && (x = b); let C = v === c[p] && v !== u[p] && S; if (C && r && e.manuallyAnimateOnMount && (C = !1), m.protectedKeys = { ...h }, !m.isActive && T === null || !v && !m.prevProp || Rl(v) || typeof v == "boolean") continue; if (p === "exit" && m.isActive && T !== !0) { m.prevResolvedValues && (h = { ...h, ...m.prevResolvedValues }); continue } const E = JR(m.prevProp, v); let P = E || p === l && m.isActive && !C && S || b > x && S, N = !1; const j = Array.isArray(v) ? v : [v]; let z = j.reduce(s(p), {}); T === !1 && (z = {}); const { prevResolvedValues: L = {} } = m, H = { ...L, ...z }, O = V => { P = !0, f.has(V) && (N = !0, f.delete(V)), m.needsAnimating[V] = !0; const k = e.getValue(V); k && (k.liveStyle = !1) }; for (const V in H) { const k = z[V], R = L[V]; if (h.hasOwnProperty(V)) continue; let F = !1; td(k) && td(R) ? F = !_1(k, R) : F = k !== R, F ? k != null ? O(V) : f.add(V) : k !== void 0 && f.has(V) ? O(V) : m.protectedKeys[V] = !0 } m.prevProp = v, m.prevResolvedValues = z, m.isActive && (h = { ...h, ...z }), r && e.blockInitialAnimation && (P = !1); const K = C && E; P && (!K || N) && d.push(...j.map(V => { const k = { type: p }; if (typeof V == "string" && r && !K && e.manuallyAnimateOnMount && e.parent) { const { parent: R } = e, F = ws(R, V); if (R.enteringChildren && F) { const { delayChildren: W } = F.transition || {}; k.delay = a1(R.enteringChildren, e, W) } } return { animation: V, options: k } })) } if (f.size) { const b = {}; if (typeof u.initial != "boolean") { const p = ws(e, Array.isArray(u.initial) ? u.initial[0] : u.initial); p && p.transition && (b.transition = p.transition) } f.forEach(p => { const m = e.getBaseTarget(p), v = e.getValue(p); v && (v.liveStyle = !0), b[p] = m ?? null }), d.push({ animation: b }) } let y = !!d.length; return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (y = !1), r = !1, y ? t(d) : Promise.resolve() } function a(l, u) { var d; if (n[l].isActive === u) return Promise.resolve(); (d = e.variantChildren) == null || d.forEach(f => { var h; return (h = f.animationState) == null ? void 0 : h.setActive(l, u) }), n[l].isActive = u; const c = o(l); for (const f in n) n[f].protectedKeys = {}; return c } return { animateChanges: o, setActive: a, setAnimateFunction: i, getState: () => n, reset: () => { n = Fm() } } } function JR(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !_1(t, e) : !1 } function mr(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function Fm() { return { animate: mr(!0), whileInView: mr(), whileHover: mr(), whileTap: mr(), whileDrag: mr(), whileFocus: mr(), exit: mr() } } function Lm(e, t) { e.min = t.min, e.max = t.max } function Mt(e, t) { Lm(e.x, t.x), Lm(e.y, t.y) } function Im(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } const z1 = 1e-4, eN = 1 - z1, tN = 1 + z1, B1 = .01, nN = 0 - B1, rN = 0 + B1; function Ge(e) { return e.max - e.min } function sN(e, t, n) { return Math.abs(e - t) <= n } function Vm(e, t, n, r = .5) { e.origin = r, e.originPoint = ge(t.min, t.max, e.origin), e.scale = Ge(n) / Ge(t), e.translate = ge(n.min, n.max, e.origin) - e.originPoint, (e.scale >= eN && e.scale <= tN || isNaN(e.scale)) && (e.scale = 1), (e.translate >= nN && e.translate <= rN || isNaN(e.translate)) && (e.translate = 0) } function Ei(e, t, n, r) { Vm(e.x, t.x, n.x, r ? r.originX : void 0), Vm(e.y, t.y, n.y, r ? r.originY : void 0) } function _m(e, t, n) { e.min = n.min + t.min, e.max = e.min + Ge(t) } function iN(e, t, n) { _m(e.x, t.x, n.x), _m(e.y, t.y, n.y) } function zm(e, t, n) { e.min = t.min - n.min, e.max = e.min + Ge(t) } function Qa(e, t, n) { zm(e.x, t.x, n.x), zm(e.y, t.y, n.y) } function Bm(e, t, n, r, s) { return e -= t, e = Xa(e, 1 / n, r), s !== void 0 && (e = Xa(e, 1 / s, r)), e } function oN(e, t = 0, n = 1, r = .5, s, i = e, o = e) { if (rn.test(t) && (t = parseFloat(t), t = ge(o.min, o.max, t / 100) - o.min), typeof t != "number") return; let a = ge(i.min, i.max, r); e === i && (a -= t), e.min = Bm(e.min, t, n, a, s), e.max = Bm(e.max, t, n, a, s) } function $m(e, t, [n, r, s], i, o) { oN(e, t[n], t[r], t[s], t.scale, i, o) } const aN = ["x", "scaleX", "originX"], lN = ["y", "scaleY", "originY"]; function Um(e, t, n, r) { $m(e.x, t, aN, n ? n.x : void 0, r ? r.x : void 0), $m(e.y, t, lN, n ? n.y : void 0, r ? r.y : void 0) } function Wm(e) { return e.translate === 0 && e.scale === 1 } function $1(e) { return Wm(e.x) && Wm(e.y) } function Hm(e, t) { return e.min === t.min && e.max === t.max } function uN(e, t) { return Hm(e.x, t.x) && Hm(e.y, t.y) } function Km(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function U1(e, t) { return Km(e.x, t.x) && Km(e.y, t.y) } function Gm(e) { return Ge(e.x) / Ge(e.y) } function Xm(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } function Xt(e) { return [e("x"), e("y")] } function cN(e, t, n) { let r = ""; const s = e.x.translate / t.x, i = e.y.translate / t.y, o = (n == null ? void 0 : n.z) || 0; if ((s || i || o) && (r = `translate3d(${s}px, ${i}px, ${o}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) { const { transformPerspective: u, rotate: c, rotateX: d, rotateY: f, skewX: h, skewY: x } = n; u && (r = `perspective(${u}px) ${r}`), c && (r += `rotate(${c}deg) `), d && (r += `rotateX(${d}deg) `), f && (r += `rotateY(${f}deg) `), h && (r += `skewX(${h}deg) `), x && (r += `skewY(${x}deg) `) } const a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none" } const W1 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], dN = W1.length, Qm = e => typeof e == "string" ? parseFloat(e) : e, Ym = e => typeof e == "number" || _.test(e); function fN(e, t, n, r, s, i) { s ? (e.opacity = ge(0, n.opacity ?? 1, hN(r)), e.opacityExit = ge(t.opacity ?? 1, 0, pN(r))) : i && (e.opacity = ge(t.opacity ?? 1, n.opacity ?? 1, r)); for (let o = 0; o < dN; o++) { const a = `border${W1[o]}Radius`; let l = qm(t, a), u = qm(n, a); if (l === void 0 && u === void 0) continue; l || (l = 0), u || (u = 0), l === 0 || u === 0 || Ym(l) === Ym(u) ? (e[a] = Math.max(ge(Qm(l), Qm(u), r), 0), (rn.test(u) || rn.test(l)) && (e[a] += "%")) : e[a] = u } (t.rotate || n.rotate) && (e.rotate = ge(t.rotate || 0, n.rotate || 0, r)) } function qm(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } const hN = H1(0, .5, Ix), pN = H1(.5, .95, Tt); function H1(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(Xi(e, t, r)) } function mN(e, t, n) { const r = Be(e) ? e : _s(e); return r.start(Uf("", r, t, n)), r.animation } function Zi(e, t, n, r = { passive: !0 }) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } const gN = (e, t) => e.depth - t.depth; class yN { constructor() { this.children = [], this.isDirty = !1 } add(t) { Af(this.children, t), this.isDirty = !0 } remove(t) { Ua(this.children, t), this.isDirty = !0 } forEach(t) { this.isDirty && this.children.sort(gN), this.isDirty = !1, this.children.forEach(t) } } function vN(e, t) { const n = Ke.now(), r = ({ timestamp: s }) => { const i = s - n; i >= t && (ar(r), e(i - t)) }; return oe.setup(r, !0), () => ar(r) } function ca(e) { return Be(e) ? e.get() : e } class xN { constructor() { this.members = [] } add(t) { Af(this.members, t); for (let n = this.members.length - 1; n >= 0; n--) { const r = this.members[n]; if (r === t || r === this.lead || r === this.prevLead) continue; const s = r.instance; s && s.isConnected === !1 && r.isPresent !== !1 && !r.snapshot && Ua(this.members, r) } t.scheduleRender() } remove(t) { if (Ua(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(t) { const n = this.members.findIndex(s => t === s); if (n === 0) return !1; let r; for (let s = n; s >= 0; s--) { const i = this.members[s], o = i.instance; if (i.isPresent !== !1 && (!o || o.isConnected !== !1)) { r = i; break } } return r ? (this.promote(r), !0) : !1 } promote(t, n) { const r = this.lead; if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) { r.instance && r.scheduleRender(), t.scheduleRender(); const s = r.options.layoutDependency, i = t.options.layoutDependency; if (!(s !== void 0 && i !== void 0 && s === i)) { const l = r.instance; l && l.isConnected === !1 && !r.snapshot || (t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0)) } const { crossfade: a } = t.options; a === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(t => { const { options: n, resumingFrom: r } = t; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(t => { t.instance && t.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } const da = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }, Eu = ["", "X", "Y", "Z"], wN = 1e3; let bN = 0; function Pu(e, t, n, r) { const { latestValues: s } = t; s[e] && (n[e] = s[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function K1(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; const { visualElement: t } = e.options; if (!t) return; const n = f1(t); if (window.MotionHasOptimisedAnimation(n, "transform")) { const { layout: s, layoutId: i } = e.options; window.MotionCancelOptimisedAnimation(n, "transform", oe, !(s || i)) } const { parent: r } = e; r && !r.hasCheckedOptimisedAppear && K1(r) } function G1({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: s }) { return class { constructor(o = {}, a = t == null ? void 0 : t()) { this.id = bN++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(CN), this.nodes.forEach(AN), this.nodes.forEach(RN), this.nodes.forEach(EN) }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new yN) } addEventListener(o, a) { return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Nf), this.eventHandlers.get(o).add(a) } notifyListeners(o, ...a) { const l = this.eventHandlers.get(o); l && l.notify(...a) } hasListeners(o) { return this.eventHandlers.has(o) } mount(o) { if (this.instance) return; this.isSVG = Qf(o) && !TR(o), this.instance = o; const { layoutId: a, layout: l, visualElement: u } = this.options; if (u && !u.current && u.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0), e) { let c, d = 0; const f = () => this.root.updateBlockedByResize = !1; oe.read(() => { d = window.innerWidth }), e(o, () => { const h = window.innerWidth; h !== d && (d = h, this.root.updateBlockedByResize = !0, c && c(), c = vN(f, 250), da.hasAnimatedSinceResize && (da.hasAnimatedSinceResize = !1, this.nodes.forEach(eg))) }) } a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && u && (a || l) && this.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: d, hasRelativeLayoutChanged: f, layout: h }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const x = this.options.transition || u.getDefaultTransition() || ON, { onLayoutAnimationStart: y, onLayoutAnimationComplete: b } = u.getProps(), p = !this.targetLayout || !U1(this.targetLayout, h), m = !d && f; if (this.options.layoutRoot || this.resumeFrom || m || d && (p || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const v = { ...$f(x, "layout"), onPlay: y, onComplete: b }; (u.shouldReduceMotion || this.options.layoutRoot) && (v.delay = 0, v.type = !1), this.startAnimation(v), this.setAnimationOrigin(c, m) } else d || eg(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = h }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const o = this.getStack(); o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), ar(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(NN), this.animationId++) } getTransformTemplate() { const { visualElement: o } = this.options; return o && o.getProps().transformTemplate } willUpdate(o = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && K1(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let c = 0; c < this.path.length; c++) { const d = this.path[c]; d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1) } const { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; const u = this.getTransformTemplate(); this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Zm); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach(Jm); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(kN), this.nodes.forEach(SN), this.nodes.forEach(TN)) : this.nodes.forEach(Jm), this.clearAllSnapshots(); const a = Ke.now(); De.delta = on(0, 1e3 / 60, a - De.timestamp), De.timestamp = a, De.isProcessing = !0, yu.update.process(De), yu.preRender.process(De), yu.render.process(De), De.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Gf.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(PN), this.sharedNodes.forEach(jN) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, oe.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { oe.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Ge(this.snapshot.measuredBox.x) && !Ge(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); const o = this.layout; this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = Ee(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0) } updateScroll(o = "measure") { let a = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && this.instance) { const l = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: o, isRoot: l, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : l } } } resetTransform() { if (!s) return; const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !$1(this.projectionDelta), l = this.getTransformTemplate(), u = l ? l(this.latestValues, "") : void 0, c = u !== this.prevTransformTemplateValue; o && this.instance && (a || vr(this.latestValues) || c) && (s(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender()) } measure(o = !0) { const a = this.measurePageBox(); let l = this.removeElementScroll(a); return o && (l = this.removeTransform(l)), FN(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { var u; const { visualElement: o } = this.options; if (!o) return Ee(); const a = o.measureViewportBox(); if (!(((u = this.scroll) == null ? void 0 : u.wasRoot) || this.path.some(LN))) { const { scroll: c } = this.root; c && (us(a.x, c.offset.x), us(a.y, c.offset.y)) } return a } removeElementScroll(o) { var l; const a = Ee(); if (Mt(a, o), (l = this.scroll) != null && l.wasRoot) return a; for (let u = 0; u < this.path.length; u++) { const c = this.path[u], { scroll: d, options: f } = c; c !== this.root && d && f.layoutScroll && (d.wasRoot && Mt(a, o), us(a.x, d.offset.x), us(a.y, d.offset.y)) } return a } applyTransform(o, a = !1) { const l = Ee(); Mt(l, o); for (let u = 0; u < this.path.length; u++) { const c = this.path[u]; !a && c.options.layoutScroll && c.scroll && c !== c.root && cs(l, { x: -c.scroll.offset.x, y: -c.scroll.offset.y }), vr(c.latestValues) && cs(l, c.latestValues) } return vr(this.latestValues) && cs(l, this.latestValues), l } removeTransform(o) { const a = Ee(); Mt(a, o); for (let l = 0; l < this.path.length; l++) { const u = this.path[l]; if (!u.instance || !vr(u.latestValues)) continue; ad(u.latestValues) && u.updateSnapshot(); const c = Ee(), d = u.measurePageBox(); Mt(c, d), Um(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c) } return vr(this.latestValues) && Um(a, this.latestValues), a } setTargetDelta(o) { this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(o) { this.options = { ...this.options, ...o, crossfade: o.crossfade !== void 0 ? o.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== De.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(o = !1) { var h; const a = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty); const l = !!this.resumingFrom || this !== a; if (!(o || l && this.isSharedProjectionDirty || this.isProjectionDirty || (h = this.parent) != null && h.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: c, layoutId: d } = this.options; if (!this.layout || !(c || d)) return; this.resolvedRelativeTargetAt = De.timestamp; const f = this.getClosestProjectingParent(); f && this.linkedParentVersion !== f.layoutVersion && !f.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (f && f.layout ? this.createRelativeTarget(f, this.layout.layoutBox, f.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Ee(), this.targetWithTransforms = Ee()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), iN(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Mt(this.target, this.layout.layoutBox), N1(this.target, this.targetDelta)) : Mt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, f && !!f.resumingFrom == !!this.resumingFrom && !f.options.layoutScroll && f.target && this.animationProgress !== 1 ? this.createRelativeTarget(f, this.target, f.target) : this.relativeParent = this.relativeTarget = void 0)) } getClosestProjectingParent() { if (!(!this.parent || ad(this.parent.latestValues) || R1(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } createRelativeTarget(o, a, l) { this.relativeParent = o, this.linkedParentVersion = o.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ee(), this.relativeTargetOrigin = Ee(), Qa(this.relativeTargetOrigin, a, l), Mt(this.relativeTarget, this.relativeTargetOrigin) } removeRelativeTarget() { this.relativeParent = this.relativeTarget = void 0 } calcProjection() { var x; const o = this.getLead(), a = !!this.resumingFrom || this !== o; let l = !0; if ((this.isProjectionDirty || (x = this.parent) != null && x.isProjectionDirty) && (l = !1), a && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === De.timestamp && (l = !1), l) return; const { layout: u, layoutId: c } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || c)) return; Mt(this.layoutCorrected, this.layout.layoutBox); const d = this.treeScale.x, f = this.treeScale.y; OR(this.layoutCorrected, this.treeScale, this.path, a), o.layout && !o.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (o.target = o.layout.layoutBox, o.targetWithTransforms = Ee()); const { target: h } = o; if (!h) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Im(this.prevProjectionDelta.x, this.projectionDelta.x), Im(this.prevProjectionDelta.y, this.projectionDelta.y)), Ei(this.projectionDelta, this.layoutCorrected, h, this.latestValues), (this.treeScale.x !== d || this.treeScale.y !== f || !Xm(this.projectionDelta.x, this.prevProjectionDelta.x) || !Xm(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", h)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(o = !0) { var a; if ((a = this.options.visualElement) == null || a.scheduleRender(), o) { const l = this.getStack(); l && l.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = ls(), this.projectionDelta = ls(), this.projectionDeltaWithTransform = ls() } setAnimationOrigin(o, a = !1) { const l = this.snapshot, u = l ? l.latestValues : {}, c = { ...this.latestValues }, d = ls(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; const f = Ee(), h = l ? l.source : void 0, x = this.layout ? this.layout.source : void 0, y = h !== x, b = this.getStack(), p = !b || b.members.length <= 1, m = !!(y && !p && this.options.crossfade === !0 && !this.path.some(DN)); this.animationProgress = 0; let v; this.mixTargetDelta = S => { const T = S / 1e3; tg(d.x, o.x, T), tg(d.y, o.y, T), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Qa(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), MN(this.relativeTarget, this.relativeTargetOrigin, f, T), v && uN(this.relativeTarget, v) && (this.isProjectionDirty = !1), v || (v = Ee()), Mt(v, this.relativeTarget)), y && (this.animationValues = c, fN(c, u, this.latestValues, T, m, p)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = T }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(o) { var a, l, u; this.notifyListeners("animationStart"), (a = this.currentAnimation) == null || a.stop(), (u = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) == null || u.stop(), this.pendingAnimation && (ar(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = oe.update(() => { da.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = _s(0)), this.currentAnimation = mN(this.motionValue, [0, 1e3], { ...o, velocity: 0, isSync: !0, onUpdate: c => { this.mixTargetDelta(c), o.onUpdate && o.onUpdate(c) }, onStop: () => { }, onComplete: () => { o.onComplete && o.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const o = this.getStack(); o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(wN), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const o = this.getLead(); let { targetWithTransforms: a, target: l, layout: u, latestValues: c } = o; if (!(!a || !l || !u)) { if (this !== o && this.layout && u && X1(this.options.animationType, this.layout.layoutBox, u.layoutBox)) { l = this.target || Ee(); const d = Ge(this.layout.layoutBox.x); l.x.min = o.target.x.min, l.x.max = l.x.min + d; const f = Ge(this.layout.layoutBox.y); l.y.min = o.target.y.min, l.y.max = l.y.min + f } Mt(a, l), cs(a, c), Ei(this.projectionDeltaWithTransform, this.layoutCorrected, a, c) } } registerSharedNode(o, a) { this.sharedNodes.has(o) || this.sharedNodes.set(o, new xN), this.sharedNodes.get(o).add(a); const u = a.options.initialPromotionConfig; a.promote({ transition: u ? u.transition : void 0, preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { const o = this.getStack(); return o ? o.lead === this : !0 } getLead() { var a; const { layoutId: o } = this.options; return o ? ((a = this.getStack()) == null ? void 0 : a.lead) || this : this } getPrevLead() { var a; const { layoutId: o } = this.options; return o ? (a = this.getStack()) == null ? void 0 : a.prevLead : void 0 } getStack() { const { layoutId: o } = this.options; if (o) return this.root.sharedNodes.get(o) } promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) { const u = this.getStack(); u && u.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { const o = this.getStack(); return o ? o.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: o } = this.options; if (!o) return; let a = !1; const { latestValues: l } = o; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; const u = {}; l.z && Pu("z", o, u, this.animationValues); for (let c = 0; c < Eu.length; c++)Pu(`rotate${Eu[c]}`, o, u, this.animationValues), Pu(`skew${Eu[c]}`, o, u, this.animationValues); o.render(); for (const c in u) o.setStaticValue(c, u[c]), this.animationValues && (this.animationValues[c] = u[c]); o.scheduleRender() } applyProjectionStyles(o, a) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { o.visibility = "hidden"; return } const l = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, o.visibility = "", o.opacity = "", o.pointerEvents = ca(a == null ? void 0 : a.pointerEvents) || "", o.transform = l ? l(this.latestValues, "") : "none"; return } const u = this.getLead(); if (!this.projectionDelta || !this.layout || !u.target) { this.options.layoutId && (o.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, o.pointerEvents = ca(a == null ? void 0 : a.pointerEvents) || ""), this.hasProjected && !vr(this.latestValues) && (o.transform = l ? l({}, "") : "none", this.hasProjected = !1); return } o.visibility = ""; const c = u.animationValues || u.latestValues; this.applyTransformsToTarget(); let d = cN(this.projectionDeltaWithTransform, this.treeScale, c); l && (d = l(c, d)), o.transform = d; const { x: f, y: h } = this.projectionDelta; o.transformOrigin = `${f.origin * 100}% ${h.origin * 100}% 0`, u.animationValues ? o.opacity = u === this ? c.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : c.opacityExit : o.opacity = u === this ? c.opacity !== void 0 ? c.opacity : "" : c.opacityExit !== void 0 ? c.opacityExit : 0; for (const x in ud) { if (c[x] === void 0) continue; const { correct: y, applyTo: b, isCSSVariable: p } = ud[x], m = d === "none" ? c[x] : y(c[x], u); if (b) { const v = b.length; for (let S = 0; S < v; S++)o[b[S]] = m } else p ? this.options.visualElement.renderState.vars[x] = m : o[x] = m } this.options.layoutId && (o.pointerEvents = u === this ? ca(a == null ? void 0 : a.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(o => { var a; return (a = o.currentAnimation) == null ? void 0 : a.stop() }), this.root.nodes.forEach(Zm), this.root.sharedNodes.clear() } } } function SN(e) { e.updateLayout() } function TN(e) { var n; const t = ((n = e.resumeFrom) == null ? void 0 : n.snapshot) || e.snapshot; if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) { const { layoutBox: r, measuredBox: s } = e.layout, { animationType: i } = e.options, o = t.source !== e.layout.source; i === "size" ? Xt(d => { const f = o ? t.measuredBox[d] : t.layoutBox[d], h = Ge(f); f.min = r[d].min, f.max = f.min + h }) : X1(i, t.layoutBox, r) && Xt(d => { const f = o ? t.measuredBox[d] : t.layoutBox[d], h = Ge(r[d]); f.max = f.min + h, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[d].max = e.relativeTarget[d].min + h) }); const a = ls(); Ei(a, r, t.layoutBox); const l = ls(); o ? Ei(l, e.applyTransform(s, !0), t.measuredBox) : Ei(l, r, t.layoutBox); const u = !$1(a); let c = !1; if (!e.resumeFrom) { const d = e.getClosestProjectingParent(); if (d && !d.resumeFrom) { const { snapshot: f, layout: h } = d; if (f && h) { const x = Ee(); Qa(x, t.layoutBox, f.layoutBox); const y = Ee(); Qa(y, r, h.layoutBox), U1(x, y) || (c = !0), d.options.layoutRoot && (e.relativeTarget = y, e.relativeTargetOrigin = x, e.relativeParent = d) } } } e.notifyListeners("didUpdate", { layout: r, snapshot: t, delta: l, layoutDelta: a, hasLayoutChanged: u, hasRelativeLayoutChanged: c }) } else if (e.isLead()) { const { onExitComplete: r } = e.options; r && r() } e.options.transition = void 0 } function CN(e) { e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function EN(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function PN(e) { e.clearSnapshot() } function Zm(e) { e.clearMeasurements() } function Jm(e) { e.isLayoutDirty = !1 } function kN(e) { const { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function eg(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function AN(e) { e.resolveTargetDelta() } function RN(e) { e.calcProjection() } function NN(e) { e.resetSkewAndRotation() } function jN(e) { e.removeLeadSnapshot() } function tg(e, t, n) { e.translate = ge(t.translate, 0, n), e.scale = ge(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function ng(e, t, n, r) { e.min = ge(t.min, n.min, r), e.max = ge(t.max, n.max, r) } function MN(e, t, n, r) { ng(e.x, t.x, n.x, r), ng(e.y, t.y, n.y, r) } function DN(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } const ON = { duration: .45, ease: [.4, 0, .1, 1] }, rg = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), sg = rg("applewebkit/") && !rg("chrome/") ? Math.round : Tt; function ig(e) { e.min = sg(e.min), e.max = sg(e.max) } function FN(e) { ig(e.x), ig(e.y) } function X1(e, t, n) { return e === "position" || e === "preserve-aspect" && !sN(Gm(t), Gm(n), .2) } function LN(e) { var t; return e !== e.root && ((t = e.scroll) == null ? void 0 : t.wasRoot) } const IN = G1({ attachResizeListener: (e, t) => Zi(e, "resize", t), measureScroll: () => { var e, t; return { x: document.documentElement.scrollLeft || ((e = document.body) == null ? void 0 : e.scrollLeft) || 0, y: document.documentElement.scrollTop || ((t = document.body) == null ? void 0 : t.scrollTop) || 0 } }, checkIsScrollRoot: () => !0 }), ku = { current: void 0 }, Q1 = G1({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!ku.current) { const e = new IN({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), ku.current = e } return ku.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed" }), eh = w.createContext({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }); function og(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function VN(...e) { return t => { let n = !1; const r = e.map(s => { const i = og(s, t); return !n && typeof i == "function" && (n = !0), i }); if (n) return () => { for (let s = 0; s < r.length; s++) { const i = r[s]; typeof i == "function" ? i() : og(e[s], null) } } } } function _N(...e) { return w.useCallback(VN(...e), e) } class zN extends w.Component { getSnapshotBeforeUpdate(t) { const n = this.props.childRef.current; if (n && t.isPresent && !this.props.isPresent && this.props.pop !== !1) { const r = n.offsetParent, s = id(r) && r.offsetWidth || 0, i = id(r) && r.offsetHeight || 0, o = this.props.sizeRef.current; o.height = n.offsetHeight || 0, o.width = n.offsetWidth || 0, o.top = n.offsetTop, o.left = n.offsetLeft, o.right = s - o.width - o.left, o.bottom = i - o.height - o.top } return null } componentDidUpdate() { } render() { return this.props.children } } function BN({ children: e, isPresent: t, anchorX: n, anchorY: r, root: s, pop: i }) {
  var f; const o = w.useId(), a = w.useRef(null), l = w.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0, bottom: 0 }), { nonce: u } = w.useContext(eh), c = ((f = e.props) == null ? void 0 : f.ref) ?? (e == null ? void 0 : e.ref), d = _N(a, c); return w.useInsertionEffect(() => {
    const { width: h, height: x, top: y, left: b, right: p, bottom: m } = l.current; if (t || i === !1 || !a.current || !h || !x) return; const v = n === "left" ? `left: ${b}` : `right: ${p}`, S = r === "bottom" ? `bottom: ${m}` : `top: ${y}`; a.current.dataset.motionPopId = o; const T = document.createElement("style"); u && (T.nonce = u); const C = s ?? document.head; return C.appendChild(T), T.sheet && T.sheet.insertRule(`
          [data-motion-pop-id="${o}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${x}px !important;
            ${v}px !important;
            ${S}px !important;
          }
        `), () => { C.contains(T) && C.removeChild(T) }
  }, [t]), g.jsx(zN, { isPresent: t, childRef: a, sizeRef: l, pop: i, children: i === !1 ? e : w.cloneElement(e, { ref: d }) })
} const $N = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: s, presenceAffectsLayout: i, mode: o, anchorX: a, anchorY: l, root: u }) => { const c = kf(UN), d = w.useId(); let f = !0, h = w.useMemo(() => (f = !1, { id: d, initial: t, isPresent: n, custom: s, onExitComplete: x => { c.set(x, !0); for (const y of c.values()) if (!y) return; r && r() }, register: x => (c.set(x, !1), () => c.delete(x)) }), [n, c, r]); return i && f && (h = { ...h }), w.useMemo(() => { c.forEach((x, y) => c.set(y, !1)) }, [n]), w.useEffect(() => { !n && !c.size && r && r() }, [n]), e = g.jsx(BN, { pop: o === "popLayout", isPresent: n, anchorX: a, anchorY: l, root: u, children: e }), g.jsx(kl.Provider, { value: h, children: e }) }; function UN() { return new Map } function Y1(e = !0) { const t = w.useContext(kl); if (t === null) return [!0, null]; const { isPresent: n, onExitComplete: r, register: s } = t, i = w.useId(); w.useEffect(() => { if (e) return s(i) }, [e]); const o = w.useCallback(() => e && r && r(i), [i, r, e]); return !n && r ? [!1, o] : [!0] } const Uo = e => e.key || ""; function ag(e) { const t = []; return w.Children.forEach(e, n => { w.isValidElement(n) && t.push(n) }), t } const jl = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, presenceAffectsLayout: s = !0, mode: i = "sync", propagate: o = !1, anchorX: a = "left", anchorY: l = "top", root: u }) => { const [c, d] = Y1(o), f = w.useMemo(() => ag(e), [e]), h = o && !c ? [] : f.map(Uo), x = w.useRef(!0), y = w.useRef(f), b = kf(() => new Map), p = w.useRef(new Set), [m, v] = w.useState(f), [S, T] = w.useState(f); Px(() => { x.current = !1, y.current = f; for (let P = 0; P < S.length; P++) { const N = Uo(S[P]); h.includes(N) ? (b.delete(N), p.current.delete(N)) : b.get(N) !== !0 && b.set(N, !1) } }, [S, h.length, h.join("-")]); const C = []; if (f !== m) { let P = [...f]; for (let N = 0; N < S.length; N++) { const j = S[N], z = Uo(j); h.includes(z) || (P.splice(N, 0, j), C.push(j)) } return i === "wait" && C.length && (P = C), T(ag(P)), v(f), null } const { forceRender: E } = w.useContext(Pf); return g.jsx(g.Fragment, { children: S.map(P => { const N = Uo(P), j = o && !c ? !1 : f === S || h.includes(N), z = () => { if (p.current.has(N)) return; if (p.current.add(N), b.has(N)) b.set(N, !0); else return; let L = !0; b.forEach(H => { H || (L = !1) }), L && (E == null || E(), T(y.current), o && (d == null || d()), r && r()) }; return g.jsx($N, { isPresent: j, initial: !x.current || n ? void 0 : !1, custom: t, presenceAffectsLayout: s, mode: i, root: u, onExitComplete: j ? void 0 : z, anchorX: a, anchorY: l, children: P }, N) }) }) }, q1 = w.createContext({ strict: !1 }), lg = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }; let ug = !1; function WN() { if (ug) return; const e = {}; for (const t in lg) e[t] = { isEnabled: n => lg[t].some(r => !!n[r]) }; P1(e), ug = !0 } function Z1() { return WN(), NR() } function HN(e) { const t = Z1(); for (const n in e) t[n] = { ...t[n], ...e[n] }; P1(t) } const KN = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "propagate", "ignoreStrict", "viewport"]); function Ya(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || KN.has(e) } let J1 = e => !Ya(e); function GN(e) { typeof e == "function" && (J1 = t => t.startsWith("on") ? !Ya(t) : e(t)) } try { GN(require("@emotion/is-prop-valid").default) } catch { } function XN(e, t, n) { const r = {}; for (const s in e) s === "values" && typeof e.values == "object" || (J1(s) || n === !0 && Ya(s) || !t && !Ya(s) || e.draggable && s.startsWith("onDrag")) && (r[s] = e[s]); return r } const Ml = w.createContext({}); function QN(e, t) { if (Nl(e)) { const { initial: n, animate: r } = e; return { initial: n === !1 || qi(n) ? n : void 0, animate: qi(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function YN(e) { const { initial: t, animate: n } = QN(e, w.useContext(Ml)); return w.useMemo(() => ({ initial: t, animate: n }), [cg(t), cg(n)]) } function cg(e) { return Array.isArray(e) ? e.join(" ") : e } const th = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function ew(e, t, n) { for (const r in t) !Be(t[r]) && !D1(r, n) && (e[r] = t[r]) } function qN({ transformTemplate: e }, t) { return w.useMemo(() => { const n = th(); return Zf(n, t, e), Object.assign({}, n.vars, n.style) }, [t]) } function ZN(e, t) { const n = e.style || {}, r = {}; return ew(r, n, e), Object.assign(r, qN(e, t)), r } function JN(e, t) { const n = {}, r = ZN(e, t); return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n } const tw = () => ({ ...th(), attrs: {} }); function e5(e, t, n, r) { const s = w.useMemo(() => { const i = tw(); return O1(i, t, L1(r), e.transformTemplate, e.style), { ...i.attrs, style: { ...i.style } } }, [t]); if (e.style) { const i = {}; ew(i, e.style, e), s.style = { ...i, ...s.style } } return s } const t5 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function nh(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(t5.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function n5(e, t, n, { latestValues: r }, s, i = !1, o) { const l = (o ?? nh(e) ? e5 : JN)(t, r, s, e), u = XN(t, typeof e == "string", i), c = e !== w.Fragment ? { ...u, ...l, ref: n } : {}, { children: d } = t, f = w.useMemo(() => Be(d) ? d.get() : d, [d]); return w.createElement(e, { ...c, children: f }) } function r5({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, s) { return { latestValues: s5(n, r, s, e), renderState: t() } } function s5(e, t, n, r) { const s = {}, i = r(e, {}); for (const f in i) s[f] = ca(i[f]); let { initial: o, animate: a } = e; const l = Nl(e), u = C1(e); t && u && !l && e.inherit !== !1 && (o === void 0 && (o = t.initial), a === void 0 && (a = t.animate)); let c = n ? n.initial === !1 : !1; c = c || o === !1; const d = c ? a : o; if (d && typeof d != "boolean" && !Rl(d)) { const f = Array.isArray(d) ? d : [d]; for (let h = 0; h < f.length; h++) { const x = Wf(e, f[h]); if (x) { const { transitionEnd: y, transition: b, ...p } = x; for (const m in p) { let v = p[m]; if (Array.isArray(v)) { const S = c ? v.length - 1 : 0; v = v[S] } v !== null && (s[m] = v) } for (const m in y) s[m] = y[m] } } } return s } const nw = e => (t, n) => { const r = w.useContext(Ml), s = w.useContext(kl), i = () => r5(e, t, r, s); return n ? i() : kf(i) }, i5 = nw({ scrapeMotionValuesFromProps: Jf, createRenderState: th }), o5 = nw({ scrapeMotionValuesFromProps: I1, createRenderState: tw }), a5 = Symbol.for("motionComponentSymbol"); function l5(e, t, n) { const r = w.useRef(n); w.useInsertionEffect(() => { r.current = n }); const s = w.useRef(null); return w.useCallback(i => { var a; i && ((a = e.onMount) == null || a.call(e, i)), t && (i ? t.mount(i) : t.unmount()); const o = r.current; if (typeof o == "function") if (i) { const l = o(i); typeof l == "function" && (s.current = l) } else s.current ? (s.current(), s.current = null) : o(i); else o && (o.current = i) }, [t]) } const rw = w.createContext({}); function Gr(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function u5(e, t, n, r, s, i) { var v, S; const { visualElement: o } = w.useContext(Ml), a = w.useContext(q1), l = w.useContext(kl), u = w.useContext(eh), c = u.reducedMotion, d = u.skipAnimations, f = w.useRef(null), h = w.useRef(!1); r = r || a.renderer, !f.current && r && (f.current = r(e, { visualState: t, parent: o, props: n, presenceContext: l, blockInitialAnimation: l ? l.initial === !1 : !1, reducedMotionConfig: c, skipAnimations: d, isSVG: i }), h.current && f.current && (f.current.manuallyAnimateOnMount = !0)); const x = f.current, y = w.useContext(rw); x && !x.projection && s && (x.type === "html" || x.type === "svg") && c5(f.current, n, s, y); const b = w.useRef(!1); w.useInsertionEffect(() => { x && b.current && x.update(n, l) }); const p = n[d1], m = w.useRef(!!p && !((v = window.MotionHandoffIsComplete) != null && v.call(window, p)) && ((S = window.MotionHasOptimisedAnimation) == null ? void 0 : S.call(window, p))); return Px(() => { h.current = !0, x && (b.current = !0, window.MotionIsMounted = !0, x.updateFeatures(), x.scheduleRenderMicrotask(), m.current && x.animationState && x.animationState.animateChanges()) }), w.useEffect(() => { x && (!m.current && x.animationState && x.animationState.animateChanges(), m.current && (queueMicrotask(() => { var T; (T = window.MotionHandoffMarkAsComplete) == null || T.call(window, p) }), m.current = !1), x.enteringChildren = void 0) }), x } function c5(e, t, n, r) { const { layoutId: s, layout: i, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: u, layoutCrossfade: c } = t; e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : sw(e.parent)), e.projection.setOptions({ layoutId: s, layout: i, alwaysMeasureLayout: !!o || a && Gr(a), visualElement: e, animationType: typeof i == "string" ? i : "both", initialPromotionConfig: r, crossfade: c, layoutScroll: l, layoutRoot: u }) } function sw(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : sw(e.parent) } function Au(e, { forwardMotionProps: t = !1, type: n } = {}, r, s) { r && HN(r); const i = n ? n === "svg" : nh(e), o = i ? o5 : i5; function a(u, c) { let d; const f = { ...w.useContext(eh), ...u, layoutId: d5(u) }, { isStatic: h } = f, x = YN(u), y = o(u, h); if (!h && Ex) { f5(); const b = h5(f); d = b.MeasureLayout, x.visualElement = u5(e, y, f, s, b.ProjectionNode, i) } return g.jsxs(Ml.Provider, { value: x, children: [d && x.visualElement ? g.jsx(d, { visualElement: x.visualElement, ...f }) : null, n5(e, u, l5(y, x.visualElement, c), y, h, t, i)] }) } a.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`; const l = w.forwardRef(a); return l[a5] = e, l } function d5({ layoutId: e }) { const t = w.useContext(Pf).id; return t && e !== void 0 ? t + "-" + e : e } function f5(e, t) { w.useContext(q1).strict } function h5(e) { const t = Z1(), { drag: n, layout: r } = t; if (!n && !r) return {}; const s = { ...n, ...r }; return { MeasureLayout: n != null && n.isEnabled(e) || r != null && r.isEnabled(e) ? s.MeasureLayout : void 0, ProjectionNode: s.ProjectionNode } } function p5(e, t) { if (typeof Proxy > "u") return Au; const n = new Map, r = (i, o) => Au(i, o, e, t), s = (i, o) => r(i, o); return new Proxy(s, { get: (i, o) => o === "create" ? r : (n.has(o) || n.set(o, Au(o, void 0, e, t)), n.get(o)) }) } const m5 = (e, t) => t.isSVG ?? nh(e) ? new GR(t) : new BR(t, { allowProjection: e !== w.Fragment }); class g5 extends fr { constructor(t) { super(t), t.animationState || (t.animationState = ZR(t)) } updateAnimationControlsSubscription() { const { animate: t } = this.node.getProps(); Rl(t) && (this.unmountControls = t.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; t !== n && this.updateAnimationControlsSubscription() } unmount() { var t; this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this) } } let y5 = 0; class v5 extends fr { constructor() { super(...arguments), this.id = y5++ } update() { if (!this.node.presenceContext) return; const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || t === r) return; const s = this.node.animationState.setActive("exit", !t); n && !t && s.then(() => { n(this.id) }) } mount() { const { register: t, onExitComplete: n } = this.node.presenceContext || {}; n && n(this.id), t && (this.unmount = t(this.id)) } unmount() { } } const x5 = { animation: { Feature: g5 }, exit: { Feature: v5 } }; function ho(e) { return { point: { x: e.pageX, y: e.pageY } } } const w5 = e => t => Xf(t) && e(t, ho(t)); function Pi(e, t, n, r) { return Zi(e, t, w5(n), r) } const iw = ({ current: e }) => e ? e.ownerDocument.defaultView : null, dg = (e, t) => Math.abs(e - t); function b5(e, t) { const n = dg(e.x, t.x), r = dg(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) } const fg = new Set(["auto", "scroll"]); class ow { constructor(t, n, { transformPagePoint: r, contextWindow: s = window, dragSnapToOrigin: i = !1, distanceThreshold: o = 3, element: a } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = new Map, this.removeScrollListeners = null, this.onElementScroll = h => { this.handleScroll(h.target) }, this.onWindowScroll = () => { this.handleScroll(window) }, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const h = Nu(this.lastMoveEventInfo, this.history), x = this.startEvent !== null, y = b5(h.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!x && !y) return; const { point: b } = h, { timestamp: p } = De; this.history.push({ ...b, timestamp: p }); const { onStart: m, onMove: v } = this.handlers; x || (m && m(this.lastMoveEvent, h), this.startEvent = this.lastMoveEvent), v && v(this.lastMoveEvent, h) }, this.handlePointerMove = (h, x) => { this.lastMoveEvent = h, this.lastMoveEventInfo = Ru(x, this.transformPagePoint), oe.update(this.updatePoint, !0) }, this.handlePointerUp = (h, x) => { this.end(); const { onEnd: y, onSessionEnd: b, resumeAnimation: p } = this.handlers; if ((this.dragSnapToOrigin || !this.startEvent) && p && p(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const m = Nu(h.type === "pointercancel" ? this.lastMoveEventInfo : Ru(x, this.transformPagePoint), this.history); this.startEvent && y && y(h, m), b && b(h, m) }, !Xf(t)) return; this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = r, this.distanceThreshold = o, this.contextWindow = s || window; const l = ho(t), u = Ru(l, this.transformPagePoint), { point: c } = u, { timestamp: d } = De; this.history = [{ ...c, timestamp: d }]; const { onSessionStart: f } = n; f && f(t, Nu(u, this.history)), this.removeListeners = uo(Pi(this.contextWindow, "pointermove", this.handlePointerMove), Pi(this.contextWindow, "pointerup", this.handlePointerUp), Pi(this.contextWindow, "pointercancel", this.handlePointerUp)), a && this.startScrollTracking(a) } startScrollTracking(t) { let n = t.parentElement; for (; n;) { const r = getComputedStyle(n); (fg.has(r.overflowX) || fg.has(r.overflowY)) && this.scrollPositions.set(n, { x: n.scrollLeft, y: n.scrollTop }), n = n.parentElement } this.scrollPositions.set(window, { x: window.scrollX, y: window.scrollY }), window.addEventListener("scroll", this.onElementScroll, { capture: !0, passive: !0 }), window.addEventListener("scroll", this.onWindowScroll, { passive: !0 }), this.removeScrollListeners = () => { window.removeEventListener("scroll", this.onElementScroll, { capture: !0 }), window.removeEventListener("scroll", this.onWindowScroll) } } handleScroll(t) { const n = this.scrollPositions.get(t); if (!n) return; const r = t === window, s = r ? { x: window.scrollX, y: window.scrollY } : { x: t.scrollLeft, y: t.scrollTop }, i = { x: s.x - n.x, y: s.y - n.y }; i.x === 0 && i.y === 0 || (r ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += i.x, this.lastMoveEventInfo.point.y += i.y) : this.history.length > 0 && (this.history[0].x -= i.x, this.history[0].y -= i.y), this.scrollPositions.set(t, s), oe.update(this.updatePoint, !0)) } updateHandlers(t) { this.handlers = t } end() { this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), ar(this.updatePoint) } } function Ru(e, t) { return t ? { point: t(e.point) } : e } function hg(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function Nu({ point: e }, t) { return { point: e, delta: hg(e, aw(t)), offset: hg(e, S5(t)), velocity: T5(t, .1) } } function S5(e) { return e[0] } function aw(e) { return e[e.length - 1] } function T5(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null; const s = aw(e); for (; n >= 0 && (r = e[n], !(s.timestamp - r.timestamp > Ct(t)));)n--; if (!r) return { x: 0, y: 0 }; r === e[0] && e.length > 2 && s.timestamp - r.timestamp > Ct(t) * 2 && (r = e[1]); const i = bt(s.timestamp - r.timestamp); if (i === 0) return { x: 0, y: 0 }; const o = { x: (s.x - r.x) / i, y: (s.y - r.y) / i }; return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o } function C5(e, { min: t, max: n }, r) { return t !== void 0 && e < t ? e = r ? ge(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? ge(n, e, r.max) : Math.min(e, n)), e } function pg(e, t, n) { return { min: t !== void 0 ? e.min + t : void 0, max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0 } } function E5(e, { top: t, left: n, bottom: r, right: s }) { return { x: pg(e.x, n, s), y: pg(e.y, t, r) } } function mg(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } function P5(e, t) { return { x: mg(e.x, t.x), y: mg(e.y, t.y) } } function k5(e, t) { let n = .5; const r = Ge(e), s = Ge(t); return s > r ? n = Xi(t.min, t.max - r, e.min) : r > s && (n = Xi(e.min, e.max - s, t.min)), on(0, 1, n) } function A5(e, t) { const n = {}; return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n } const cd = .35; function R5(e = cd) { return e === !1 ? e = 0 : e === !0 && (e = cd), { x: gg(e, "left", "right"), y: gg(e, "top", "bottom") } } function gg(e, t, n) { return { min: yg(e, t), max: yg(e, n) } } function yg(e, t) { return typeof e == "number" ? e : e[t] || 0 } const N5 = new WeakMap; class j5 { constructor(t) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Ee(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t } start(t, { snapToCursor: n = !1, distanceThreshold: r } = {}) { const { presenceContext: s } = this.visualElement; if (s && s.isPresent === !1) return; const i = d => { n && this.snapToCursor(ho(d).point), this.stopAnimation() }, o = (d, f) => { const { drag: h, dragPropagation: x, onDragStart: y } = this.getProps(); if (h && !x && (this.openDragLock && this.openDragLock(), this.openDragLock = oR(h), !this.openDragLock)) return; this.latestPointerEvent = d, this.latestPanInfo = f, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Xt(p => { let m = this.getAxisMotionValue(p).get() || 0; if (rn.test(m)) { const { projection: v } = this.visualElement; if (v && v.layout) { const S = v.layout.layoutBox[p]; S && (m = Ge(S) * (parseFloat(m) / 100)) } } this.originPoint[p] = m }), y && oe.update(() => y(d, f), !1, !0), nd(this.visualElement, "transform"); const { animationState: b } = this.visualElement; b && b.setActive("whileDrag", !0) }, a = (d, f) => { this.latestPointerEvent = d, this.latestPanInfo = f; const { dragPropagation: h, dragDirectionLock: x, onDirectionLock: y, onDrag: b } = this.getProps(); if (!h && !this.openDragLock) return; const { offset: p } = f; if (x && this.currentDirection === null) { this.currentDirection = D5(p), this.currentDirection !== null && y && y(this.currentDirection); return } this.updateAxis("x", f.point, p), this.updateAxis("y", f.point, p), this.visualElement.render(), b && oe.update(() => b(d, f), !1, !0) }, l = (d, f) => { this.latestPointerEvent = d, this.latestPanInfo = f, this.stop(d, f), this.latestPointerEvent = null, this.latestPanInfo = null }, u = () => { const { dragSnapToOrigin: d } = this.getProps(); (d || this.constraints) && this.startAnimation({ x: 0, y: 0 }) }, { dragSnapToOrigin: c } = this.getProps(); this.panSession = new ow(t, { onSessionStart: i, onStart: o, onMove: a, onSessionEnd: l, resumeAnimation: u }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: c, distanceThreshold: r, contextWindow: iw(this.visualElement), element: this.visualElement.current }) } stop(t, n) { const r = t || this.latestPointerEvent, s = n || this.latestPanInfo, i = this.isDragging; if (this.cancel(), !i || !s || !r) return; const { velocity: o } = s; this.startAnimation(o); const { onDragEnd: a } = this.getProps(); a && oe.postRender(() => a(r, s)) } cancel() { this.isDragging = !1; const { projection: t, animationState: n } = this.visualElement; t && (t.isAnimationBlocked = !1), this.endPanSession(); const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1) } endPanSession() { this.panSession && this.panSession.end(), this.panSession = void 0 } updateAxis(t, n, r) { const { drag: s } = this.getProps(); if (!r || !Wo(t, s, this.currentDirection)) return; const i = this.getAxisMotionValue(t); let o = this.originPoint[t] + r[t]; this.constraints && this.constraints[t] && (o = C5(o, this.constraints[t], this.elastic[t])), i.set(o) } resolveConstraints() { var i; const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (i = this.visualElement.projection) == null ? void 0 : i.layout, s = this.constraints; t && Gr(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = E5(r.layoutBox, t) : this.constraints = !1, this.elastic = R5(n), s !== this.constraints && !Gr(t) && r && this.constraints && !this.hasMutatedConstraints && Xt(o => { this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = A5(r.layoutBox[o], this.constraints[o])) }) } resolveRefConstraints() { const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps(); if (!t || !Gr(t)) return !1; const r = t.current; Vs(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref"); const { projection: s } = this.visualElement; if (!s || !s.layout) return !1; const i = FR(r, s.root, this.visualElement.getTransformPagePoint()); let o = P5(s.layout.layoutBox, i); if (n) { const a = n(MR(o)); this.hasMutatedConstraints = !!a, a && (o = A1(a)) } return o } startAnimation(t) { const { drag: n, dragMomentum: r, dragElastic: s, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, u = Xt(c => { if (!Wo(c, n, this.currentDirection)) return; let d = l && l[c] || {}; o && (d = { min: 0, max: 0 }); const f = s ? 200 : 1e6, h = s ? 40 : 1e7, x = { type: "inertia", velocity: r ? t[c] : 0, bounceStiffness: f, bounceDamping: h, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i, ...d }; return this.startAxisValueAnimation(c, x) }); return Promise.all(u).then(a) } startAxisValueAnimation(t, n) { const r = this.getAxisMotionValue(t); return nd(this.visualElement, t), r.start(Uf(t, r, 0, n, this.visualElement, !1)) } stopAnimation() { Xt(t => this.getAxisMotionValue(t).stop()) } getAxisMotionValue(t) { const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), s = r[n]; return s || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0) } snapToCursor(t) { Xt(n => { const { drag: r } = this.getProps(); if (!Wo(n, r, this.currentDirection)) return; const { projection: s } = this.visualElement, i = this.getAxisMotionValue(n); if (s && s.layout) { const { min: o, max: a } = s.layout.layoutBox[n], l = i.get() || 0; i.set(t[n] - ge(o, a, .5) + l) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!Gr(n) || !r || !this.constraints) return; this.stopAnimation(); const s = { x: 0, y: 0 }; Xt(o => { const a = this.getAxisMotionValue(o); if (a && this.constraints !== !1) { const l = a.get(); s[o] = k5({ min: l, max: l }, this.constraints[o]) } }); const { transformTemplate: i } = this.visualElement.getProps(); this.visualElement.current.style.transform = i ? i({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.constraints = !1, this.resolveConstraints(), Xt(o => { if (!Wo(o, t, null)) return; const a = this.getAxisMotionValue(o), { min: l, max: u } = this.constraints[o]; a.set(ge(l, u, s[o])) }), this.visualElement.render() } addListeners() { if (!this.visualElement.current) return; N5.set(this.visualElement, this); const t = this.visualElement.current, n = Pi(t, "pointerdown", u => { const { drag: c, dragListener: d = !0 } = this.getProps(), f = u.target, h = f !== t && fR(f); c && d && !h && this.start(u) }); let r; const s = () => { const { dragConstraints: u } = this.getProps(); Gr(u) && u.current && (this.constraints = this.resolveRefConstraints(), r || (r = M5(t, u.current, () => this.scalePositionWithinConstraints()))) }, { projection: i } = this.visualElement, o = i.addEventListener("measure", s); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), oe.read(s); const a = Zi(window, "resize", () => this.scalePositionWithinConstraints()), l = i.addEventListener("didUpdate", ({ delta: u, hasLayoutChanged: c }) => { this.isDragging && c && (Xt(d => { const f = this.getAxisMotionValue(d); f && (this.originPoint[d] += u[d].translate, f.set(f.get() + u[d].translate)) }), this.visualElement.render()) }); return () => { a(), n(), o(), l && l(), r && r() } } getProps() { const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: s = !1, dragConstraints: i = !1, dragElastic: o = cd, dragMomentum: a = !0 } = t; return { ...t, drag: n, dragDirectionLock: r, dragPropagation: s, dragConstraints: i, dragElastic: o, dragMomentum: a } } } function vg(e) { let t = !0; return () => { if (t) { t = !1; return } e() } } function M5(e, t, n) { const r = Em(e, vg(n)), s = Em(t, vg(n)); return () => { r(), s() } } function Wo(e, t, n) { return (t === !0 || t === e) && (n === null || n === e) } function D5(e, t = 10) { let n = null; return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n } class O5 extends fr { constructor(t) { super(t), this.removeGroupControls = Tt, this.removeListeners = Tt, this.controls = new j5(t) } mount() { const { dragControls: t } = this.node.getProps(); t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Tt } update() { const { dragControls: t } = this.node.getProps(), { dragControls: n } = this.node.prevProps || {}; t !== n && (this.removeGroupControls(), t && (this.removeGroupControls = t.subscribe(this.controls))) } unmount() { this.removeGroupControls(), this.removeListeners(), this.controls.isDragging || this.controls.endPanSession() } } const ju = e => (t, n) => { e && oe.update(() => e(t, n), !1, !0) }; class F5 extends fr { constructor() { super(...arguments), this.removePointerDownListener = Tt } onPointerDown(t) { this.session = new ow(t, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: iw(this.node) }) } createPanHandlers() { const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: s } = this.node.getProps(); return { onSessionStart: ju(t), onStart: ju(n), onMove: ju(r), onEnd: (i, o) => { delete this.session, s && oe.postRender(() => s(i, o)) } } } mount() { this.removePointerDownListener = Pi(this.node.current, "pointerdown", t => this.onPointerDown(t)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } let Mu = !1; class L5 extends w.Component { componentDidMount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: s } = this.props, { projection: i } = t; i && (n.group && n.group.add(i), r && r.register && s && r.register(i), Mu && i.root.didUpdate(), i.addEventListener("animationComplete", () => { this.safeToRemove() }), i.setOptions({ ...i.options, layoutDependency: this.props.layoutDependency, onExitComplete: () => this.safeToRemove() })), da.hasEverUpdated = !0 } getSnapshotBeforeUpdate(t) { const { layoutDependency: n, visualElement: r, drag: s, isPresent: i } = this.props, { projection: o } = r; return o && (o.isPresent = i, t.layoutDependency !== n && o.setOptions({ ...o.options, layoutDependency: n }), Mu = !0, s || t.layoutDependency !== n || n === void 0 || t.isPresent !== i ? o.willUpdate() : this.safeToRemove(), t.isPresent !== i && (i ? o.promote() : o.relegate() || oe.postRender(() => { const a = o.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: t } = this.props.visualElement; t && (t.root.didUpdate(), Gf.postRender(() => { !t.currentAnimation && t.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: s } = t; Mu = !0, s && (s.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(s), r && r.deregister && r.deregister(s)) } safeToRemove() { const { safeToRemove: t } = this.props; t && t() } render() { return null } } function lw(e) { const [t, n] = Y1(), r = w.useContext(Pf); return g.jsx(L5, { ...e, layoutGroup: r, switchLayoutGroup: w.useContext(rw), isPresent: t, safeToRemove: n }) } const I5 = { pan: { Feature: F5 }, drag: { Feature: O5, ProjectionNode: Q1, MeasureLayout: lw } }; function xg(e, t, n) { const { props: r } = e; e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start"); const s = "onHover" + n, i = r[s]; i && oe.postRender(() => i(t, ho(t))) } class V5 extends fr { mount() { const { current: t } = this.node; t && (this.unmount = lR(t, (n, r) => (xg(this.node, r, "Start"), s => xg(this.node, s, "End")))) } unmount() { } } class _5 extends fr { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let t = !1; try { t = this.node.current.matches(":focus-visible") } catch { t = !0 } !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = uo(Zi(this.node.current, "focus", () => this.onFocus()), Zi(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function wg(e, t, n) { const { props: r } = e; if (e.current instanceof HTMLButtonElement && e.current.disabled) return; e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start"); const s = "onTap" + (n === "End" ? "" : n), i = r[s]; i && oe.postRender(() => i(t, ho(t))) } class z5 extends fr { mount() { const { current: t } = this.node; if (!t) return; const { globalTapTarget: n, propagate: r } = this.node.props; this.unmount = pR(t, (s, i) => (wg(this.node, i, "Start"), (o, { success: a }) => wg(this.node, o, a ? "End" : "Cancel")), { useGlobalTarget: n, stopPropagation: (r == null ? void 0 : r.tap) === !1 }) } unmount() { } } const dd = new WeakMap, Du = new WeakMap, B5 = e => { const t = dd.get(e.target); t && t(e) }, $5 = e => { e.forEach(B5) }; function U5({ root: e, ...t }) { const n = e || document; Du.has(n) || Du.set(n, {}); const r = Du.get(n), s = JSON.stringify(t); return r[s] || (r[s] = new IntersectionObserver($5, { root: e, ...t })), r[s] } function W5(e, t, n) { const r = U5(t); return dd.set(e, n), r.observe(e), () => { dd.delete(e), r.unobserve(e) } } const H5 = { some: 0, all: 1 }; class K5 extends fr { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: s = "some", once: i } = t, o = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof s == "number" ? s : H5[s] }, a = l => { const { isIntersecting: u } = l; if (this.isInView === u || (this.isInView = u, i && !u && this.hasEnteredView)) return; u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u); const { onViewportEnter: c, onViewportLeave: d } = this.node.getProps(), f = u ? c : d; f && f(l) }; return W5(this.node.current, o, a) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: t, prevProps: n } = this.node;["amount", "margin", "root"].some(G5(t, n)) && this.startObserver() } unmount() { } } function G5({ viewport: e = {} }, { viewport: t = {} } = {}) { return n => e[n] !== t[n] } const X5 = { inView: { Feature: K5 }, tap: { Feature: z5 }, focus: { Feature: _5 }, hover: { Feature: V5 } }, Q5 = { layout: { ProjectionNode: Q1, MeasureLayout: lw } }, Y5 = { ...x5, ...X5, ...I5, ...Q5 }, $ = p5(Y5, m5), rh = "/assets/tiger-header-B_edPfGx.png", q5 = ({ state: e }) => g.jsxs("div", { className: "relative flex justify-center", style: { marginBottom: "-20px", zIndex: 20 }, children: [(e === "win" || e === "mega-win") && g.jsx($.div, { className: "absolute rounded-full blur-3xl", style: { width: "200px", height: "200px", top: "-20px", background: "radial-gradient(circle, rgba(255,215,0,0.6), rgba(255,165,0,0.2), transparent)" }, animate: { opacity: [.4, .9, .4], scale: [.9, 1.1, .9] }, transition: { duration: .5, repeat: 1 / 0 } }), g.jsx($.img, { src: rh, alt: "Fortune Tiger", className: "relative z-10 object-contain drop-shadow-2xl", style: { width: "140px", height: "140px", borderRadius: "50%", objectFit: "cover" }, animate: e === "spinning" ? { y: [0, -5, 0], rotate: [0, -2, 2, 0], transition: { duration: .3, repeat: 1 / 0 } } : e === "win" ? { y: [0, -15, 0], scale: [1, 1.1, 1], transition: { duration: .5, repeat: 4 } } : e === "mega-win" ? { y: [0, -20, 0], scale: [1, 1.15, 1], rotate: [0, -5, 5, 0], transition: { duration: .4, repeat: 8 } } : e === "lose" ? { x: [0, -3, 3, 0], transition: { duration: .3 } } : { y: [0, -6, 0], transition: { duration: 2.5, repeat: 1 / 0, ease: "easeInOut" } } }), (e === "win" || e === "mega-win") && g.jsx("div", { className: "absolute inset-0 z-20 pointer-events-none", children: [...Array(8)].map((t, n) => g.jsx($.div, { className: "absolute text-base", style: { left: `${10 + Math.random() * 80}%`, top: `${5 + Math.random() * 90}%` }, animate: { opacity: [0, 1, 0], scale: [0, 1.3, 0], rotate: [0, 180] }, transition: { duration: .5, delay: n * .08, repeat: 1 / 0, repeatDelay: .2 }, children: "" }, n)) })] }), Z5 = "/assets/symbol-envelope-D5ceJwOz.png", J5 = "/assets/symbol-orange-bEnQEq05.png", ej = "/assets/symbol-gold-CIm17iqF.png", tj = "/assets/symbol-wild-DTDefusi.png", nj = "/assets/symbol-firecracker-DyAieH9i.png", rj = "/assets/symbol-coin-DG_hKLn3.png", sj = "/assets/symbol-bell-CqAPpeb4.png", ij = "/assets/symbol-lantern-fW2BQC8n.png", oj = "/assets/symbol-treasure-tx-6NoQd.png", fn = [{ id: "wild", image: tj, name: "Wild Tiger" }, { id: "envelope", image: Z5, name: "Envelope" }, { id: "orange", image: J5, name: "Laranja" }, { id: "gold", image: ej, name: "Ouro" }, { id: "firecracker", image: nj, name: "Fogos" }, { id: "coin", image: rj, name: "Moeda" }, { id: "bell", image: sj, name: "Sino" }, { id: "lantern", image: ij, name: "Lanterna" }, { id: "treasure", image: oj, name: "Tesouro" }], bg = fn.filter(e => ["wild", "gold", "envelope", "treasure", "lantern"].includes(e.id)), aj = [{ round: 1, win: !0, amount: 5e3, label: "GRANDE GANHO" }, { round: 2, win: !0, amount: 8e3, label: "GRANDE GANHO" }, { round: 3, win: !1, amount: 0, label: "" }, { round: 4, win: !0, amount: 1e4, label: "GRANDE GANHO" }, { round: 5, win: !0, amount: 12e3, label: "MEGA GANHO" }, { round: 6, win: !1, amount: 0, label: "" }, { round: 7, win: !0, amount: 15e3, label: "MEGA GANHO" }, { round: 8, win: !0, amount: 2e4, label: "MEGA GANHO" }, { round: 9, win: !1, amount: 0, label: "" }, { round: 10, win: !0, amount: 45e3, label: "SUPER MEGA GANHO" }], fd = [{ type: "horizontal-top", positions: [[0, 0], [1, 0], [2, 0]] }, { type: "horizontal-mid", positions: [[0, 1], [1, 1], [2, 1]] }, { type: "horizontal-bot", positions: [[0, 2], [1, 2], [2, 2]] }, { type: "diagonal-down", positions: [[0, 0], [1, 1], [2, 2]] }, { type: "diagonal-up", positions: [[0, 2], [1, 1], [2, 0]] }]; function lj() { return fn[Math.floor(Math.random() * fn.length)] } function qa() { return Array.from({ length: 3 }, () => Array.from({ length: 3 }, () => lj())) } function uj() { const e = bg[Math.floor(Math.random() * bg.length)], t = Math.floor(Math.random() * fd.length), n = fd[t], r = qa(); for (const [s, i] of n.positions) r[s][i] = e; return { grid: r, winLine: n.type } } function cj() { let e; do e = qa(); while (fd.some(t => { const n = t.positions.map(([r, s]) => e[r][s].id); return n[0] === n[1] && n[1] === n[2] })); return e } const dj = ({ symbols: e, spinning: t, delay: n }) => { const r = [...fn, ...fn, ...fn, ...fn, ...fn, ...fn]; return g.jsxs("div", { className: "flex-1 flex flex-col overflow-hidden relative", style: { background: "linear-gradient(180deg, #E8D5A8, #D4BC82, #E8D5A8)" }, children: [g.jsx("div", { className: "absolute inset-y-0 left-0 w-[1px] z-10", style: { background: "rgba(184,134,11,0.3)" } }), g.jsx("div", { className: "absolute inset-y-0 right-0 w-[1px] z-10", style: { background: "rgba(184,134,11,0.3)" } }), t ? g.jsx($.div, { className: "flex flex-col", animate: { y: [0, -900] }, transition: { duration: .08, repeat: 1 / 0, ease: "linear", delay: n * .015 }, children: r.map((s, i) => g.jsx("div", { className: "h-[90px] flex items-center justify-center p-1", style: { filter: "blur(2px)" }, children: g.jsx("img", { src: s.image, alt: s.name, className: "w-[70px] h-[70px] object-contain" }) }, i)) }) : g.jsx("div", { className: "flex flex-col", children: e.map((s, i) => g.jsx($.div, { className: "h-[90px] flex items-center justify-center p-1", initial: { y: -30, opacity: 0, scale: .8 }, animate: { y: 0, opacity: 1, scale: 1 }, transition: { type: "spring", stiffness: 400, damping: 18, delay: n + i * .05 }, children: g.jsx("img", { src: s.image, alt: s.name, className: "w-[70px] h-[70px] object-contain", style: { filter: "drop-shadow(0 4px 6px rgba(0,0,0,0.3)) drop-shadow(0 0 8px rgba(255,215,0,0.2))" } }) }, `${s.id}-${i}`)) })] }) }, fj = ({ show: e, label: t, amount: n, isMega: r }) => { const s = new Intl.NumberFormat("pt-AO").format(n); return g.jsx(jl, { children: e && g.jsxs($.div, { className: "fixed inset-0 z-50 flex items-center justify-center", initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: .3 }, children: [g.jsx("div", { className: "absolute inset-0 bg-black/60 backdrop-blur-sm" }), r && g.jsx($.div, { className: "absolute inset-0", style: { background: "rgba(255,215,0,0.15)" }, animate: { opacity: [0, .5, 0] }, transition: { duration: .5, repeat: 3 } }), g.jsxs($.div, { className: "relative z-10 text-center px-6 py-5 rounded-2xl mx-8", style: { background: "linear-gradient(180deg, rgba(139,26,26,0.95), rgba(74,8,8,0.95))", border: "2px solid #DAA520", boxShadow: "0 0 30px rgba(218,165,32,0.4)", maxWidth: "300px" }, initial: { scale: 0, rotate: -5 }, animate: { scale: 1, rotate: 0 }, exit: { scale: 0 }, transition: { type: "spring", stiffness: 250, damping: 15 }, children: [g.jsxs($.div, { className: `font-bold mb-2 ${r ? "text-2xl" : "text-xl"}`, style: { background: "linear-gradient(180deg, #FFD700, #DAA520)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", fontFamily: "'Russo One', sans-serif" }, animate: r ? { scale: [1, 1.08, 1] } : {}, transition: { duration: .5, repeat: 1 / 0 }, children: [" ", t, " "] }), g.jsxs($.div, { className: "font-bold text-3xl", style: { color: "#FFD700", fontFamily: "'Orbitron', sans-serif", textShadow: "0 0 15px rgba(255,215,0,0.6)" }, initial: { y: 15, opacity: 0 }, animate: { y: 0, opacity: 1 }, transition: { delay: .2 }, children: ["+", s, " Kz"] }), g.jsx($.div, { className: "mt-2 text-3xl", initial: { scale: 0 }, animate: { scale: [0, 1.2, 1], rotate: [0, 8, -8, 0] }, transition: { delay: .4, duration: .5 }, children: "" })] })] }) }) }, hj = "/assets/coin-ChMzLoi4.png", pj = ({ active: e }) => e ? g.jsx("div", { className: "fixed inset-0 pointer-events-none z-40 overflow-hidden", children: [...Array(25)].map((t, n) => { const r = 20 + Math.random() * 20; return g.jsx($.img, { src: hj, alt: "", className: "absolute", style: { width: r, height: r }, initial: { x: Math.random() * (typeof window < "u" ? window.innerWidth : 400), y: -60, rotate: 0, opacity: 1 }, animate: { y: (typeof window < "u" ? window.innerHeight : 800) + 60, rotate: 720, opacity: [1, 1, .5] }, transition: { duration: 1.8 + Math.random() * 1.2, delay: Math.random() * .8, ease: "easeIn" } }, n) }) }) : null, mj = ({ active: e }) => g.jsx(jl, { children: e && g.jsxs(g.Fragment, { children: [g.jsx($.div, { className: "fixed inset-0 pointer-events-none z-50", initial: { opacity: 0 }, animate: { opacity: [0, .6, 0] }, exit: { opacity: 0 }, transition: { duration: .6 }, style: { background: "radial-gradient(circle at 50% 80%, rgba(255,215,0,0.3), transparent 60%)" } }), [...Array(12)].map((t, n) => { const s = n / 12 * 360 * Math.PI / 180, i = 80 + Math.random() * 60; return g.jsx($.div, { className: "fixed z-50 pointer-events-none", style: { left: "50%", bottom: "120px", width: "6px", height: "6px", borderRadius: "50%", background: n % 2 === 0 ? "#FFD700" : "#FF6B35", boxShadow: `0 0 8px ${n % 2 === 0 ? "#FFD700" : "#FF6B35"}` }, initial: { x: 0, y: 0, opacity: 1, scale: 1 }, animate: { x: Math.cos(s) * i, y: Math.sin(s) * i - 40, opacity: 0, scale: 0 }, exit: { opacity: 0 }, transition: { duration: .5, delay: n * .02, ease: "easeOut" } }, n) }), [...Array(6)].map((t, n) => g.jsx($.div, { className: "fixed z-50 pointer-events-none", style: { left: `${20 + n * 12}%`, bottom: "100px", width: "2px", height: "40px", background: "linear-gradient(to top, #FFD700, transparent)", borderRadius: "2px" }, initial: { y: 0, opacity: .8, scaleY: 0 }, animate: { y: -80, opacity: 0, scaleY: 1 }, transition: { duration: .4, delay: n * .04 } }, `streak-${n}`))] }) }), gj = ({ type: e, visible: t }) => { if (!t) return null; const r = (() => { switch (e) { case "horizontal-top": return { x1: "0%", y1: "16.7%", x2: "100%", y2: "16.7%" }; case "horizontal-mid": return { x1: "0%", y1: "50%", x2: "100%", y2: "50%" }; case "horizontal-bot": return { x1: "0%", y1: "83.3%", x2: "100%", y2: "83.3%" }; case "diagonal-down": return { x1: "0%", y1: "0%", x2: "100%", y2: "100%" }; case "diagonal-up": return { x1: "0%", y1: "100%", x2: "100%", y2: "0%" } } })(); return g.jsxs($.svg, { className: "absolute inset-0 z-30 pointer-events-none", style: { width: "100%", height: "100%" }, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: [g.jsx($.line, { x1: r.x1, y1: r.y1, x2: r.x2, y2: r.y2, stroke: "rgba(255,215,0,0.4)", strokeWidth: "8", strokeLinecap: "round", filter: "url(#glow)" }), g.jsx($.line, { x1: r.x1, y1: r.y1, x2: r.x2, y2: r.y2, stroke: "#FFD700", strokeWidth: "3", strokeLinecap: "round", initial: { pathLength: 0 }, animate: { pathLength: 1 }, transition: { duration: .4 } }), g.jsx("defs", { children: g.jsxs("filter", { id: "glow", children: [g.jsx("feGaussianBlur", { stdDeviation: "4", result: "coloredBlur" }), g.jsxs("feMerge", { children: [g.jsx("feMergeNode", { in: "coloredBlur" }), g.jsx("feMergeNode", { in: "SourceGraphic" })] })] }) })] }) }, po = "/assets/temple-bg-xbdkwM8g.jpg", yj = ({ totalWin: e, onContinue: t }) => { const n = r => new Intl.NumberFormat("pt-AO").format(r); return g.jsxs("div", { className: "fixed inset-0 z-50 flex items-center justify-center", style: { backgroundImage: `url(${po})`, backgroundSize: "cover", backgroundPosition: "center" }, children: [g.jsx("div", { className: "absolute inset-0", style: { background: "rgba(10,10,20,0.75)" } }), [...Array(20)].map((r, s) => g.jsx($.div, { className: "absolute rounded-full pointer-events-none z-10", style: { width: 3 + Math.random() * 4, height: 3 + Math.random() * 4, background: "#FFD700", left: `${Math.random() * 100}%`, top: `${Math.random() * 100}%`, boxShadow: "0 0 6px #FFD700" }, animate: { opacity: [0, 1, 0], scale: [.5, 1, .5] }, transition: { duration: 2 + Math.random() * 2, repeat: 1 / 0, delay: Math.random() * 3 } }, s)), g.jsxs($.div, { className: "relative z-10 w-full max-w-[340px] mx-4 rounded-2xl p-6 text-center", style: { background: "linear-gradient(180deg, rgba(30,30,40,0.97), rgba(15,15,25,0.98))", border: "1px solid rgba(218,165,32,0.3)", boxShadow: "0 0 40px rgba(255,215,0,0.1)" }, initial: { scale: .8, opacity: 0 }, animate: { scale: 1, opacity: 1 }, transition: { type: "spring", stiffness: 200, damping: 20 }, children: [g.jsx("div", { className: "w-14 h-14 rounded-full flex items-center justify-center mx-auto mb-4", style: { background: "rgba(60,50,30,0.6)" }, children: g.jsx("span", { className: "text-2xl", children: "" }) }), g.jsx("h2", { className: "text-lg font-bold text-white mb-1", style: { fontFamily: "'Russo One', sans-serif" }, children: "As tuas jogadas bnus terminaram" }), g.jsx("p", { className: "text-xs mb-5", style: { color: "#888" }, children: "Os ganhos obtidos esto agora disponveis para levantamento." }), g.jsx("div", { className: "h-px mb-3", style: { background: "linear-gradient(90deg, transparent, rgba(218,165,32,0.3), transparent)" } }), g.jsx("p", { className: "text-xs mb-1", style: { color: "#999" }, children: "Total ganho" }), g.jsxs($.p, { className: "text-3xl font-bold mb-5", style: { background: "linear-gradient(180deg, #22c55e, #16a34a)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", fontFamily: "'Orbitron', sans-serif" }, animate: { scale: [1, 1.05, 1] }, transition: { duration: 2, repeat: 1 / 0 }, children: [n(e), " Kz"] }), g.jsx("div", { className: "h-px mb-5", style: { background: "linear-gradient(90deg, transparent, rgba(218,165,32,0.3), transparent)" } }), g.jsx($.button, { onClick: t, className: "w-full py-3.5 rounded-xl text-base font-bold", style: { background: "linear-gradient(135deg, #FFD700, #DAA520, #FF8C00)", color: "#1a0505", fontFamily: "'Russo One', sans-serif" }, whileTap: { scale: .97 }, children: " Sacar" })] })] }) }, Sg = ["Sofia R.", "Carlos M.", "Ana T.", "Pedro L.", "Maria J.", "Joo S.", "Rita F.", "Bruno A.", "Lusa C.", "Andr P.", "Helena D.", "Miguel N.", "Teresa B.", "Rui G.", "Ins V."], vj = ({ totalWin: e }) => {
  const t = i => new Intl.NumberFormat("pt-AO").format(i), [n, r] = w.useState(null), s = w.useRef(null); return w.useEffect(() => { const i = () => { const a = Sg[Math.floor(Math.random() * Sg.length)], l = Math.floor(Math.random() * 42001) + 95e3; r({ name: a, amount: l }), setTimeout(() => r(null), 4e3) }; i(); const o = setInterval(i, 15e3); return () => clearInterval(o) }, []), w.useEffect(() => {
    const i = s.current; if (!i) return; const o = document.createElement("vturb-smartplayer"); o.id = "vid-699f875ec4b02ade5c5efb73", o.style.cssText = "display:block;margin:0 auto;width:100%;", i.appendChild(o); const a = document.createElement("script"); return a.type = "text/javascript", a.textContent = `
      var s=document.createElement("script");
      s.src="https://scripts.converteai.net/8ec221ee-fd6a-41d1-af21-1a5598ba8436/players/69a0cd629a21752e30e68e77/v4/player.js",
      s.async=!0,document.head.appendChild(s);
    `, i.appendChild(a), () => { for (; i.firstChild;)i.removeChild(i.firstChild) }
  }, []), g.jsxs("div", { className: "fixed inset-0 z-50 overflow-y-auto", style: { background: "#0a0a0a" }, children: [g.jsxs("div", { className: "relative z-10 w-full max-w-[400px] mx-auto px-5 py-10 flex flex-col items-center min-h-screen", children: [g.jsx("h2", { className: "text-xl font-bold text-center mb-6 leading-tight", style: { color: "#FFC106", fontFamily: "'Russo One', sans-serif" }, children: "ASSISTA O VDEO ABAIXO PARA VER COMO RECEBER O SEU DINHEIRO AGORA MESMO" }), g.jsx("div", { className: "w-full rounded-2xl overflow-hidden", ref: s })] }), g.jsx(jl, { children: n && g.jsxs($.div, { className: "fixed bottom-6 left-4 right-4 z-[60] flex items-center gap-3 rounded-xl px-4 py-3 mx-auto max-w-[380px]", style: { background: "rgba(30,32,40,0.95)", border: "1px solid rgba(100,100,120,0.3)", boxShadow: "0 4px 20px rgba(0,0,0,0.5)" }, initial: { y: 80, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 80, opacity: 0 }, transition: { type: "spring", stiffness: 300, damping: 25 }, children: [g.jsx("span", { className: "text-lg", children: "" }), g.jsxs("p", { className: "text-xs text-white", children: [g.jsx("strong", { children: n.name }), " ", g.jsx("span", { style: { color: "#888" }, children: "levantou" }), " ", g.jsxs("strong", { style: { color: "#22c55e" }, children: [t(n.amount), " Kz"] })] })] }) })] })
}, xj = ({ totalWin: e }) => { const [t, n] = w.useState("none"), [r, s] = w.useState("choose"), [i, o] = w.useState(""), [a, l] = w.useState(""), [u, c] = w.useState(""), [d, f] = w.useState(""), h = p => new Intl.NumberFormat("pt-AO").format(p), x = { backgroundImage: `url(${po})`, backgroundSize: "cover", backgroundPosition: "center" }, y = () => { s("processing") }; w.useEffect(() => { if (r === "processing") { const p = setTimeout(() => s("confirmed"), 3e3); return () => clearTimeout(p) } }, [r]); const b = () => s("activation"); return r === "activation" ? g.jsx(vj, { totalWin: e }) : r === "processing" ? g.jsx("div", { className: "fixed inset-0 z-50 flex items-center justify-center", style: { background: "#0d0d12" }, children: g.jsxs($.div, { className: "text-center px-6", initial: { opacity: 0 }, animate: { opacity: 1 }, children: [g.jsx($.div, { className: "w-16 h-16 rounded-full mx-auto mb-6", style: { border: "3px solid rgba(255,255,255,0.1)", borderTopColor: "rgba(255,255,255,0.7)" }, animate: { rotate: 360 }, transition: { duration: 1, repeat: 1 / 0, ease: "linear" } }), g.jsx("h2", { className: "text-xl font-bold text-white mb-2", style: { fontFamily: "'Russo One', sans-serif" }, children: "Verificando seus dados" }), g.jsx("p", { className: "text-sm mb-6", style: { color: "#666" }, children: "Por favor aguarde..." }), g.jsx("div", { className: "w-64 h-1 rounded-full mx-auto overflow-hidden", style: { background: "rgba(255,255,255,0.1)" }, children: g.jsx($.div, { className: "h-full rounded-full", style: { background: "rgba(255,255,255,0.4)" }, initial: { width: "0%" }, animate: { width: "100%" }, transition: { duration: 3, ease: "linear" } }) })] }) }) : r === "confirmed" ? g.jsxs("div", { className: "fixed inset-0 z-50 flex items-center justify-center", style: x, children: [g.jsx("div", { className: "absolute inset-0", style: { background: "rgba(0,0,0,0.55)" } }), g.jsxs($.div, { className: "relative z-10 w-[calc(100%-40px)] max-w-[380px] mx-auto rounded-2xl p-6 text-center", style: { background: "linear-gradient(180deg, rgba(20,25,35,0.95), rgba(15,18,25,0.97))", border: "1px solid rgba(100,120,140,0.2)", boxShadow: "0 8px 40px rgba(0,0,0,0.5)" }, initial: { scale: .8, opacity: 0 }, animate: { scale: 1, opacity: 1 }, children: [g.jsx("div", { className: "w-14 h-14 rounded-full flex items-center justify-center mx-auto mb-3", style: { background: "rgba(34,197,94,0.15)" }, children: g.jsx("span", { className: "text-2xl", children: "" }) }), g.jsx("h2", { className: "text-lg font-bold mb-1", style: { color: "#22c55e", fontFamily: "'Russo One', sans-serif" }, children: "Dados verificados com sucesso" }), g.jsx("p", { className: "text-xs mb-4", style: { color: "#888" }, children: "Os seus dados foram validados" }), g.jsx("div", { className: "h-px mb-3", style: { background: "linear-gradient(90deg, transparent, rgba(100,100,120,0.3), transparent)" } }), g.jsx("p", { className: "text-xs mb-1", style: { color: "#999" }, children: "Total disponvel para levantamento" }), g.jsxs($.p, { className: "text-3xl font-bold mb-4", style: { background: "linear-gradient(180deg, #22c55e, #16a34a)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", fontFamily: "'Orbitron', sans-serif" }, animate: { scale: [1, 1.03, 1] }, transition: { duration: 2, repeat: 1 / 0 }, children: [h(e), " Kz"] }), g.jsx("div", { className: "h-px mb-4", style: { background: "linear-gradient(90deg, transparent, rgba(100,100,120,0.3), transparent)" } }), g.jsx("div", { className: "text-left space-y-2.5 mb-5", children: t === "express" ? g.jsxs("div", { className: "flex items-center gap-2 text-xs", style: { color: "#ccc" }, children: [g.jsx("span", { children: "" }), g.jsxs("span", { children: ["Express: ", g.jsx("strong", { className: "text-white", children: i })] })] }) : g.jsxs(g.Fragment, { children: [g.jsxs("div", { className: "flex items-center gap-2 text-xs", style: { color: "#ccc" }, children: [g.jsx("span", { children: "" }), g.jsx("span", { children: a })] }), g.jsxs("div", { className: "flex items-center gap-2 text-xs", style: { color: "#ccc" }, children: [g.jsx("span", { children: "" }), g.jsx("span", { children: u })] }), g.jsxs("div", { className: "flex items-center gap-2 text-xs", style: { color: "#ccc" }, children: [g.jsx("span", { children: "" }), g.jsxs("span", { children: ["IBAN: ", d] })] })] }) }), g.jsx($.button, { onClick: b, className: "w-full py-3.5 rounded-xl text-base font-bold", style: { background: "linear-gradient(135deg, #FFD700, #DAA520, #FF8C00)", color: "#1a0505", fontFamily: "'Russo One', sans-serif" }, whileTap: { scale: .97 }, children: " Levantar meus ganhos agora" })] })] }) : t === "none" || r === "choose" ? g.jsxs("div", { className: "fixed inset-0 z-50 flex items-center justify-center", style: x, children: [g.jsx("div", { className: "absolute inset-0", style: { background: "rgba(0,0,0,0.55)" } }), g.jsxs($.div, { className: "relative z-10 w-[calc(100%-40px)] max-w-[380px] mx-auto rounded-2xl px-6 py-8", style: { background: "linear-gradient(180deg, rgba(20,25,35,0.95), rgba(15,18,25,0.97))", border: "1px solid rgba(100,120,140,0.2)", boxShadow: "0 8px 40px rgba(0,0,0,0.5)" }, initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, children: [g.jsx("h2", { className: "text-xl font-bold text-white text-center mb-1", style: { fontFamily: "'Russo One', sans-serif" }, children: "Levantamento" }), g.jsx("p", { className: "text-xs text-center mb-1", style: { color: "#888" }, children: "Escolha o meio de recebimento" }), g.jsxs("p", { className: "text-xl font-bold text-center mb-1", style: { background: "linear-gradient(180deg, #22c55e, #16a34a)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", fontFamily: "'Orbitron', sans-serif" }, children: [h(e), " Kz"] }), g.jsx("p", { className: "text-[10px] text-center mb-6", style: { color: "#666" }, children: "disponvel para levantamento" }), g.jsxs($.button, { onClick: () => { n("iban"), s("form") }, className: "w-full rounded-xl p-4 mb-3 text-left flex items-center gap-3", style: { background: "rgba(25,25,35,0.9)", border: "1px solid rgba(100,100,120,0.25)" }, whileTap: { scale: .98 }, children: [g.jsx("span", { className: "text-2xl", children: "" }), g.jsxs("div", { children: [g.jsx("p", { className: "font-bold text-white text-sm", children: "Registrar IBAN" }), g.jsx("p", { className: "text-[10px]", style: { color: "#888" }, children: "Transferncia bancria directa" })] })] }), g.jsxs($.button, { onClick: () => { n("express"), s("form") }, className: "w-full rounded-xl p-4 text-left flex items-center gap-3", style: { background: "rgba(25,25,35,0.9)", border: "1px solid rgba(100,100,120,0.25)" }, whileTap: { scale: .98 }, children: [g.jsx("span", { className: "text-2xl", children: "" }), g.jsxs("div", { children: [g.jsx("p", { className: "font-bold text-white text-sm", children: "Registrar Multicaixa Express" }), g.jsx("p", { className: "text-[10px]", style: { color: "#888" }, children: "Receba no seu Express" })] })] })] })] }) : g.jsxs("div", { className: "fixed inset-0 z-50 flex items-center justify-center", style: x, children: [g.jsx("div", { className: "absolute inset-0", style: { background: "rgba(0,0,0,0.55)" } }), g.jsxs($.div, { className: "relative z-10 w-[calc(100%-40px)] max-w-[380px] mx-auto rounded-2xl px-6 py-8", style: { background: "linear-gradient(180deg, rgba(20,25,35,0.95), rgba(15,18,25,0.97))", border: "1px solid rgba(100,120,140,0.2)", boxShadow: "0 8px 40px rgba(0,0,0,0.5)" }, initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, children: [g.jsx("button", { onClick: () => { n("none"), s("choose") }, className: "text-xs mb-3", style: { color: "#888" }, children: " Voltar" }), g.jsx("h2", { className: "text-lg font-bold text-white mb-5", style: { fontFamily: "'Russo One', sans-serif" }, children: t === "express" ? "Multicaixa Express" : "Registrar IBAN" }), t === "express" ? g.jsx("div", { className: "space-y-3", children: g.jsxs("div", { children: [g.jsx("label", { className: "text-[10px] mb-1 block", style: { color: "#888" }, children: "Nmero Express" }), g.jsx("input", { type: "tel", value: i, onChange: p => o(p.target.value), placeholder: "9XX XXX XXX", className: "w-full rounded-xl px-4 py-3 text-white text-sm outline-none", style: { background: "rgba(25,25,35,0.9)", border: "1px solid rgba(100,100,120,0.3)" } })] }) }) : g.jsxs("div", { className: "space-y-3", children: [g.jsxs("div", { children: [g.jsx("label", { className: "text-[10px] mb-1 block", style: { color: "#888" }, children: "Nome completo" }), g.jsx("input", { type: "text", value: a, onChange: p => l(p.target.value), placeholder: "Nome do titular", className: "w-full rounded-xl px-4 py-3 text-white text-sm outline-none", style: { background: "rgba(25,25,35,0.9)", border: "1px solid rgba(100,100,120,0.3)" } })] }), g.jsxs("div", { children: [g.jsx("label", { className: "text-[10px] mb-1 block", style: { color: "#888" }, children: "Nmero de telefone" }), g.jsx("input", { type: "tel", value: u, onChange: p => c(p.target.value), placeholder: "9XX XXX XXX", className: "w-full rounded-xl px-4 py-3 text-white text-sm outline-none", style: { background: "rgba(25,25,35,0.9)", border: "1px solid rgba(100,100,120,0.3)" } })] }), g.jsxs("div", { children: [g.jsx("label", { className: "text-[10px] mb-1 block", style: { color: "#888" }, children: "IBAN" }), g.jsx("input", { type: "text", value: d, onChange: p => f(p.target.value), placeholder: "AO06 XXXX XXXX XXXX XXXX XXXX X", className: "w-full rounded-xl px-4 py-3 text-white text-sm outline-none", style: { background: "rgba(25,25,35,0.9)", border: "1px solid rgba(100,100,120,0.3)" } })] })] }), g.jsx($.button, { onClick: y, className: "w-full py-3.5 rounded-xl text-base font-bold mt-6", style: { background: "linear-gradient(135deg, #FFD700, #DAA520, #FF8C00)", color: "#1a0505", fontFamily: "'Russo One', sans-serif" }, whileTap: { scale: .97 }, children: "Confirmar Levantamento" })] })] }) }, wj = () => { const e = w.useRef(null), t = w.useRef(null), n = w.useCallback(() => { try { const a = new AudioContext, l = a.createOscillator(), u = a.createGain(); l.connect(u), u.connect(a.destination), l.frequency.setValueAtTime(600, a.currentTime), l.frequency.exponentialRampToValueAtTime(300, a.currentTime + .08), u.gain.setValueAtTime(.2, a.currentTime), u.gain.exponentialRampToValueAtTime(.01, a.currentTime + .1), l.start(a.currentTime), l.stop(a.currentTime + .1) } catch { } }, []), r = w.useCallback(() => { try { const a = new AudioContext; e.current = a; const l = a.createOscillator(), u = a.createGain(); l.type = "square", l.connect(u), u.connect(a.destination), l.frequency.setValueAtTime(80, a.currentTime), u.gain.setValueAtTime(.06, a.currentTime); const c = a.createOscillator(), d = a.createGain(); c.frequency.setValueAtTime(18, a.currentTime), d.gain.setValueAtTime(40, a.currentTime), c.connect(d), d.connect(l.frequency), c.start(a.currentTime); const f = a.sampleRate * 2, h = a.createBuffer(1, f, a.sampleRate), x = h.getChannelData(0); for (let p = 0; p < f; p++)x[p] = Math.random() * 2 - 1; const y = a.createBufferSource(); y.buffer = h; const b = a.createGain(); b.gain.setValueAtTime(.03, a.currentTime), y.connect(b), b.connect(a.destination), y.start(a.currentTime), l.start(a.currentTime), t.current = l } catch { } }, []), s = w.useCallback(() => { var a; try { (a = t.current) == null || a.stop(), t.current = null, e.current && (e.current.close(), e.current = null) } catch { } }, []), i = w.useCallback(() => { try { const a = new AudioContext;[523, 659, 784, 1047, 1319].forEach((u, c) => { const d = a.createOscillator(), f = a.createGain(); d.type = "sine", d.connect(f), f.connect(a.destination), d.frequency.setValueAtTime(u, a.currentTime + c * .08), f.gain.setValueAtTime(.25, a.currentTime + c * .08), f.gain.exponentialRampToValueAtTime(.01, a.currentTime + c * .08 + .15), d.start(a.currentTime + c * .08), d.stop(a.currentTime + c * .08 + .15) }), setTimeout(() => { const u = a.createOscillator(), c = a.createGain(); u.type = "triangle", u.connect(c), c.connect(a.destination), u.frequency.setValueAtTime(2e3, a.currentTime), u.frequency.exponentialRampToValueAtTime(4e3, a.currentTime + .3), c.gain.setValueAtTime(.1, a.currentTime), c.gain.exponentialRampToValueAtTime(.01, a.currentTime + .3), u.start(a.currentTime), u.stop(a.currentTime + .3) }, 300) } catch { } }, []), o = w.useCallback(() => { try { const a = new AudioContext, l = a.createOscillator(), u = a.createGain(); l.type = "sine", l.connect(u), u.connect(a.destination), l.frequency.setValueAtTime(400, a.currentTime), l.frequency.exponentialRampToValueAtTime(200, a.currentTime + .3), u.gain.setValueAtTime(.15, a.currentTime), u.gain.exponentialRampToValueAtTime(.01, a.currentTime + .4), l.start(a.currentTime), l.stop(a.currentTime + .4) } catch { } }, []); return { playSpinClick: n, playReelSpin: r, stopReelSpin: s, playWinSound: i, playLoseSound: o } }, Tg = [500, 1e3, 2e3, 5e3, 1e4], bj = () => { const [e, t] = w.useState(0), [n, r] = w.useState(0), [s, i] = w.useState(0), [o, a] = w.useState(0), [l, u] = w.useState(!1), [c, d] = w.useState(qa), [f, h] = w.useState("idle"), [x, y] = w.useState(!1), [b, p] = w.useState(!1), [m, v] = w.useState({ label: "", amount: 0, isMega: !1 }), [S, T] = w.useState(!1), [C, E] = w.useState(!1), [P, N] = w.useState(0), [j, z] = w.useState(!1), [L, H] = w.useState(!1), [O, K] = w.useState(null), [U, V] = w.useState("playing"), k = w.useRef(!1), { playSpinClick: R, playReelSpin: F, stopReelSpin: W, playWinSound: B, playLoseSound: Y } = wj(), q = Tg[P], he = C ? 800 : 1500; w.useEffect(() => { if (n === e) return; const ce = e - n, se = 25, ot = ce / se; let qe = n, Re = 0; const at = setInterval(() => { Re++, qe += ot, Re >= se ? (r(e), clearInterval(at)) : r(Math.round(qe)) }, 30); return () => clearInterval(at) }, [e]); const Se = w.useCallback(() => { if (l || o >= 10) return; const ce = o % 10, se = aj[ce]; u(!0), h("spinning"), y(!1), p(!1), z(!1), i(0), K(null), H(!0), R(), F(), setTimeout(() => H(!1), 600), d(qa()), setTimeout(() => { let ot, qe = null; if (se.win) { const Re = uj(); ot = Re.grid, qe = Re.winLine } else ot = cj(); if (d(ot), u(!1), W(), se.win) { const Re = se.label === "SUPER MEGA GANHO"; h(Re ? "mega-win" : "win"), v({ label: se.label, amount: se.amount, isMega: Re }), p(!0), z(!0), i(se.amount), K(qe), B(), setTimeout(() => y(!0), 300), setTimeout(() => t(at => at + se.amount), 600), setTimeout(() => { y(!1), p(!1), z(!1), K(null), h("idle"), ce === 9 && setTimeout(() => V("bonus-end"), 500) }, Re ? 4e3 : 2500) } else h("lose"), Y(), setTimeout(() => h("idle"), 800); a(Re => Re + 1) }, he) }, [l, o, he, R, F, W, B, Y]); w.useEffect(() => { k.current = S }, [S]), w.useEffect(() => { if (!S || l || o >= 10) return; const ce = setTimeout(() => { k.current && Se() }, C ? 1500 : 3e3); return () => clearTimeout(ce) }, [S, l, Se, C, o]); const J = ce => new Intl.NumberFormat("pt-AO").format(ce); return U === "withdraw" ? g.jsx(xj, { totalWin: e }) : U === "bonus-end" ? g.jsx(yj, { totalWin: e, onContinue: () => V("withdraw") }) : g.jsxs("div", { className: "min-h-screen flex flex-col items-center justify-start relative overflow-hidden", children: [g.jsx("div", { className: "absolute inset-0", children: g.jsx("img", { src: po, alt: "", className: "w-full h-full object-cover" }) }), g.jsx("div", { className: "absolute inset-0 pointer-events-none", style: { background: "radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.3) 100%)" } }), [...Array(15)].map((ce, se) => g.jsx($.div, { className: "absolute rounded-full pointer-events-none z-20", style: { width: 2 + Math.random() * 3, height: 2 + Math.random() * 3, background: se % 3 === 0 ? "#FFD700" : se % 3 === 1 ? "#FF6B35" : "#fff", left: `${5 + Math.random() * 90}%`, top: `${10 + Math.random() * 80}%`, boxShadow: `0 0 ${4 + Math.random() * 6}px ${se % 3 === 0 ? "#FFD700" : "#FF6B35"}` }, animate: { opacity: [0, .8, 0], y: [0, -20, -40] }, transition: { duration: 3 + Math.random() * 3, repeat: 1 / 0, delay: Math.random() * 5 } }, `sparkle-${se}`)), g.jsxs("div", { className: "relative z-10 w-full max-w-[420px] mx-auto flex flex-col pt-2 px-2 sm:px-0", children: [g.jsxs("div", { className: "flex items-center justify-between px-2 py-2 gap-1", children: [g.jsxs("div", { className: "rounded-lg px-2 py-1 flex flex-col items-center min-w-0 flex-shrink-0", style: { background: "linear-gradient(180deg, #8B1A1A, #4A0808)", border: "1px solid rgba(218,165,32,0.6)" }, children: [g.jsx("span", { className: "text-[7px] uppercase tracking-wider whitespace-nowrap", style: { color: "#FFD700" }, children: "Rodadas Grtis" }), g.jsxs("span", { className: "font-bold text-xs", style: { color: "#22c55e", fontFamily: "'Orbitron', sans-serif" }, children: [o, "/10"] })] }), g.jsxs("div", { className: "flex flex-col items-center flex-shrink min-w-0", children: [g.jsx("span", { className: "font-bold text-sm sm:text-lg whitespace-nowrap", style: { background: "linear-gradient(180deg, #FFD700, #DAA520, #B8860B)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", filter: "drop-shadow(0 0 8px rgba(255,215,0,0.5))", fontFamily: "'Russo One', sans-serif" }, children: "FORTUNE TIGER" }), g.jsx("span", { className: "text-[8px] tracking-widest", style: { color: "#B8860B" }, children: "PG SOFT" })] }), g.jsxs("div", { className: "rounded-lg px-2 py-1 flex flex-col items-center min-w-0 flex-shrink-0", style: { background: "linear-gradient(180deg, #8B1A1A, #4A0808)", border: "1px solid rgba(218,165,32,0.6)" }, children: [g.jsx("span", { className: "text-[7px] uppercase tracking-wider", style: { color: "#FFD700" }, children: "Saldo" }), g.jsxs("span", { className: `font-bold text-xs whitespace-nowrap ${j ? "glow-gold" : ""}`, style: { color: "#22c55e", fontFamily: "'Orbitron', sans-serif" }, children: [J(n), " Kz"] })] })] }), g.jsx(q5, { state: f }), g.jsxs("div", { className: "mx-4 relative", children: [g.jsx("div", { className: "absolute -inset-[3px] rounded-xl z-0", style: { background: "linear-gradient(180deg, #DAA520 0%, #B8860B 20%, #DAA520 40%, #FFD700 50%, #DAA520 60%, #B8860B 80%, #DAA520 100%)", boxShadow: "0 0 20px rgba(218,165,32,0.5), inset 0 0 10px rgba(255,215,0,0.3)" } }), g.jsx("div", { className: "absolute -left-3 top-0 bottom-0 w-5 z-30 rounded-l", style: { background: "linear-gradient(90deg, #6B4C14, #B8860B, #DAA520, #FFD700, #DAA520, #B8860B, #6B4C14)", boxShadow: "2px 0 8px rgba(0,0,0,0.3)" } }), g.jsx("div", { className: "absolute -right-3 top-0 bottom-0 w-5 z-30 rounded-r", style: { background: "linear-gradient(90deg, #6B4C14, #B8860B, #DAA520, #FFD700, #DAA520, #B8860B, #6B4C14)", boxShadow: "-2px 0 8px rgba(0,0,0,0.3)" } }), g.jsx("div", { className: "absolute -left-7 top-0 bottom-0 flex flex-col justify-around z-40 py-1", children: ["1", "2", "3"].map(ce => g.jsx("div", { className: "w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold", style: { background: "linear-gradient(135deg, #DAA520, #FFD700)", color: "#4A0808", boxShadow: "0 0 6px rgba(218,165,32,0.5)" }, children: ce }, ce)) }), g.jsx("div", { className: "absolute -right-7 top-0 bottom-0 flex flex-col justify-around z-40 py-1", children: ["5", "2", "4"].map(ce => g.jsx("div", { className: "w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold", style: { background: "linear-gradient(135deg, #DAA520, #FFD700)", color: "#4A0808", boxShadow: "0 0 6px rgba(218,165,32,0.5)" }, children: ce }, ce)) }), g.jsxs("div", { className: "relative z-10 rounded-lg overflow-hidden", style: { background: "#1a0505" }, children: [g.jsx("div", { className: "flex", style: { height: "270px" }, children: c.map((ce, se) => g.jsx(dj, { symbols: ce, spinning: l, delay: se * .12 }, se)) }), g.jsx(gj, { type: O || "horizontal-mid", visible: !!O })] })] }), g.jsx("div", { className: "mx-4 mt-0 relative overflow-hidden", style: { background: "linear-gradient(180deg, #6B0F0F, #4A0808)", border: "2px solid #DAA520", borderTop: "none", borderRadius: "0 0 8px 8px", padding: "5px 12px" }, children: g.jsx($.div, { className: "text-xs whitespace-nowrap font-bold", style: { color: "#FFD700" }, animate: { x: [350, -600] }, transition: { duration: 10, repeat: 1 / 0, ease: "linear" }, children: " Fortune Tiger  Jogue e ganhe grandes prmios!  Multiplicadores at 2500x " }) }), g.jsx("div", { className: "mx-4 mt-2", children: g.jsxs("div", { className: "flex rounded-lg overflow-hidden", style: { background: "linear-gradient(180deg, #6B0F0F, #4A0808)", border: "1px solid #DAA520" }, children: [g.jsxs("div", { className: "flex-1 text-center py-2 flex items-center justify-center gap-1.5", style: { borderRight: "1px solid rgba(218,165,32,0.4)" }, children: [g.jsx("span", { className: "text-base", children: "" }), g.jsxs("div", { children: [g.jsx("div", { className: "text-[8px] uppercase tracking-wider", style: { color: "#FFD700" }, children: "Saldo" }), g.jsxs("div", { className: "font-bold text-[11px]", style: { color: "#FFD700", fontFamily: "'Orbitron', sans-serif" }, children: [J(n), " Kz"] })] })] }), g.jsxs("div", { className: "flex-1 text-center py-2 flex items-center justify-center gap-1.5", style: { borderRight: "1px solid rgba(218,165,32,0.4)" }, children: [g.jsx("span", { className: "text-base", children: "" }), g.jsxs("div", { children: [g.jsx("div", { className: "text-[8px] uppercase tracking-wider", style: { color: "#FFD700" }, children: "Aposta Grtis" }), g.jsxs("div", { className: "font-bold text-[11px]", style: { color: "#FFD700", fontFamily: "'Orbitron', sans-serif" }, children: [J(q), " Kz"] })] })] }), g.jsxs("div", { className: "flex-1 text-center py-2 flex items-center justify-center gap-1.5", children: [g.jsx("span", { className: "text-base", children: "" }), g.jsxs("div", { children: [g.jsx("div", { className: "text-[8px] uppercase tracking-wider", style: { color: "#FFD700" }, children: "Ganho" }), g.jsxs("div", { className: `font-bold text-[11px] ${s > 0 ? "glow-gold" : ""}`, style: { color: "#FFD700", fontFamily: "'Orbitron', sans-serif" }, children: [J(s), " Kz"] })] })] })] }) }), g.jsxs("div", { className: "mx-4 mt-3 flex items-center justify-center gap-3", children: [g.jsxs("button", { onClick: () => E(!C), className: "flex flex-col items-center justify-center w-12 h-12 rounded-full transition-all", style: { background: C ? "linear-gradient(135deg, #DAA520, #FFD700)" : "linear-gradient(135deg, #2a0808, #1a0505)", border: `2px solid ${C ? "#FFD700" : "#DAA520"}`, boxShadow: C ? "0 0 15px rgba(255,215,0,0.6)" : "0 0 5px rgba(0,0,0,0.3)" }, children: [g.jsx("span", { className: "text-lg", children: "" }), g.jsx("span", { className: "text-[7px] font-bold", style: { color: C ? "#4A0808" : "#DAA520" }, children: "TURBO" })] }), g.jsx("button", { onClick: () => N(Math.max(0, P - 1)), className: "w-10 h-10 rounded-full flex items-center justify-center text-lg font-bold transition-all active:scale-90", style: { background: "linear-gradient(135deg, #2a0808, #1a0505)", border: "2px solid #DAA520", color: "#FFD700" }, children: "" }), g.jsx($.button, { onClick: Se, disabled: l || o >= 10, className: "relative w-[72px] h-[72px] rounded-full flex items-center justify-center font-bold text-base", style: { background: l ? "linear-gradient(135deg, #555, #333)" : "linear-gradient(135deg, #22c55e, #16a34a, #15803d)", border: "4px solid #DAA520", color: l ? "#999" : "#FFF", fontFamily: "'Russo One', sans-serif", boxShadow: l ? "inset 0 2px 8px rgba(0,0,0,0.5)" : "0 0 25px rgba(34,197,94,0.5), inset 0 -3px 8px rgba(0,0,0,0.3)" }, whileTap: l ? {} : { scale: .88 }, animate: l ? {} : { boxShadow: ["0 0 20px rgba(34,197,94,0.4)", "0 0 40px rgba(34,197,94,0.8)", "0 0 20px rgba(34,197,94,0.4)"] }, transition: l ? {} : { duration: 1.2, repeat: 1 / 0 }, children: l ? g.jsx($.span, { animate: { rotate: 360 }, transition: { duration: .8, repeat: 1 / 0, ease: "linear" }, children: "" }) : "JOGAR" }), g.jsx("button", { onClick: () => N(Math.min(Tg.length - 1, P + 1)), className: "w-10 h-10 rounded-full flex items-center justify-center text-lg font-bold transition-all active:scale-90", style: { background: "linear-gradient(135deg, #2a0808, #1a0505)", border: "2px solid #DAA520", color: "#FFD700" }, children: "+" }), g.jsxs("button", { onClick: () => T(!S), className: "flex flex-col items-center justify-center w-12 h-12 rounded-full transition-all", style: { background: S ? "linear-gradient(135deg, #DAA520, #FFD700)" : "linear-gradient(135deg, #2a0808, #1a0505)", border: `2px solid ${S ? "#FFD700" : "#DAA520"}`, boxShadow: S ? "0 0 15px rgba(255,215,0,0.6)" : "0 0 5px rgba(0,0,0,0.3)" }, children: [g.jsx("span", { className: "text-lg", children: "" }), g.jsx("span", { className: "text-[7px] font-bold", style: { color: S ? "#4A0808" : "#DAA520" }, children: "AUTO" })] })] }), g.jsx("div", { className: "mx-4 mt-2 mb-4 flex justify-center", children: g.jsx($.button, { onClick: () => { o >= 10 && V("bonus-end") }, disabled: o < 10, className: "px-8 py-2.5 rounded-lg text-sm font-bold flex items-center justify-center gap-2", style: { background: o >= 10 ? "linear-gradient(135deg, #FFD700, #DAA520, #FF8C00)" : "#555555", color: o >= 10 ? "#1a0505" : "#aaa", fontFamily: "'Russo One', sans-serif", border: o >= 10 ? "1px solid rgba(255,215,0,0.5)" : "1px solid rgba(120,120,120,0.3)", boxShadow: o >= 10 ? "0 0 20px rgba(255,215,0,0.3)" : "none", cursor: o >= 10 ? "pointer" : "not-allowed" }, whileTap: o >= 10 ? { scale: .97 } : {}, children: " LEVANTAR" }) })] }), g.jsx(mj, { active: L }), g.jsx(pj, { active: b }), g.jsx(fj, { show: x, label: m.label, amount: m.amount, isMega: m.isMega })] }) }, Sj = ({ onStart: e }) => g.jsxs("div", { className: "min-h-screen flex flex-col items-center justify-center relative overflow-hidden", children: [g.jsxs("div", { className: "absolute inset-0", children: [g.jsx("img", { src: po, alt: "", className: "w-full h-full object-cover" }), g.jsx("div", { className: "absolute inset-0", style: { background: "linear-gradient(180deg, rgba(0,0,0,0.3) 0%, rgba(139,10,10,0.6) 50%, rgba(0,0,0,0.85) 100%)" } })] }), g.jsx($.div, { className: "relative z-10 w-full max-w-[380px] mx-auto px-6", initial: { opacity: 0, y: 30 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6 }, children: g.jsxs("div", { className: "rounded-2xl p-6 text-center", style: { background: "linear-gradient(180deg, rgba(20,5,5,0.92), rgba(10,2,2,0.96))", border: "1px solid rgba(218,165,32,0.3)", boxShadow: "0 0 40px rgba(0,0,0,0.5)" }, children: [g.jsx($.div, { className: "flex justify-center mb-2", animate: { y: [0, -8, 0] }, transition: { duration: 2, repeat: 1 / 0, ease: "easeInOut" }, children: g.jsx("img", { src: rh, alt: "Fortune Tiger", className: "w-28 h-28 object-contain drop-shadow-2xl" }) }), g.jsx($.h1, { className: "font-display text-2xl font-bold mb-1", style: { background: "linear-gradient(180deg, #FFD700, #DAA520, #FF8C00)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", filter: "drop-shadow(0 0 10px rgba(255,215,0,0.5))" }, animate: { scale: [1, 1.03, 1] }, transition: { duration: 2, repeat: 1 / 0 }, children: "PARABNS!" }), g.jsx("p", { className: "font-display text-sm font-bold", style: { color: "#E8E8E8" }, children: "Bem-vindo ao Fortune Tiger" }), g.jsx("p", { className: "text-xs mt-1", style: { color: "#999" }, children: "A sua conta foi selecionada para uma oferta exclusiva" }), g.jsx("div", { className: "my-4 h-px", style: { background: "linear-gradient(90deg, transparent, rgba(218,165,32,0.4), transparent)" } }), g.jsxs("div", { className: "flex items-center justify-center gap-2 mb-1", children: [g.jsx("span", { className: "text-2xl", children: "" }), g.jsxs("div", { children: [g.jsx("p", { className: "text-xs", style: { color: "#B8860B" }, children: "Bnus de Boas-Vindas" }), g.jsx("p", { className: "font-display text-2xl font-bold", style: { background: "linear-gradient(180deg, #22c55e, #16a34a)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent" }, children: "10 Jogadas" })] })] }), g.jsxs("p", { className: "text-xs mb-4", style: { color: "#DAA520" }, children: ["Cada jogada com aposta de ", g.jsx("strong", { children: "1.000 Kz" })] }), g.jsx("div", { className: "my-4 h-px", style: { background: "linear-gradient(90deg, transparent, rgba(218,165,32,0.4), transparent)" } }), g.jsx("div", { className: "text-left space-y-2 mb-6 px-2", children: [g.jsxs(g.Fragment, { children: ["Jogue ", g.jsx("strong", { children: "10 rodadas gratuitas" }), " no Fortune Tiger"] }), g.jsxs(g.Fragment, { children: ["Acumule ganhos com ", g.jsx("strong", { children: "multiplicadores elevados" })] }), g.jsxs(g.Fragment, { children: ["Levante os seus ganhos ", g.jsx("strong", { children: "aps as jogadas" })] })].map((t, n) => g.jsxs($.div, { className: "flex items-center gap-2 text-xs", initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { delay: .3 + n * .15 }, children: [g.jsx("span", { className: "text-base", children: "" }), g.jsx("span", { style: { color: "#CCC" }, children: t })] }, n)) }), g.jsx($.button, { onClick: e, className: "w-full py-3.5 rounded-xl font-display text-lg font-bold", style: { background: "linear-gradient(135deg, #FFD700, #DAA520, #FF8C00)", color: "#1a0505", boxShadow: "0 0 25px rgba(255,215,0,0.4)" }, whileHover: { scale: 1.03 }, whileTap: { scale: .97 }, animate: { boxShadow: ["0 0 20px rgba(255,215,0,0.3)", "0 0 40px rgba(255,215,0,0.6)", "0 0 20px rgba(255,215,0,0.3)"] }, transition: { duration: 1.5, repeat: 1 / 0 }, children: " Jogar Agora" }), g.jsx("p", { className: "text-[10px] mt-3", style: { color: "#666" }, children: "Oferta limitada  Apenas para novas contas" })] }) })] }), Tj = [{ user: "@maria_f", time: "h 2 minutos", text: "Ainda estou emocionada  Joguei o Fortune Tiger, ganhei e recebi os 115.000 KZ sem complicaes. Foi tudo muito rpido e simples. Quem tiver oportunidade, aproveite." }, { user: "@joao_k", time: "h 5 minutos", text: "No incio pensei que fosse s conversa, mas resolvi tentar. Joguei, ganhei e o dinheiro caiu mesmo. Funcionou certinho. Recomendo a todos." }, { user: "@ana_p", time: "h 12 minutos", text: "Obrigada pela seriedade  Em poucos minutos joguei, confirmei o prmio e j consegui levantar o valor. Valeu muito a pena." }, { user: "@carlos_m", time: "h 45 minutos", text: "No pensei duas vezes. Joguei o Fortune Tiger, ganhei os 115.000 KZ e j levantei.  real e funciona mesmo. Nunca vi nada igual em Angola." }, { user: "@helena_s", time: "h 1 hora", text: "Gostei muito da experincia. Tudo claro, sem complicao. Fiz tudo pelo telemvel e recebi o prmio no mesmo dia. Esse jogo mudou a minha vida!" }, { user: "@paulo_t", time: "h 2 horas", text: "Recomendo  Simples, sem stress, e o prmio sai de verdade. Fiquei muito satisfeito. J indiquei para toda a minha famlia." }, { user: "@rosa_l", time: "h 3 horas", text: " verdadeiro sim. Joguei, ganhei e recebi. Aproveitem enquanto ainda est disponvel. Pensei que fosse burla, testei e recomendo!" }, { user: "@manuel_d", time: "h 4 horas", text: "Minha esposa no acreditava at ver o dinheiro na conta  Agora ela tambm quer jogar. Fortune Tiger  srio, pessoal!" }], Cj = () => g.jsxs("div", { className: "mt-6 mb-2", children: [g.jsx("h3", { className: "text-sm font-bold mb-3", style: { color: "#ccc", fontFamily: "'Russo One', sans-serif" }, children: " Comentrios Recentes" }), g.jsx("div", { className: "space-y-3", children: Tj.map((e, t) => g.jsxs($.div, { initial: { opacity: 0, y: 10 }, animate: { opacity: 1, y: 0 }, transition: { delay: t * .08 }, className: "pb-3", style: { borderBottom: "1px solid rgba(255,255,255,0.06)" }, children: [g.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [g.jsx("span", { className: "text-xs font-bold", style: { color: "#e0e0e0" }, children: e.user }), g.jsx("span", { className: "text-[10px]", style: { color: "#666" }, children: e.time })] }), g.jsx("p", { className: "text-xs leading-relaxed", style: { color: "#aaa" }, children: e.text }), g.jsxs("div", { className: "flex items-center gap-3 mt-1.5", children: [g.jsx("span", { className: "text-[11px] cursor-pointer", children: "" }), g.jsx("span", { className: "text-[11px] cursor-pointer", children: "" }), g.jsx("span", { className: "text-[10px] cursor-pointer", style: { color: "#666" }, children: "Responder" })] })] }, t)) })] }), Ej = ({ onComplete: e }) => { const [t, n] = w.useState(""), [r, s] = w.useState(""), [i, o] = w.useState(!1), a = () => { !t.trim() || !r.trim() || o(!0) }; return g.jsxs("div", { className: "min-h-screen flex flex-col items-center relative overflow-hidden", children: [g.jsxs("div", { className: "absolute inset-0", children: [g.jsx("img", { src: po, alt: "", className: "w-full h-full object-cover" }), g.jsx("div", { className: "absolute inset-0", style: { background: "rgba(0,0,0,0.55)" } })] }), g.jsxs($.div, { className: "relative z-10 w-[calc(100%-40px)] max-w-[380px] mx-auto px-6 py-8 my-8 rounded-2xl", style: { background: "linear-gradient(180deg, rgba(20,25,35,0.95), rgba(15,18,25,0.97))", border: "1px solid rgba(100,120,140,0.2)", boxShadow: "0 8px 40px rgba(0,0,0,0.5)" }, initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, children: [g.jsx($.div, { className: "flex justify-center mb-3", animate: { y: [0, -6, 0] }, transition: { duration: 2, repeat: 1 / 0, ease: "easeInOut" }, children: g.jsx("img", { src: rh, alt: "Fortune Tiger", className: "w-20 h-20 object-contain drop-shadow-2xl" }) }), g.jsx("h2", { className: "text-xl font-bold text-center mb-1", style: { background: "linear-gradient(180deg, #FFD700, #DAA520, #FF8C00)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", fontFamily: "'Russo One', sans-serif" }, children: "Cadastre-se" }), g.jsxs("p", { className: "text-xs text-center mb-6", style: { color: "#888" }, children: ["e ganhe ", g.jsx("strong", { style: { color: "#22c55e" }, children: "10 rodadas grtis" }), " no Fortune Tiger"] }), g.jsxs("div", { className: "rounded-2xl p-5 mb-4", style: { background: "rgba(20,22,30,0.9)", border: "1px solid rgba(218,165,32,0.25)" }, children: [g.jsxs("div", { className: "space-y-4", children: [g.jsxs("div", { children: [g.jsx("label", { className: "text-[10px] mb-1.5 block uppercase tracking-wider", style: { color: "#888" }, children: "Nome completo" }), g.jsx("input", { type: "text", value: t, onChange: l => n(l.target.value), placeholder: "Seu nome", className: "w-full rounded-xl px-4 py-3 text-white text-sm outline-none", style: { background: "rgba(40,42,55,0.9)", border: "1px solid rgba(100,100,120,0.3)" } })] }), g.jsxs("div", { children: [g.jsx("label", { className: "text-[10px] mb-1.5 block uppercase tracking-wider", style: { color: "#888" }, children: "Nmero de telefone" }), g.jsx("input", { type: "tel", value: r, onChange: l => s(l.target.value), placeholder: "9XX XXX XXX", className: "w-full rounded-xl px-4 py-3 text-white text-sm outline-none", style: { background: "rgba(40,42,55,0.9)", border: "1px solid rgba(100,100,120,0.3)" } })] })] }), g.jsx($.button, { onClick: a, className: "w-full py-3.5 rounded-xl text-base font-bold mt-5", style: { background: !t.trim() || !r.trim() ? "rgba(100,100,100,0.4)" : "linear-gradient(135deg, #FFD700, #DAA520, #FF8C00)", color: !t.trim() || !r.trim() ? "#666" : "#1a0505", fontFamily: "'Russo One', sans-serif", boxShadow: t.trim() && r.trim() ? "0 0 20px rgba(255,215,0,0.3)" : "none" }, whileTap: t.trim() && r.trim() ? { scale: .97 } : {}, children: " Cadastrar e Jogar" })] }), g.jsx("p", { className: "text-[10px] text-center", style: { color: "#555" }, children: "Ao cadastrar-se, voc aceita os termos e condies" }), g.jsx(Cj, {})] }), g.jsx(jl, { children: i && g.jsxs($.div, { className: "fixed inset-0 z-[70] flex items-center justify-center", initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: [g.jsx("div", { className: "absolute inset-0 bg-black/70" }), g.jsxs($.div, { className: "relative z-10 w-full max-w-[340px] mx-4 rounded-2xl p-6 text-center", style: { background: "linear-gradient(180deg, rgba(20,25,15,0.98), rgba(10,15,10,0.99))", border: "1px solid rgba(34,197,94,0.3)", boxShadow: "0 0 40px rgba(34,197,94,0.15)" }, initial: { scale: .7, opacity: 0 }, animate: { scale: 1, opacity: 1 }, transition: { type: "spring", stiffness: 300, damping: 20 }, children: [g.jsx($.div, { className: "text-5xl mb-3", animate: { scale: [1, 1.2, 1], rotate: [0, 10, -10, 0] }, transition: { duration: .6 }, children: "" }), g.jsx("h3", { className: "text-lg font-bold mb-2", style: { color: "#22c55e", fontFamily: "'Russo One', sans-serif" }, children: "Parabns!" }), g.jsx("p", { className: "text-sm mb-1 text-white", children: "Cadastro realizado com sucesso!" }), g.jsxs("p", { className: "text-xs mb-5", style: { color: "#888" }, children: ["Voc ganhou ", g.jsx("strong", { style: { color: "#22c55e" }, children: "10 rodadas grtis" }), " no Fortune Tiger"] }), g.jsx($.p, { className: "text-2xl font-bold mb-5", style: { background: "linear-gradient(180deg, #FFD700, #DAA520)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", fontFamily: "'Orbitron', sans-serif" }, animate: { scale: [1, 1.05, 1] }, transition: { duration: 1.5, repeat: 1 / 0 }, children: " 10 Rodadas Grtis" }), g.jsx($.button, { onClick: e, className: "w-full py-3.5 rounded-xl text-base font-bold", style: { background: "linear-gradient(135deg, #FFD700, #DAA520, #FF8C00)", color: "#1a0505", fontFamily: "'Russo One', sans-serif", boxShadow: "0 0 25px rgba(255,215,0,0.4)" }, whileTap: { scale: .97 }, children: " Comear a Jogar" })] })] }) })] }) }, Pj = () => { const [e, t] = w.useState("welcome"); return e === "welcome" ? g.jsx(Sj, { onStart: () => t("register") }) : e === "register" ? g.jsx(Ej, { onComplete: () => t("game") }) : g.jsx(bj, {}) }, kj = () => { const e = Cx(); return w.useEffect(() => { console.error("404 Error: User attempted to access non-existent route:", e.pathname) }, [e.pathname]), g.jsx("div", { className: "flex min-h-screen items-center justify-center bg-muted", children: g.jsxs("div", { className: "text-center", children: [g.jsx("h1", { className: "mb-4 text-4xl font-bold", children: "404" }), g.jsx("p", { className: "mb-4 text-xl text-muted-foreground", children: "Oops! Page not found" }), g.jsx("a", { href: "/", className: "text-primary underline hover:text-primary/90", children: "Return to Home" })] }) }) }, Aj = new gk, Rj = () => g.jsx(vk, { client: Aj, children: g.jsxs(KP, { children: [g.jsx(RC, {}), g.jsx(aE, {}), g.jsx(r2, { children: g.jsxs(e2, { children: [g.jsx(Bc, { path: "/", element: g.jsx(Pj, {}) }), g.jsx(Bc, { path: "*", element: g.jsx(kj, {}) })] }) })] }) }); Gy(document.getElementById("root")).render(g.jsx(Rj, {}));
